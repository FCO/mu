;; Do not edit this file - Generated by MiniPerl6
;; class Rul
(defpackage mp-Rul
  (:use common-lisp))
;; (in-package mp-Rul)
(if (not (ignore-errors (find-class 'mp-Rul)))
  (defclass mp-Rul () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul))
  (defun proto-mp-Rul () x))
(in-package mp-Rul)
  (defun sv-constant (&optional sv-str )
  (block mp6-function (let ((sv-len nil)) (setf sv-len (chars sv-str ))(if (sv-bool (sv-eq sv-str "\\\\")) (progn (setf sv-str "\\\\\\\\")) (progn ))(if (sv-bool (sv-eq sv-str "\\'")) (progn (setf sv-str "\\\\\\'")) (progn ))(if (sv-bool sv-len) (progn (format nil "~{~a~}" (list "( ( \\'" (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list "\\' eq substr( $str, $MATCH.to, " (format nil "~{~a~}" (list sv-len (format nil "~{~a~}" (list ")) " (format nil "~{~a~}" (list "  ?? (1 + ( $MATCH.to := " (format nil "~{~a~}" (list sv-len (format nil "~{~a~}" (list " + $MATCH.to ))" (format nil "~{~a~}" (list "  !! (0) " ")"))))))))))))))))))) (progn (return-from mp6-function "1"))))))

(in-package mp-Main)



;; class Rul::Quantifier
(defpackage mp-Rul-Quantifier
  (:use common-lisp))
;; (in-package mp-Rul-Quantifier)
(if (not (ignore-errors (find-class 'mp-Rul-Quantifier)))
  (defclass mp-Rul-Quantifier () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Quantifier))
  (defun proto-mp-Rul-Quantifier () x))
;; has $.term
(let ((new-slots (list (list :name 'sv-term
  :readers '(sv-term)
  :writers '((setf sv-term))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.quant
(let ((new-slots (list (list :name 'sv-quant
  :readers '(sv-quant)
  :writers '((setf sv-quant))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.greedy
(let ((new-slots (list (list :name 'sv-greedy
  :readers '(sv-greedy)
  :writers '((setf sv-greedy))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.ws1
(let ((new-slots (list (list :name 'sv-ws1
  :readers '(sv-ws1)
  :writers '((setf sv-ws1))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.ws2
(let ((new-slots (list (list :name 'sv-ws2
  :readers '(sv-ws2)
  :writers '((setf sv-ws2))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.ws3
(let ((new-slots (list (list :name 'sv-ws3
  :readers '(sv-ws3)
  :writers '((setf sv-ws3))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Quantifier))
  (block mp6-function
    (progn (sv-emit (sv-term sv-self) ))))




;; class Rul::Or
(defpackage mp-Rul-Or
  (:use common-lisp))
;; (in-package mp-Rul-Or)
(if (not (ignore-errors (find-class 'mp-Rul-Or)))
  (defclass mp-Rul-Or () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Or))
  (defun proto-mp-Rul-Or () x))
;; has $.or
(let ((new-slots (list (list :name 'sv-or
  :readers '(sv-or)
  :writers '((setf sv-or))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Or)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Or :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Or))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "do { " (format nil "~{~a~}" (list "my $pos1 := $MATCH.to; do{ " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-or sv-self)) "} || do { $MATCH.to := $pos1; ") "} }")))))))))




;; class Rul::Concat
(defpackage mp-Rul-Concat
  (:use common-lisp))
;; (in-package mp-Rul-Concat)
(if (not (ignore-errors (find-class 'mp-Rul-Concat)))
  (defclass mp-Rul-Concat () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Concat))
  (defun proto-mp-Rul-Concat () x))
;; has $.concat
(let ((new-slots (list (list :name 'sv-concat
  :readers '(sv-concat)
  :writers '((setf sv-concat))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Concat)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Concat :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Concat))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-concat sv-self)) " && ") ")")))))))




;; class Rul::Subrule
(defpackage mp-Rul-Subrule
  (:use common-lisp))
;; (in-package mp-Rul-Subrule)
(if (not (ignore-errors (find-class 'mp-Rul-Subrule)))
  (defclass mp-Rul-Subrule () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Subrule))
  (defun proto-mp-Rul-Subrule () x))
;; has $.metasyntax
(let ((new-slots (list (list :name 'sv-metasyntax
  :readers '(sv-metasyntax)
  :writers '((setf sv-metasyntax))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Subrule)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Subrule :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Subrule))
  (block mp6-function
    (let ((sv-meth nil)) (setf sv-meth (if (sv-bool (+ 1 (sv-index (sv-metasyntax sv-self) "."))) (sv-metasyntax sv-self) (format nil "~{~a~}" (list "$grammar." (sv-metasyntax sv-self)))))(format nil "~{~a~}" (list "do { " (format nil "~{~a~}" (list "my $m2 := " (format nil "~{~a~}" (list sv-meth (format nil "~{~a~}" (list "($str, $MATCH.to); " (format nil "~{~a~}" (list "if $m2 { $MATCH.to := $m2.to; $MATCH{\\'" (format nil "~{~a~}" (list (sv-metasyntax sv-self) (format nil "~{~a~}" (list "\\'} := $m2; 1 } else { 0 } " "}")))))))))))))))))




;; class Rul::SubruleNoCapture
(defpackage mp-Rul-SubruleNoCapture
  (:use common-lisp))
;; (in-package mp-Rul-SubruleNoCapture)
(if (not (ignore-errors (find-class 'mp-Rul-SubruleNoCapture)))
  (defclass mp-Rul-SubruleNoCapture () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-SubruleNoCapture))
  (defun proto-mp-Rul-SubruleNoCapture () x))
;; has $.metasyntax
(let ((new-slots (list (list :name 'sv-metasyntax
  :readers '(sv-metasyntax)
  :writers '((setf sv-metasyntax))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-SubruleNoCapture)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-SubruleNoCapture :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-SubruleNoCapture))
  (block mp6-function
    (let ((sv-meth nil)) (setf sv-meth (if (sv-bool (+ 1 (sv-index (sv-metasyntax sv-self) "."))) (sv-metasyntax sv-self) (format nil "~{~a~}" (list "$grammar." (sv-metasyntax sv-self)))))(format nil "~{~a~}" (list "do { " (format nil "~{~a~}" (list "my $m2 := " (format nil "~{~a~}" (list sv-meth (format nil "~{~a~}" (list "($str, $MATCH.to); " (format nil "~{~a~}" (list "if $m2 { $MATCH.to := $m2.to; 1 } else { 0 } " "}")))))))))))))




;; class Rul::Var
(defpackage mp-Rul-Var
  (:use common-lisp))
;; (in-package mp-Rul-Var)
(if (not (ignore-errors (find-class 'mp-Rul-Var)))
  (defclass mp-Rul-Var () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Var))
  (defun proto-mp-Rul-Var () x))
;; has $.sigil
(let ((new-slots (list (list :name 'sv-sigil
  :readers '(sv-sigil)
  :writers '((setf sv-sigil))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Var :direct-slots new-slots))

;; has $.twigil
(let ((new-slots (list (list :name 'sv-twigil
  :readers '(sv-twigil)
  :writers '((setf sv-twigil))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Var :direct-slots new-slots))

;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Var :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Var))
  (block mp6-function
    (let ((sv-table nil)) (setf sv-table (let ((h (make-hash-table :test 'equal))) (setf (gethash "$" h) "$")(setf (gethash "@" h) "$List_")(setf (gethash "%" h) "$Hash_")(setf (gethash "&" h) "$Code_") h))(format nil "~{~a~}" (list (gethash (sv-sigil sv-self) sv-table) (sv-name sv-self))))))




;; class Rul::Constant
(defpackage mp-Rul-Constant
  (:use common-lisp))
;; (in-package mp-Rul-Constant)
(if (not (ignore-errors (find-class 'mp-Rul-Constant)))
  (defclass mp-Rul-Constant () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Constant))
  (defun proto-mp-Rul-Constant () x))
;; has $.constant
(let ((new-slots (list (list :name 'sv-constant
  :readers '(sv-constant)
  :writers '((setf sv-constant))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Constant)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Constant :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Constant))
  (block mp6-function
    (let ((sv-str nil)) (setf sv-str (sv-constant sv-self))(mp-Rul::sv-constant sv-str))))




;; class Rul::Dot
(defpackage mp-Rul-Dot
  (:use common-lisp))
;; (in-package mp-Rul-Dot)
(if (not (ignore-errors (find-class 'mp-Rul-Dot)))
  (defclass mp-Rul-Dot () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Dot))
  (defun proto-mp-Rul-Dot () x))
;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Dot))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "( (\\'\\' ne substr( $str, $MATCH.to, 1 )) " (format nil "~{~a~}" (list "  ?? (1 + ($MATCH.to := 1 + $MATCH.to ))" (format nil "~{~a~}" (list "  !! (0) " ")")))))))))




;; class Rul::SpecialChar
(defpackage mp-Rul-SpecialChar
  (:use common-lisp))
;; (in-package mp-Rul-SpecialChar)
(if (not (ignore-errors (find-class 'mp-Rul-SpecialChar)))
  (defclass mp-Rul-SpecialChar () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-SpecialChar))
  (defun proto-mp-Rul-SpecialChar () x))
;; has $.char
(let ((new-slots (list (list :name 'sv-char
  :readers '(sv-char)
  :writers '((setf sv-char))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-SpecialChar)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-SpecialChar :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-SpecialChar))
  (block mp6-function
    (let ((sv-char nil)) (setf sv-char (sv-char sv-self))(if (sv-bool (sv-eq sv-char "n")) (let ((sv-rul nil)) (setf sv-rul (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) "newline") m))(setf sv-rul (sv-emit sv-rul ))(return-from mp6-function sv-rul)) (progn ))(if (sv-bool (sv-eq sv-char "N")) (let ((sv-rul nil)) (setf sv-rul (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) "not_newline") m))(setf sv-rul (sv-emit sv-rul ))(return-from mp6-function sv-rul)) (progn ))(if (sv-bool (sv-eq sv-char "d")) (let ((sv-rul nil)) (setf sv-rul (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) "digit") m))(setf sv-rul (sv-emit sv-rul ))(return-from mp6-function sv-rul)) (progn ))(if (sv-bool (sv-eq sv-char "s")) (let ((sv-rul nil)) (setf sv-rul (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) "space") m))(setf sv-rul (sv-emit sv-rul ))(return-from mp6-function sv-rul)) (progn ))(return-from mp6-function (mp-Rul::sv-constant sv-char)))))




;; class Rul::Block
(defpackage mp-Rul-Block
  (:use common-lisp))
;; (in-package mp-Rul-Block)
(if (not (ignore-errors (find-class 'mp-Rul-Block)))
  (defclass mp-Rul-Block () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Block))
  (defun proto-mp-Rul-Block () x))
;; has $.closure
(let ((new-slots (list (list :name 'sv-closure
  :readers '(sv-closure)
  :writers '((setf sv-closure))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Block)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Block :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Block))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "do { " (format nil "~{~a~}" (list "my $ret := ( sub {" (format nil "~{~a~}" (list "do {" (format nil "~{~a~}" (list (sv-closure sv-self) (format nil "~{~a~}" (list "}; " (format nil "~{~a~}" (list "\\'974^213\\' } ).();" (format nil "~{~a~}" (list "if $ret ne \\'974^213\\' {" (format nil "~{~a~}" (list "$MATCH.capture := $ret; " (format nil "~{~a~}" (list "$MATCH.bool := 1; " (format nil "~{~a~}" (list "return $MATCH;" (format nil "~{~a~}" (list "};" (format nil "~{~a~}" (list "1" "}")))))))))))))))))))))))))))




;; class Rul::InterpolateVar
(defpackage mp-Rul-InterpolateVar
  (:use common-lisp))
;; (in-package mp-Rul-InterpolateVar)
(if (not (ignore-errors (find-class 'mp-Rul-InterpolateVar)))
  (defclass mp-Rul-InterpolateVar () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-InterpolateVar))
  (defun proto-mp-Rul-InterpolateVar () x))
;; has $.var
(let ((new-slots (list (list :name 'sv-var
  :readers '(sv-var)
  :writers '((setf sv-var))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-InterpolateVar)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-InterpolateVar :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-InterpolateVar))
  (block mp6-function
    (progn (format t "~{~a~}~%" (list (format nil "~{~a~}" (list "# TODO: interpolate var " (format nil "~{~a~}" (list (sv-emit (sv-var sv-self) ) ""))))))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit)))))




;; class Rul::NamedCapture
(defpackage mp-Rul-NamedCapture
  (:use common-lisp))
;; (in-package mp-Rul-NamedCapture)
(if (not (ignore-errors (find-class 'mp-Rul-NamedCapture)))
  (defclass mp-Rul-NamedCapture () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-NamedCapture))
  (defun proto-mp-Rul-NamedCapture () x))
;; has $.rule
(let ((new-slots (list (list :name 'sv-rule
  :readers '(sv-rule)
  :writers '((setf sv-rule))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-NamedCapture)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-NamedCapture :direct-slots new-slots))

;; has $.ident
(let ((new-slots (list (list :name 'sv-ident
  :readers '(sv-ident)
  :writers '((setf sv-ident))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-NamedCapture)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-NamedCapture :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-NamedCapture))
  (block mp6-function
    (progn (format t "~{~a~}~%" (list (format nil "~{~a~}" (list "# TODO: named capture " (format nil "~{~a~}" (list (sv-ident sv-self) (format nil "~{~a~}" (list " := " (format nil "~{~a~}" (list (sv-emit (sv-rule sv-self) ) ""))))))))))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit)))))




;; class Rul::Before
(defpackage mp-Rul-Before
  (:use common-lisp))
;; (in-package mp-Rul-Before)
(if (not (ignore-errors (find-class 'mp-Rul-Before)))
  (defclass mp-Rul-Before () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Before))
  (defun proto-mp-Rul-Before () x))
;; has $.rule
(let ((new-slots (list (list :name 'sv-rule
  :readers '(sv-rule)
  :writers '((setf sv-rule))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Before)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Before :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Before))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "do { " (format nil "~{~a~}" (list "my $tmp := $MATCH; " (format nil "~{~a~}" (list "$MATCH := ::MiniPerl6::Match( \\'str\\' => $str, \\'from\\' => $tmp.to, \\'to\\' => $tmp.to, \\'bool\\' => 1  ); " (format nil "~{~a~}" (list "$MATCH.bool := " (format nil "~{~a~}" (list (sv-emit (sv-rule sv-self) ) (format nil "~{~a~}" (list "; " (format nil "~{~a~}" (list "$tmp.bool := ?$MATCH; " (format nil "~{~a~}" (list "$MATCH := $tmp; " (format nil "~{~a~}" (list "?$MATCH; " "}")))))))))))))))))))))




;; class Rul::NotBefore
(defpackage mp-Rul-NotBefore
  (:use common-lisp))
;; (in-package mp-Rul-NotBefore)
(if (not (ignore-errors (find-class 'mp-Rul-NotBefore)))
  (defclass mp-Rul-NotBefore () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-NotBefore))
  (defun proto-mp-Rul-NotBefore () x))
;; has $.rule
(let ((new-slots (list (list :name 'sv-rule
  :readers '(sv-rule)
  :writers '((setf sv-rule))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-NotBefore)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-NotBefore :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-NotBefore))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "do { " (format nil "~{~a~}" (list "my $tmp := $MATCH; " (format nil "~{~a~}" (list "$MATCH := ::MiniPerl6::Match( \\'str\\' => $str, \\'from\\' => $tmp.to, \\'to\\' => $tmp.to, \\'bool\\' => 1  ); " (format nil "~{~a~}" (list "$MATCH.bool := " (format nil "~{~a~}" (list (sv-emit (sv-rule sv-self) ) (format nil "~{~a~}" (list "; " (format nil "~{~a~}" (list "$tmp.bool := !$MATCH; " (format nil "~{~a~}" (list "$MATCH := $tmp; " (format nil "~{~a~}" (list "?$MATCH; " "}")))))))))))))))))))))




;; class Rul::NegateCharClass
(defpackage mp-Rul-NegateCharClass
  (:use common-lisp))
;; (in-package mp-Rul-NegateCharClass)
(if (not (ignore-errors (find-class 'mp-Rul-NegateCharClass)))
  (defclass mp-Rul-NegateCharClass () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-NegateCharClass))
  (defun proto-mp-Rul-NegateCharClass () x))
;; has $.chars
(let ((new-slots (list (list :name 'sv-chars
  :readers '(sv-chars)
  :writers '((setf sv-chars))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-NegateCharClass)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-NegateCharClass :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-NegateCharClass))
  (block mp6-function
    (progn (format t "~{~a~}~%" (list "TODO NegateCharClass"))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit)))))




;; class Rul::CharClass
(defpackage mp-Rul-CharClass
  (:use common-lisp))
;; (in-package mp-Rul-CharClass)
(if (not (ignore-errors (find-class 'mp-Rul-CharClass)))
  (defclass mp-Rul-CharClass () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-CharClass))
  (defun proto-mp-Rul-CharClass () x))
;; has $.chars
(let ((new-slots (list (list :name 'sv-chars
  :readers '(sv-chars)
  :writers '((setf sv-chars))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-CharClass)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-CharClass :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-CharClass))
  (block mp6-function
    (progn (format t "~{~a~}~%" (list "TODO CharClass"))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit)))))




;; class Rul::Capture
(defpackage mp-Rul-Capture
  (:use common-lisp))
;; (in-package mp-Rul-Capture)
(if (not (ignore-errors (find-class 'mp-Rul-Capture)))
  (defclass mp-Rul-Capture () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Capture))
  (defun proto-mp-Rul-Capture () x))
;; has $.rule
(let ((new-slots (list (list :name 'sv-rule
  :readers '(sv-rule)
  :writers '((setf sv-rule))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Capture)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Capture :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Capture))
  (block mp6-function
    (progn (format t "~{~a~}~%" (list "TODO RulCapture"))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit)))))




