;; Do not edit this file - Generated by MiniPerl6
;; class MiniPerl6::Grammar
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp mp-Main))
;; (in-package mp-MiniPerl6-Grammar)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
;; method pair_key
(if (not (ignore-errors (find-method 'sv-pair_key () ())))
  (defgeneric sv-pair_key (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-pair_key ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "=>" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil)))))))(setf (sv-bool sv-tmp ) (sv-bool sv-MATCH))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (sv-or (progn (setf (sv-capture sv-MATCH) (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (sv-string (gethash "ident" (sv-hash sv-MATCH)))) m))) 1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))) 1))))))sv-MATCH)))

;; method pair
(if (not (ignore-errors (find-method 'sv-pair () ())))
  (defgeneric sv-pair (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-pair ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-pair_key sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "pair_key" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "=>" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'list  (list (sv-scalar (gethash "pair_key" (sv-hash sv-MATCH)))) (list (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))))) 1))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_sigil sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "var_sigil" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'list  (list (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (sv-string (gethash "ident" (sv-hash sv-MATCH)))) m)) (list (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (sv-string (sv-scalar (gethash "var_sigil" (sv-hash sv-MATCH)))))(setf (sv-twigil m) "")(setf (sv-name m) (sv-scalar (gethash "ident" (sv-hash sv-MATCH)))) m))))) 1))))))))sv-MATCH)))

;; method exp_mapping
(if (not (ignore-errors (find-method 'sv-exp_mapping () ())))
  (defgeneric sv-exp_mapping (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-exp_mapping ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-pair sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "pair" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-exp_mapping sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_mapping" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'list  (list (sv-scalar (gethash "pair" (sv-hash sv-MATCH)))) (sv-scalar (gethash "exp_mapping" (sv-hash sv-MATCH)))))) 1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-or (progn (setf (sv-capture sv-MATCH) (concatenate 'list  (list (sv-scalar (gethash "pair" (sv-hash sv-MATCH))))))) 1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-or (progn (setf (sv-capture sv-MATCH) nil)) 1)))))sv-MATCH)))

(defmethod sv-perl ((self mp-MiniPerl6-Grammar))
  (mp-Main::sv-lisp_dump_object "::MiniPerl6::Grammar" (list )))




