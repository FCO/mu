;; Do not edit this file - Generated by MiniPerl6
;; class MiniPerl6::Grammar
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp))
;; (in-package mp-MiniPerl6-Grammar)
(let ((sv-Class_name nil))
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
(in-package mp-MiniPerl6-Grammar)
  (defun sv-get_class_name ()
  (block mp6-function (progn sv-Class_name)))

(in-package mp-Main)
;; method ident_digit
(if (not (ignore-errors (find-method 'sv-ident_digit () ())))
  (defgeneric sv-ident_digit (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-ident_digit ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-word sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "_" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 nil)) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))))) (let ((sv-m2 nil)) (setf sv-m2 (sv-ident_digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))))(return-from mp6-function sv-MATCH))))

;; method ident
(if (not (ignore-errors (find-method 'sv-ident () ())))
  (defgeneric sv-ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-word sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "_" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)))) (let ((sv-m2 nil)) (setf sv-m2 (sv-ident_digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))))))(return-from mp6-function sv-MATCH))))

;; method full_ident
(if (not (ignore-errors (find-method 'sv-full_ident () ())))
  (defgeneric sv-full_ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-full_ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))))(return-from mp6-function sv-MATCH))))

;; method to_line_end
(if (not (ignore-errors (find-method 'sv-to_line_end () ())))
  (defgeneric sv-to_line_end (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-to_line_end ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-not_newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (let ((sv-m2 nil)) (setf sv-m2 (sv-to_line_end sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))(return-from mp6-function sv-MATCH))))

;; method pod_begin
(if (not (ignore-errors (find-method 'sv-pod_begin () ())))
  (defgeneric sv-pod_begin (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-pod_begin ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "=end" (sv-substr sv-str (sv-to sv-MATCH ) 4))) (+ 1 (setf (sv-to sv-MATCH ) (+ 4 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-to_line_end sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-to_line_end sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (let ((sv-m2 nil)) (setf sv-m2 (sv-pod_begin sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))))))))(return-from mp6-function sv-MATCH))))

;; method pod_other
(if (not (ignore-errors (find-method 'sv-pod_other () ())))
  (defgeneric sv-pod_other (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-pod_other ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "=cut" (sv-substr sv-str (sv-to sv-MATCH ) 4))) (+ 1 (setf (sv-to sv-MATCH ) (+ 4 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-to_line_end sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-to_line_end sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (let ((sv-m2 nil)) (setf sv-m2 (sv-pod_other sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))))))))(return-from mp6-function sv-MATCH))))

;; method ws
(if (not (ignore-errors (find-method 'sv-ws () ())))
  (defgeneric sv-ws (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-ws ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "#" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-to_line_end sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-newline sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "=begin" (sv-substr sv-str (sv-to sv-MATCH ) 6))) (+ 1 (setf (sv-to sv-MATCH ) (+ 6 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-pod_begin sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "=kwid" (sv-substr sv-str (sv-to sv-MATCH ) 5))) (+ 1 (setf (sv-to sv-MATCH ) (+ 5 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-pod_other sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "=pod" (sv-substr sv-str (sv-to sv-MATCH ) 4))) (+ 1 (setf (sv-to sv-MATCH ) (+ 4 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-pod_other sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "=for" (sv-substr sv-str (sv-to sv-MATCH ) 4))) (+ 1 (setf (sv-to sv-MATCH ) (+ 4 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-pod_other sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "=head1" (sv-substr sv-str (sv-to sv-MATCH ) 6))) (+ 1 (setf (sv-to sv-MATCH ) (+ 6 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-pod_other sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 nil)) (setf sv-m2 (sv-space sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))))(return-from mp6-function sv-MATCH))))

;; method opt_ws
(if (not (ignore-errors (find-method 'sv-opt_ws () ())))
  (defgeneric sv-opt_ws (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-opt_ws ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))(return-from mp6-function sv-MATCH))))

;; method opt_ws2
(if (not (ignore-errors (find-method 'sv-opt_ws2 () ())))
  (defgeneric sv-opt_ws2 (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-opt_ws2 ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))(return-from mp6-function sv-MATCH))))

;; method opt_ws3
(if (not (ignore-errors (find-method 'sv-opt_ws3 () ())))
  (defgeneric sv-opt_ws3 (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-opt_ws3 ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))(return-from mp6-function sv-MATCH))))

;; method parse
(if (not (ignore-errors (find-method 'sv-parse () ())))
  (defgeneric sv-parse (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-parse ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-comp_unit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "comp_unit" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-parse sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "parse" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "comp_unit" (sv-hash sv-MATCH))) (sv-scalar (gethash "parse" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "comp_unit" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list )))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))

;; method comp_unit
(if (not (ignore-errors (find-method 'sv-comp_unit () ())))
  (defgeneric sv-comp_unit (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-comp_unit ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "use" (sv-substr sv-str (sv-to sv-MATCH ) 3))) (+ 1 (setf (sv-to sv-MATCH ) (+ 3 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "v6-" (sv-substr sv-str (sv-to sv-MATCH ) 3))) (+ 1 (setf (sv-to sv-MATCH ) (+ 3 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "class" (sv-substr sv-str (sv-to sv-MATCH ) 5))) (+ 1 (setf (sv-to sv-MATCH ) (+ 5 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "grammar" (sv-substr sv-str (sv-to sv-MATCH ) 7))) (+ 1 (setf (sv-to sv-MATCH ) (+ 7 (sv-to sv-MATCH )))) 0)))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (setf sv-Class_name (format nil "~{~a~}" (list (gethash "full_ident" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_stmts" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-CompUnit))) (setf (sv-name m) (sv-scalar (gethash "full_ident" (sv-hash sv-MATCH))))(setf (sv-attributes m) (let ((h (make-hash-table :test 'equal)))  h))(setf (sv-methods m) (let ((h (make-hash-table :test 'equal)))  h))(setf (sv-body m) (sv-scalar (gethash "exp_stmts" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))))))))))))))(return-from mp6-function sv-MATCH))))

;; method infix_op
(if (not (ignore-errors (find-method 'sv-infix_op () ())))
  (defgeneric sv-infix_op (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-infix_op ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "*" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "/" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (if (sv-bool (sv-eq "q" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "n" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "==" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "!=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "&&" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "||" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "~~" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "~" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "x" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)))))))))))))))))(return-from mp6-function sv-MATCH))))

;; method hyper_op
(if (not (ignore-errors (find-method 'sv-hyper_op () ())))
  (defgeneric sv-hyper_op (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-hyper_op ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq ">>" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))(return-from mp6-function sv-MATCH))))

;; method prefix_op
(if (not (ignore-errors (find-method 'sv-prefix_op () ())))
  (defgeneric sv-prefix_op (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-prefix_op ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "$" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "@" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "%" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "?" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "!" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "++" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "--" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "~" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)))))))))))) (let ((sv-tmp nil)) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "$" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)))))(setf (sv-bool sv-tmp ) (sv-bool sv-MATCH ))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH ))))))(return-from mp6-function sv-MATCH))))

;; method declarator
(if (not (ignore-errors (find-method 'sv-declarator () ())))
  (defgeneric sv-declarator (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-declarator ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "my" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "state" (sv-substr sv-str (sv-to sv-MATCH ) 5))) (+ 1 (setf (sv-to sv-MATCH ) (+ 5 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "has" (sv-substr sv-str (sv-to sv-MATCH ) 3))) (+ 1 (setf (sv-to sv-MATCH ) (+ 3 (sv-to sv-MATCH )))) 0))))))(return-from mp6-function sv-MATCH))))

;; method exp2
(if (not (ignore-errors (find-method 'sv-exp2 () ())))
  (defgeneric sv-exp2 (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-exp2 ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "exp" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))

;; method exp_stmts2
(if (not (ignore-errors (find-method 'sv-exp_stmts2 () ())))
  (defgeneric sv-exp_stmts2 (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-exp_stmts2 ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_stmts" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "exp_stmts" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))


;; use mp-MiniPerl6-Grammar-Regex


;; use mp-MiniPerl6-Grammar-Mapping


;; use mp-MiniPerl6-Grammar-Control

)


;; class MiniPerl6::Grammar
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp))
;; (in-package mp-MiniPerl6-Grammar)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
;; method exp
(if (not (ignore-errors (find-method 'sv-exp () ())))
  (defgeneric sv-exp (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-exp ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-term_meth sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "term_meth" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "??" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "!!" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp2 sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp2" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) "ternary:<?? !!>")(setf (sv-arguments m) (list (sv-scalar (gethash "term_meth" (sv-hash sv-MATCH))) (sv-scalar (gethash "exp" (sv-hash sv-MATCH))) (sv-scalar (gethash "exp2" (sv-hash sv-MATCH))))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (format t "~{~a~}~%" (list "*** Syntax error in ternary operation")))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-infix_op sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "infix_op" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) (format nil "~{~a~}" (list "infix:<" (format nil "~{~a~}" (list (gethash "infix_op" (sv-hash sv-MATCH)) ">")))))(setf (sv-arguments m) (list (sv-scalar (gethash "term_meth" (sv-hash sv-MATCH))) (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq ":=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (sv-scalar (gethash "term_meth" (sv-hash sv-MATCH))))(setf (sv-arguments m) (sv-scalar (gethash "exp" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "term_meth" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))))(return-from mp6-function sv-MATCH))))

;; method opt_ident
(if (not (ignore-errors (find-method 'sv-opt_ident () ())))
  (defgeneric sv-opt_ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-opt_ident ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "ident" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and 1 (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function "postcircumfix:<( )>"))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))(return-from mp6-function sv-MATCH))))

;; method term_meth
(if (not (ignore-errors (find-method 'sv-term_meth () ())))
  (defgeneric sv-term_meth (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-term_meth ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq ".new(" (sv-substr sv-str (sv-to sv-MATCH ) 5))) (+ 1 (setf (sv-to sv-MATCH ) (+ 5 (sv-to sv-MATCH )))) 0) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_mapping sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_mapping" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Lit-Object))) (setf (sv-class m) (sv-scalar (gethash "full_ident" (sv-hash sv-MATCH))))(setf (sv-fields m) (sv-scalar (gethash "exp_mapping" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (format t "~{~a~}~%" (list "*** Syntax Error parsing Constructor"))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-hyper_op sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "hyper_op" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (let ((m (make-instance 'mp-Proto))) (setf (sv-name m) (format nil "~{~a~}" (list (gethash "full_ident" (sv-hash sv-MATCH))))) m))(setf (sv-method m) (sv-scalar (gethash "ident" (sv-hash sv-MATCH))))(setf (sv-arguments m) nil)(setf (sv-hyper m) (sv-scalar (gethash "hyper_op" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (let ((m (make-instance 'mp-Proto))) (setf (sv-name m) (format nil "~{~a~}" (list (gethash "full_ident" (sv-hash sv-MATCH))))) m))(setf (sv-method m) (sv-scalar (gethash "ident" (sv-hash sv-MATCH))))(setf (sv-arguments m) (sv-scalar (gethash "exp_seq" (sv-hash sv-MATCH))))(setf (sv-hyper m) (sv-scalar (gethash "hyper_op" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-term sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "term" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-hyper_op sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "hyper_op" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "opt_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (sv-scalar (gethash "term" (sv-hash sv-MATCH))))(setf (sv-method m) (sv-scalar (gethash "opt_ident" (sv-hash sv-MATCH))))(setf (sv-arguments m) nil)(setf (sv-hyper m) (sv-scalar (gethash "hyper_op" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (sv-scalar (gethash "term" (sv-hash sv-MATCH))))(setf (sv-method m) (sv-scalar (gethash "opt_ident" (sv-hash sv-MATCH))))(setf (sv-arguments m) (sv-scalar (gethash "exp_seq" (sv-hash sv-MATCH))))(setf (sv-hyper m) (sv-scalar (gethash "hyper_op" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "[" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Index))) (setf (sv-obj m) (sv-scalar (gethash "term" (sv-hash sv-MATCH))))(setf (sv-index m) (sv-scalar (gethash "exp" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Lookup))) (setf (sv-obj m) (sv-scalar (gethash "term" (sv-hash sv-MATCH))))(setf (sv-index m) (sv-scalar (gethash "exp" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "term" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))))))(return-from mp6-function sv-MATCH))))

;; method sub_or_method_name
(if (not (ignore-errors (find-method 'sv-sub_or_method_name () ())))
  (defgeneric sv-sub_or_method_name (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-sub_or_method_name ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))))(return-from mp6-function sv-MATCH))))

;; method opt_type
(if (not (ignore-errors (find-method 'sv-opt_type () ())))
  (defgeneric sv-opt_type (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-opt_type ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "full_ident" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and 1 (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function ""))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))(return-from mp6-function sv-MATCH))))

;; method term
(if (not (ignore-errors (find-method 'sv-term () ())))
  (defgeneric sv-term (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-term ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-var sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "var" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "var" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-prefix_op sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "prefix_op" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) (format nil "~{~a~}" (list "prefix:<" (format nil "~{~a~}" (list (gethash "prefix_op" (sv-hash sv-MATCH)) ">")))))(setf (sv-arguments m) (list (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "exp" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_mapping sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_mapping" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Lit-Hash))) (setf (sv-hash m) (sv-scalar (gethash "exp_mapping" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "[" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Lit-Array))) (setf (sv-array m) (sv-scalar (gethash "exp_seq" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "$" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "<" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-sub_or_method_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "sub_or_method_name" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Lookup))) (setf (sv-obj m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) "$")(setf (sv-twigil m) "")(setf (sv-name m) "/") m))(setf (sv-index m) (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (sv-scalar (gethash "sub_or_method_name" (sv-hash sv-MATCH)))) m)) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "d" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "o" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_stmts" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Do))) (setf (sv-block m) (sv-scalar (gethash "exp_stmts" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-declarator sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "declarator" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_type sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "opt_type" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-var sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "var" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Decl))) (setf (sv-decl m) (sv-scalar (gethash "declarator" (sv-hash sv-MATCH))))(setf (sv-type m) (sv-scalar (gethash "opt_type" (sv-hash sv-MATCH))))(setf (sv-var m) (sv-scalar (gethash "var" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "u" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "s" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "-" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Use))) (setf (sv-mod m) (sv-scalar (gethash "full_ident" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-val sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "val" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "val" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-lit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "lit" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "lit" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-token sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "token" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "token" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-method sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "method" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "method" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-sub sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "sub" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "sub" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-control sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "control" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "control" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-apply sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "apply" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "apply" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))))))))))))))(return-from mp6-function sv-MATCH))))




;; class MiniPerl6::Grammar
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp))
;; (in-package mp-MiniPerl6-Grammar)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
;; method sigil
(if (not (ignore-errors (find-method 'sv-sigil () ())))
  (defgeneric sv-sigil (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-sigil ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "$" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "%" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "@" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "&" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)))))))(return-from mp6-function sv-MATCH))))

;; method twigil
(if (not (ignore-errors (find-method 'sv-twigil () ())))
  (defgeneric sv-twigil (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-twigil ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "!" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "^" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "*" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))(return-from mp6-function sv-MATCH))))

;; method var_name
(if (not (ignore-errors (find-method 'sv-var_name () ())))
  (defgeneric sv-var_name (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-var_name ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "/" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 nil)) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "digit" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))))))))(return-from mp6-function sv-MATCH))))

;; method var
(if (not (ignore-errors (find-method 'sv-var () ())))
  (defgeneric sv-var (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-var ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-sigil sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "sigil" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-twigil sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "twigil" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-var_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "var_name" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (format nil "~{~a~}" (list (gethash "sigil" (sv-hash sv-MATCH)))))(setf (sv-twigil m) (format nil "~{~a~}" (list (gethash "twigil" (sv-hash sv-MATCH)))))(setf (sv-name m) (format nil "~{~a~}" (list (gethash "var_name" (sv-hash sv-MATCH))))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))(return-from mp6-function sv-MATCH))))

;; method val
(if (not (ignore-errors (find-method 'sv-val () ())))
  (defgeneric sv-val (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-val ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-val_undef sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "val_undef" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "val_undef" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-val_int sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "val_int" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "val_int" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-val_bit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "val_bit" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "val_bit" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-val_num sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "val_num" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "val_num" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-val_buf sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "val_buf" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "val_buf" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))))(return-from mp6-function sv-MATCH))))

;; method val_bit
(if (not (ignore-errors (find-method 'sv-val_bit () ())))
  (defgeneric sv-val_bit (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-val_bit ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "T" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "r" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "u" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Val-Bit))) (setf (sv-bit m) 1) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "F" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "a" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "l" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "s" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Val-Bit))) (setf (sv-bit m) 0) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))))(return-from mp6-function sv-MATCH))))




;; class MiniPerl6::Grammar
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp))
;; (in-package mp-MiniPerl6-Grammar)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
;; method val_undef
(if (not (ignore-errors (find-method 'sv-val_undef () ())))
  (defgeneric sv-val_undef (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-val_undef ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "u" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "n" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "d" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "f" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-tmp nil)) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "w" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH )))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH )) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Val-Undef)))  m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))))(return-from mp6-function sv-MATCH))))

;; method val_num
(if (not (ignore-errors (find-method 'sv-val_num () ())))
  (defgeneric sv-val_num (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-val_num ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function "TODO: val_num"))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))(return-from mp6-function sv-MATCH))))

;; method double_quoted
(if (not (ignore-errors (find-method 'sv-double_quoted () ())))
  (defgeneric sv-double_quoted (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-double_quoted ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\\\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-double_quoted sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "double_quoted" (sv-hash sv-MATCH)) sv-m2)1) (progn 0)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp nil)) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "\"" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH )))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH )) (sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-double_quoted sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "double_quoted" (sv-hash sv-MATCH)) sv-m2)1) (progn 0)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))(return-from mp6-function sv-MATCH))))

;; method single_quoted
(if (not (ignore-errors (find-method 'sv-single_quoted () ())))
  (defgeneric sv-single_quoted (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-single_quoted ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\\\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-single_quoted sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "single_quoted" (sv-hash sv-MATCH)) sv-m2)1) (progn 0)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp nil)) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "\\'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH )))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH )) (sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-single_quoted sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "single_quoted" (sv-hash sv-MATCH)) sv-m2)1) (progn 0)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))(return-from mp6-function sv-MATCH))))

;; method digits
(if (not (ignore-errors (find-method 'sv-digits () ())))
  (defgeneric sv-digits (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-digits ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-digits sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "digits" (sv-hash sv-MATCH)) sv-m2)1) (progn 0)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))))(return-from mp6-function sv-MATCH))))

;; method val_buf
(if (not (ignore-errors (find-method 'sv-val_buf () ())))
  (defgeneric sv-val_buf (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-val_buf ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\"" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-double_quoted sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "double_quoted" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (if (sv-bool (sv-eq "\"" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (format nil "~{~a~}" (list (gethash "double_quoted" (sv-hash sv-MATCH))))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "\\'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-single_quoted sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "single_quoted" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (if (sv-bool (sv-eq "\\'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (format nil "~{~a~}" (list (gethash "single_quoted" (sv-hash sv-MATCH))))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))(return-from mp6-function sv-MATCH))))

;; method val_int
(if (not (ignore-errors (find-method 'sv-val_int () ())))
  (defgeneric sv-val_int (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-val_int ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-digits sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "digits" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Val-Int))) (setf (sv-int m) (format nil "~{~a~}" (list sv-MATCH))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))

;; method exp_stmts
(if (not (ignore-errors (find-method 'sv-exp_stmts () ())))
  (defgeneric sv-exp_stmts (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-exp_stmts ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_stmts" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "exp" (sv-hash sv-MATCH))) (sv-scalar (gethash "exp_stmts" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq ";" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list )))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))

;; method exp_seq
(if (not (ignore-errors (find-method 'sv-exp_seq () ())))
  (defgeneric sv-exp_seq (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-exp_seq ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "exp" (sv-hash sv-MATCH))) (sv-scalar (gethash "exp_seq" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list )))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))




;; class MiniPerl6::Grammar
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp))
;; (in-package mp-MiniPerl6-Grammar)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
;; method lit
(if (not (ignore-errors (find-method 'sv-lit () ())))
  (defgeneric sv-lit (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-lit ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-lit_object sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "lit_object" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "lit_object" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))

;; method lit_seq
(if (not (ignore-errors (find-method 'sv-lit_seq () ())))
  (defgeneric sv-lit_seq (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-lit_seq ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function "TODO: lit_seq"))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))(return-from mp6-function sv-MATCH))))

;; method lit_array
(if (not (ignore-errors (find-method 'sv-lit_array () ())))
  (defgeneric sv-lit_array (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-lit_array ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function "TODO: lit_array"))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))(return-from mp6-function sv-MATCH))))

;; method lit_hash
(if (not (ignore-errors (find-method 'sv-lit_hash () ())))
  (defgeneric sv-lit_hash (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-lit_hash ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function "TODO: lit_hash"))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))(return-from mp6-function sv-MATCH))))

;; method lit_code
(if (not (ignore-errors (find-method 'sv-lit_code () ())))
  (defgeneric sv-lit_code (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-lit_code ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "X" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function "TODO - Lit::Code"))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))(return-from mp6-function sv-MATCH))))

;; method lit_object
(if (not (ignore-errors (find-method 'sv-lit_object () ())))
  (defgeneric sv-lit_object (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-lit_object ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "::" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_mapping sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_mapping" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Lit-Object))) (setf (sv-class m) (sv-scalar (gethash "full_ident" (sv-hash sv-MATCH))))(setf (sv-fields m) (sv-scalar (gethash "exp_mapping" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (format t "~{~a~}~%" (list "*** Syntax Error parsing Constructor"))(progn (write-line (format nil "~{~a~}" (list )) *error-output*) (sb-ext:quit)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))))(return-from mp6-function sv-MATCH))))

;; method bind
(if (not (ignore-errors (find-method 'sv-bind () ())))
  (defgeneric sv-bind (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-bind ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq ":=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp2 sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp2" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))(setf (sv-arguments m) (sv-scalar (gethash "exp2" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))))(return-from mp6-function sv-MATCH))))

;; method call
(if (not (ignore-errors (find-method 'sv-call () ())))
  (defgeneric sv-call (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-call ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))(setf (sv-method m) (sv-scalar (gethash "ident" (sv-hash sv-MATCH))))(setf (sv-arguments m) (sv-scalar (gethash "exp_seq" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))))))(return-from mp6-function sv-MATCH))))

;; method apply
(if (not (ignore-errors (find-method 'sv-apply () ())))
  (defgeneric sv-apply (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-apply ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-full_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))))))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) (sv-scalar (gethash "full_ident" (sv-hash sv-MATCH))))(setf (sv-arguments m) (sv-scalar (gethash "exp_seq" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) (sv-scalar (gethash "full_ident" (sv-hash sv-MATCH))))(setf (sv-arguments m) (list )) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))(return-from mp6-function sv-MATCH))))

;; method opt_name
(if (not (ignore-errors (find-method 'sv-opt_name () ())))
  (defgeneric sv-opt_name (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-opt_name ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))))(return-from mp6-function sv-MATCH))))

;; method invocant
(if (not (ignore-errors (find-method 'sv-invocant () ())))
  (defgeneric sv-invocant (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-invocant ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-var sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "var" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "var" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) "$")(setf (sv-twigil m) "")(setf (sv-name m) "self") m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))

;; method sig
(if (not (ignore-errors (find-method 'sv-sig () ())))
  (defgeneric sv-sig (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-sig ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-invocant sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "invocant" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_seq sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_seq" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Sig))) (setf (sv-invocant m) (sv-scalar (gethash "invocant" (sv-hash sv-MATCH))))(setf (sv-positional m) (sv-scalar (gethash "exp_seq" (sv-hash sv-MATCH))))(setf (sv-named m) (let ((h (make-hash-table :test 'equal)))  h)) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))(return-from mp6-function sv-MATCH))))

;; method method_sig
(if (not (ignore-errors (find-method 'sv-method_sig () ())))
  (defgeneric sv-method_sig (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-method_sig ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-sig sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "sig" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "sig" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Sig))) (setf (sv-invocant m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) "$")(setf (sv-twigil m) "")(setf (sv-name m) "self") m))(setf (sv-positional m) (list ))(setf (sv-named m) (let ((h (make-hash-table :test 'equal)))  h)) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))

;; method method
(if (not (ignore-errors (find-method 'sv-method () ())))
  (defgeneric sv-method (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-method ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "m" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "t" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "h" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "o" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "d" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "opt_name" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-method_sig sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "method_sig" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_stmts" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (format t "~{~a~}~%" (list "*** Syntax Error in method \\'" (sv-get_class_name ) "." (sv-scalar (gethash "name" (sv-hash sv-MATCH))) "\\' near pos=" (sv-to sv-MATCH )))(progn (write-line (format nil "~{~a~}" (list "error in Block")) *error-output*) (sb-ext:quit)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Method))) (setf (sv-name m) (sv-scalar (gethash "opt_name" (sv-hash sv-MATCH))))(setf (sv-sig m) (sv-scalar (gethash "method_sig" (sv-hash sv-MATCH))))(setf (sv-block m) (sv-scalar (gethash "exp_stmts" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))))))))))))))(return-from mp6-function sv-MATCH))))

;; method sub
(if (not (ignore-errors (find-method 'sv-sub () ())))
  (defgeneric sv-sub (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-sub ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "s" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "u" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "b" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "opt_name" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-method_sig sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "method_sig" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_stmts sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_stmts" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (format t "~{~a~}~%" (list "*** Syntax Error in sub \\'" (sv-scalar (gethash "name" (sv-hash sv-MATCH))) "\\'"))(progn (write-line (format nil "~{~a~}" (list "error in Block")) *error-output*) (sb-ext:quit)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Sub))) (setf (sv-name m) (sv-scalar (gethash "opt_name" (sv-hash sv-MATCH))))(setf (sv-sig m) (sv-scalar (gethash "method_sig" (sv-hash sv-MATCH))))(setf (sv-block m) (sv-scalar (gethash "exp_stmts" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))))))))))))(return-from mp6-function sv-MATCH))))




;; class MiniPerl6::Grammar
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp))
;; (in-package mp-MiniPerl6-Grammar)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
;; method token
(if (not (ignore-errors (find-method 'sv-token () ())))
  (defgeneric sv-token (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-token ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (if (sv-bool (sv-eq "t" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "o" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "k" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "e" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (if (sv-bool (sv-eq "n" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_name sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "opt_name" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-rule (proto-mp-MiniPerl6-Grammar-Regex) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "MiniPerl6::Grammar::Regex.rule" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (let ((sv-source nil)(sv-ast nil)) (setf sv-source (format nil "~{~a~}" (list "method " (format nil "~{~a~}" (list (gethash "opt_name" (sv-hash sv-MATCH)) (format nil "~{~a~}" (list " ( $grammar: $str, $pos ) { " (format nil "~{~a~}" (list "my $MATCH; $MATCH := ::MiniPerl6::Match( \\'str\\' => $str, \\'from\\' => $pos, \\'to\\' => $pos, \\'bool\\' => 1 ); " (format nil "~{~a~}" (list "$MATCH.bool := ( " (format nil "~{~a~}" (list (sv-emit (sv-scalar (gethash "MiniPerl6::Grammar::Regex.rule" (sv-hash sv-MATCH))) ) (format nil "~{~a~}" (list "); " "make $MATCH }")))))))))))))))(setf sv-ast (sv-term (proto-mp-MiniPerl6-Grammar) sv-source))(return-from mp6-function (sv-scalar sv-ast)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))))))))))(return-from mp6-function sv-MATCH))))




