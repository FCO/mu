#!/usr/bin/env perl
use v5.10;
use lib 'perl6-snapshot';
use lib 'src';
use STD;
package Mildew;
do 'viv';
use AST;
use AST::Helpers;
use DumpMatch;
use utf8;
use YAML::XS;
use Encode;
use strict;
use warnings;
use Getopt::Long;
use Carp 'confess';
use Scalar::Util 'blessed';
use File::Temp qw(tempfile tmpnam);
use File::Slurp qw(slurp);

#  -e program      one line of program (multiple -e are allowed, omit programfile)
#  -c              parse the file or -e, but do not run it
sub help {
print <<'HELP';
Usage: mildew [switches] [--] [programfile] [arguments]
  -Bbackend       execute using the compiler backend
  -Cbackend       compile using the compiler backend
                  (valid backends are: m0ld, desugar, yaml, via-C, js)
  -o              output to file
  -h or --help    give this message
  --valgrind      use valgrind when executing
  --gdb           run the program under gdb
  -x              specify the language of the input file
  --profile       print profiling info
                  (valid values are: call-graph)
  --format        format for the profiling info
                  (valid values: dhtml,text)
  -e
  --server        runs as an App::Persistent server
HELP
exit;
}
my ($debug,$B,$C,$output,$help,$valgrind,$gdb,$empty_setting,$x,$target_stage,$yeast,$profile,$profile_format,$program);
my @SMOP_INCLUDE;
my @MILDEW_LDOPTS;

BEGIN {
    for (<src/VAST/*.pm>) {
	require $_;
    }
}

sub m0ld_to_c {
    my ($m0ld,@options) = @_;
    use IPC::Open2;
    local $ENV{LD_LIBRARY_PATH} = '../smop/build/lib';
    open2(my $m0ld_exe_out,my $m0ld_exe_in,"../smop/m0ld_exe",@options);
    binmode $m0ld_exe_in, ':utf8';
    print $m0ld_exe_in $m0ld;
    close($m0ld_exe_in);
    local $/;
    binmode $m0ld_exe_out, ':utf8';
    return <$m0ld_exe_out>;
}

sub m0ld_to_js {
    my ($m0ld,@options) = @_;
    use IPC::Open2;
    open2(my $m0ld_exe_out,my $m0ld_exe_in,"../smop/m0ld_exe",'--js');
    binmode $m0ld_exe_in, ':utf8';
    print $m0ld_exe_in $m0ld;
    close($m0ld_exe_in);
    local $/;
    binmode $m0ld_exe_out, ':utf8';
    return <$m0ld_exe_out>;
}

sub run_m0ld {
    my ($m0ld,) = @_;
    local $ENV{LD_LIBRARY_PATH} = 'CORE:../smop/build/lib';
    local $ENV{PERL5LIB} = "../smop/SMOP/blib/lib/:../smop/SMOP/blib/arch:" . ($ENV{PERL5LIB} || '');
    my $tmp = tmpnam;
    compile_via_c($m0ld,$tmp);
    if ($valgrind) {
        exec('valgrind','-q','--leak-check=full','--show-reachable=yes',$tmp);
    } elsif ($gdb) {
        exec('gdb',$tmp);
    } else {
        exec($tmp);
    }
}

sub compile_via_c {
    my ($m0ld,$output) = @_;
    my ($c_fh,$c_file) = tempfile();
    binmode($c_fh,":utf8");
    print $c_fh compile_to_c($m0ld);
    system("gcc","-g","-xc","-L../smop/build/lib",@SMOP_INCLUDE,@MILDEW_LDOPTS,$c_file,"-o",$output);
}

sub get_boilerplate {
    open(my $boilerplate,"../smop/m0ld/m0ld_boilerplate") || die "can't open internal file\n";
    local $/;
    return scalar <$boilerplate>;
}
sub get_js_runtime {
    open(my $runtime,"js/CORE.js") || die "can't open internal file\n";
    local $/;
    return scalar <$runtime>;
}
sub add_boilerplate {
    my ($m0ld,$boilerplate) = @_;
    my $body;
    my $funcs = '';

    if ($yeast) {
        $body = "SMOP__Object* yeast = " . m0ld_to_c($m0ld,"--yeast-create") . ";\n" . 
        "SMOP__Object* frame = SMOP__Yeast__Frame_create(interpreter,yeast);";
        $funcs = m0ld_to_c($m0ld,"--yeast-funcs");
    } else {
        $body = "SMOP__Object* mold = " . m0ld_to_c($m0ld) . ";\n" . 
        "SMOP__Object* frame = SMOP__Mold__Frame_create(interpreter,mold);";
    }

    $boilerplate =~ s/%%BODY%%/$body/;
    $boilerplate =~ s/%%FUNCS%%/$funcs/;
    $boilerplate;
}
sub compile_to_c {
    my ($m0ld,) = @_;
    add_boilerplate($m0ld,get_boilerplate);
}


sub compile_to_so {
    my ($m0ld,$output) = @_;
    my ($c_fh,$c_file) = tempfile();
    print $c_fh add_boilerplate($m0ld,<<'BOILERPLATE');
#include <stdio.h>
#include <smop/base.h>
#include <smop/mold.h>
#include <smop/capture.h>
#include <smop/s0native.h>
#include <smop/native.h>
#include <smop/s1p.h>
#include <smop/yeast.h>
%%FUNCS%%
void init(SMOP__Object* interpreter,SMOP__Object* scope,SMOP__Object* continuation) {
  %%BODY%%
  smop_reg_set(interpreter,frame,0,SMOP_REFERENCE(interpreter,interpreter));
  smop_reg_set(interpreter,frame,1,scope);
  smop_reg_set(interpreter,frame,2,continuation);

  SMOP_DISPATCH(interpreter, SMOP_RI(interpreter),
    SMOP__NATIVE__idconst_create("goto"),
    SMOP__NATIVE__capture_create(interpreter,
        (SMOP__Object*[]) {SMOP_REFERENCE(interpreter,interpreter),frame,NULL},
        (SMOP__Object*[]) {NULL})
  );

}
BOILERPLATE
    close($c_fh);
    system("gcc","-fPIC","-g","-xc","-L../../smop/build/lib",@MILDEW_LDOPTS,@SMOP_INCLUDE,"-shared",$c_file,"-o",$output);
}
sub output {
    my ($what,$where) = @_;
    if ($where) {
        open(my $out,">",$where);
        binmode $out, ':utf8';
        print $out $what;
    } else {
        binmode STDOUT, ':utf8';
        print $what;
    }
}
sub parse {
    my $m;
    die "output=$output too many arguments @ARGV" if scalar @ARGV > 1;
    if (@ARGV) {
        $m = STD->parsefile($ARGV[0],actions=>'Actions');
    } else {
        $program = join('', <STDIN>) unless $program;
        $m = STD->parse($program, actions=>'Actions');
    }
    
    #print dump_match('comp_unit'=>$m,{vertical=>1,mark_arrays=>1,visit_twice=>1}),"\n" if $debug;
    print "#################\n" if $debug;
    if ($debug) {
        print Dump($m->{'?'});
        exit;
    }

    my $mold = $m->{'?'}->emit_m0ld($C);
    
    unless ($empty_setting) {
        my $load_CORE = call(load => call(new => FETCH(lookup 'MildewSOLoader')),
        [string 'CORE.mildew.so',FETCH(lookup('$LexicalPrelude'))]);
        unshift @{$mold->stmts},$load_CORE;
    }
    $mold;
}
sub mold_to_m0ld {
    my ($mold,$C) = @_;
    my ($front,$back);
    if ($C eq 'so' or $C eq 'js') {
        $front = "my \$interpreter;\nmy \$scope;\nmy \$back;\n";
        $back = 'my $void = $back."setr"($ret);my $void = $interpreter."goto"($back);';
    } else {
        $front = "my \$scope = ?SMOP__S1P__LexicalPrelude;\n";
        $back = '';
    }
    my $m0ld = $front.<<'BOILERPLATE_FRONT'.$mold->m0ld('$main').<<'BOILERPLATE_BACK'.$back;
    my $void;
BOILERPLATE_FRONT
    my $AdhocSignature_scalar = $scope."lookup"("AdhocSignature");
    my $AdhocSignature = $AdhocSignature_scalar."FETCH"();
    
    my $sig = $AdhocSignature."new"(:"BIND"(mold {
        my $interpreter;
        my $scope;
        my $capture;
        my $continuation = $interpreter."continuation"();
        my $back = $continuation."back"();
        my $void = $interpreter."goto"($back);
    }),:"ACCEPTS"(mold {
        my $interpreter;
        my $scope;
        my $capture;
        my $continuation = $interpreter."continuation"();
        my $back = $continuation."back"();
        my $void = $interpreter."goto"($back);
    }));

    my $Code_scalar = $scope."lookup"("Code");
    my $Code = $Code_scalar."FETCH"();
    my $main_code = $Code."new"(:"outer"($scope),:"mold"($main),:"signature"($sig));
    my $Capture_scalar = $scope."lookup"("capture");
    my $Capture = $Capture_scalar."FETCH"();
    my $capture = $Capture."new"();
    my $ret = $main_code."postcircumfix:( )"($capture);
BOILERPLATE_BACK
}
sub m0ld {
    $x ||= 'p6';
    if ($x eq 'm0ld') {
        local $/;
        my $m0ld = <>;
        return $m0ld;
    } elsif ($x eq 'p6') {
        mold_to_m0ld(parse,$C);
    } elsif ($x) {
        die "Unsupported language $x.\n"
    }


}

sub main {
    Getopt::Long::Parser->new( config => [qw( bundling no_ignore_case pass_through require_order)], )->getoptions(
        "C=s" => \$C,
        "output|o=s" => \$output,
        "B=s" => \$B,
        'valgrind' => \$valgrind,
        'gdb' => \$gdb,
        'empty-setting' => \$empty_setting,
        'debug' => \$debug,
        'h|help' => \$help,
        'x=s' => \$x,
        'target-stage=i'=>\$target_stage,
        'yeast' => \$yeast,
        'profile=s' => \$profile,
        'format=s' => \$profile_format,
        'return-real-value' => \$Mildew::return_real_value,
        'e=s' => \$program
    ) || help;
    help if $help;
    
    if (($B // $C // '') eq 'js') {
        $empty_setting = 1;
        #$target_stage = 1 unless $target_stage;
    }
    @SMOP_INCLUDE = map {"-I".$_} glob("../smop/*/include");
    @MILDEW_LDOPTS = ( '-L../smop/build/lib',
                          map { s/^.+?\/lib\/lib|.so$//g; "-l".$_ } glob("../smop/build/lib/*.so") );
    
    
    $target_stage //= 2;
    if ($target_stage == 1) {
        $Mildew::adhoc_sig = 1;
    } elsif ($target_stage == 2) {
        $Mildew::adhoc_sig = 0;
    } else {
        die 'unrecognised value passed to --target-stage';
    }
    
    VIV::SET_OPT('match'=>!$debug,'pos'=>1);
    $C = '' unless $C;
    if ($C eq 'desugar') {
        output(parse->pretty."\n",$output);
        exit;
    } elsif ($C eq 'ast-yaml') {
        use YAML::XS;
        output(Dump(parse),$output);
        exit;
    } else {
    }
    if ($output and not $C) {
        $C = 'via-C';
    }
    if ($C eq 'via-C') {
        die "-o is required when compiling to an executable\n" unless $output;
        local $ENV{LD_LIBRARY_PATH} = 'CORE:../smop/build/lib';
        compile_via_c(m0ld,$output);
    } elsif ($C eq 'so') {
        die "-o is required when compiling to a shared library \n" unless $output;
        compile_to_so(m0ld,$output);
    } elsif ($C eq 'm0ld') {
        output(m0ld,$output);
    } elsif ($C eq 'C') {
        output(compile_to_c(m0ld),$output);
    } elsif ($C eq 'js') {
        output(m0ld_to_js(m0ld),$output);
    } elsif ($C) {
        die "unknown backend passed to -C: $C\n";
    }
  
    if ($B && $C) {
        die "can't specify both -C and -B\n";
    } elsif (!$B && !$C) {
        $B = 'via-C';
    } elsif ($C) {
        exit;
    }
    if ($B eq 'via-C') {
        local $ENV{LD_LIBRARY_PATH} = 'CORE:../smop/build/lib';
        local $ENV{PERL5LIB} = "../smop/SMOP/blib/lib/:../smop/SMOP/blib/arch:" . ($ENV{PERL5LIB} || '');
        run_m0ld(m0ld);
    } elsif ($B eq 'js') {
        require V8;
        my $ctx = V8::Context->new();
        sub print {
            # TODO: put this in C++ instead as a V8 plugin (or use Print() from d8.cc)
            print map { Encode::decode_utf8($_) } @_;
        }
        sub p6_to_js {
            local $Mildew::return_real_value = 1;
            m0ld_to_js(mold_to_m0ld(STD->parse($_[0], actions=>'Actions')->{'?'}->emit_m0ld(),'js'));
        }
        $ctx->register_method_by_name("print");
        $ctx->register_method_by_name("slurp");
        $ctx->register_method_by_name("p6_to_js");
        $ctx->execute(get_js_runtime."\n1;");
        $ctx->execute(slurp("js/molds.js").";onmoldload()\n1;");
    
        for my $file (qw(js/CORE2.js js/RoleHOW.js js/Exception.js js/Failure.js js/Signature.js js/Multi.js js/Types.js js/int.js js/ModuleLoader.js)) {
            $ctx->execute("
                var interpreter = new P6Interpreter();
                var frame = new P6Frame(".slurp($file).");
                interpreter.DISPATCH(interpreter,new P6Str('goto'),new P6capture([interpreter,frame],[]));
                interpreter.DISPATCH(interpreter,new P6Str('loop'),new P6capture([interpreter],[]));
                1;
            ");
        }
        $ctx->execute("
            var interpreter = new P6Interpreter();
            var frame = new P6Frame(".m0ld_to_js(m0ld).");
    interpreter.DISPATCH(interpreter,new P6Str('goto'),new P6capture([interpreter,frame],[]));
    interpreter.DISPATCH(interpreter,new P6Str('loop'),new P6capture([interpreter],[]));
    1;");
        warn if $@;
    } elsif ($B) {
        die "unknown backend passed to -B: $C\n";
    }
}
#main();
if (@ARGV == 1 && $ARGV[0] eq '--server') {
    require App::Persistent::Server;
    my $server = App::Persistent::Server->new(
        code => sub {
            my $info = shift;
    
            # fake environment
            local %ENV = $info->environment;
            local $0 = $info->program_name;
            chdir $info->working_directory;
            local @ARGV = $info->cmdline_args;
    
            main;
         },
    );
    $server->start;
    exit $server->completion_condvar->recv;
} else {
    main;
}
