#!/usr/bin/env perl
use strict;
no strict "subs"; # XXX remove once Type-names are quoted. # say Int.isa(Any)
use warnings;

{package AssertCurrentModuleVersions;
 use autobox 2.51;
}
{ package NoSideEffects;
  use Class::Multimethods;
  use Data::Dumper;
}

{package Object;
    our %DEFAULTS;
    sub new {
        my $self = shift;
        my $class = ref $self || $self;
        my $obj = bless {@_}, $class;
        for (keys %{$DEFAULTS{$class}}) {
            $obj->{$_} = $DEFAULTS{$class}{$_}->() unless $obj->{$_};
        }
        $obj;
    }
    sub become {
      my($self,$cls)=@_;
      bless $self,$cls;
    }
}
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      

# Workaround autobox 2.53 api change. :(
if(!defined(&autobox::universal::type)) {
  eval q{package autobox::universal; sub type { autobox->type($_[0]) }};
}
{package UNIVERSAL; sub ref {CORE::ref($_[0]) || autobox::universal::type($_[0]) } } # For IRx1_FromAST.pm.
{package UNIVERSAL; sub WHAT {CORE::ref($_[0]) || autobox::universal::type($_[0]) } }

{ package Any;
  sub can { UNIVERSAL::can($_[0],$_[1]) }
  sub isa { UNIVERSAL::isa($_[0],$_[1]) }
  sub does { UNIVERSAL::isa($_[0],$_[1]) }
}  

# Avoid "use base" error: Base class package "Xxx" is empty. :/
{ package Num; our $_tell_use_base_i_am_not_empty_; }
{ package Int; our $_tell_use_base_i_am_not_empty_; }
{ package Str; our $_tell_use_base_i_am_not_empty_; }
{ package Array; our $_tell_use_base_i_am_not_empty_; }
{ package Hash; our $_tell_use_base_i_am_not_empty_; }
{ package Undef; our $_tell_use_base_i_am_not_empty_; }
{ package Code; our $_tell_use_base_i_am_not_empty_; }

{package UNDEF;
 use base "Undef";
 sub WHAT {"Undef"}
 sub perl { "undef" }
}
no warnings qw(redefine prototype);
{ package STRING;
  use base "Str";
  sub WHAT { "Str" }

  sub re_matchp { ($_[0] =~ m{$_[1]}) ? 1 : 0 }
  sub re_groups {
    my @g = $_[0] =~ m{$_[1]};
    @g ? \@g : undef;
  }

  sub re_gsub_pat { # slower, but needed for $1.
    my($s,$pat,$replace_pat)=@_;
    eval "\$s =~ s/$pat/$replace_pat/g";
    Carp::confess($@) if $@;
    $s;
  }
  sub re_gsub {
    my($s,$pat,$replace_str)=@_;
    $s =~ s/$pat/$replace_str/g;
    $s;
  }

  # unused
  sub re_sub         {
    my $expr = "\$_[0] =~ s/$_[1]/$_[2]/".($_[3]||"");
    eval $expr;
    Carp::confess($@) if $@;
    $_[0]
  }

  sub hex   { CORE::hex($_[0]); }

  # randomness taken from autobox::Core

  sub chomp    { CORE::chomp($_[0]); }
  sub chop     { CORE::chop($_[0]); }
  sub chr      { CORE::chr($_[0]); }
  sub crypt    { CORE::crypt($_[0], $_[1]); }
  sub index    { CORE::index($_[0], $_[1], @_[2.. $#_]); }
  sub lc       { CORE::lc($_[0]); }
  sub lcfirst  { CORE::lcfirst($_[0]); }

  sub bytes    { use bytes; CORE::length($_[0]); }
  sub chars    { CORE::length($_[0]); }
  sub codes    { my @c = unpack("U*",$_[0]); 0+@c }
  sub graphs   { require String::Multibyte; String::Multibyte->new("Grapheme")->length($_[0]) }

  sub ord      { CORE::ord($_[0]); }
  sub pack     { CORE::pack(@_); }
  sub reverse  { CORE::reverse($_[0]); }
  sub rindex   { CORE::rindex($_[0], $_[1], @_[2.. $#_]); }
  sub sprintf  { CORE::sprintf($_[0], $_[1], @_[2.. $#_]); }
  sub substr   { CORE::substr($_[0], $_[1], @_[2 .. $#_]); }
  sub uc       { CORE::uc($_[0]); }
  sub ucfirst  { CORE::ucfirst($_[0]); }
  sub unpack   { CORE::unpack($_[0], @_[1..$#_]); }
  sub undef    { $_[0] = undef }
  sub m        { [ $_[0] =~ m{$_[1]} ] }
  sub nm        { [ $_[0] !~ m{$_[1]} ] }
  sub s        { $_[0] =~ s{$_[1]}{$_[2]} }
  sub split    { [ split $_[1], $_[0] ] }

  sub primitive_Num { no warnings "numeric"; 0+$_[0] }
}

{ package FLOAT_and_INTEGER;
  use base "Num";
  sub abs   { CORE::abs($_[0]) }
  sub atan2 { CORE::atan2($_[0], $_[1]) }
  sub cos   { CORE::cos($_[0]) }
  sub exp   { CORE::exp($_[0]) }
  sub int   { CORE::int($_[0]) }
  sub log   { CORE::log($_[0]) }
  sub oct   { CORE::oct($_[0]) }
  sub hex   { CORE::hex($_[0]); }
  sub rand  { CORE::rand($_[0]) }
  sub sin   { CORE::sin($_[0]) }
  sub sqrt  { CORE::sqrt($_[0]) }

}
{ package FLOAT;
  use base "FLOAT_and_INTEGER";
  sub WHAT { "Num" }
}
{ package INTEGER;
  use base "FLOAT_and_INTEGER";
  use base "Int";

  sub WHAT { "Int" }
  sub to ($$) { $_[0] < $_[1] ? [$_[0]..$_[1]] : [CORE::reverse $_[1]..$_[0]]}
  sub upto ($$) { [ $_[0]..$_[1] ] }
  sub downto ($$) { [ CORE::reverse $_[1]..$_[0] ] }

  sub chr      { CORE::chr($_[0]); }
}
{ package ARRAY;
  use base "Array";
  sub WHAT {"Array"}

  sub shape { my $a = CORE::shift; 0+@$a } # ?
  sub end { my $a = CORE::shift; -1+@$a } # ?
  sub elems { my $a = CORE::shift; CORE::scalar @$a }
  sub delete { my $a = CORE::shift; @_ ? CORE::delete($a->[$_[0]]) : undef }
  sub exists { my $a = CORE::shift; @_ ? CORE::exists($a->[$_[0]]) : undef }
  sub pop   { CORE::pop @{$_[0]}; }
  sub shift { my $a = CORE::shift; CORE::shift(@$a) }
  sub push { my $a = CORE::shift; CORE::push(@$a,@_); $a }
  sub unshift { my $a = CORE::shift; CORE::unshift(@$a,@_) }
  sub splice {
    my $a = CORE::shift;
    my $offset = CORE::shift || 0;
    my $size = CORE::shift || 0;
    [CORE::splice(@{$a},$offset,$size,@_)]
  }
  sub keys { my $a = CORE::shift; [0..(@$a-1)] }
  sub kv { my $a = CORE::shift; my $idx = 0; [map{($idx++,$_)}@$a] }
  sub pairs { my $a = CORE::shift; my $idx = 0; [map{Pair->new("key"=>$idx++,"value"=>$_)}@$a] }
  sub values { my $a = CORE::shift; @$a }

  # Speculative

  sub clone { my $a = CORE::shift; [@$a] }

  # Non-spec

  sub grep  { my $arr = CORE::shift; my $sub = CORE::shift; [ CORE::grep { $sub->($_) } @$arr ]; }
  sub join  { my $arr = CORE::shift; my $sep = CORE::shift; CORE::join $sep, @$arr; }
  sub map  { my $arr = CORE::shift; my $sub = CORE::shift; [ CORE::map { $sub->($_) } @$arr ]; }
  sub reverse  { [ CORE::reverse @{$_[0]} ] }
  sub sort  { my $arr = CORE::shift; my $sub = CORE::shift() || sub { $a cmp $b }; [ CORE::sort { $sub->($a, $b) } @$arr ]; }
  sub max { my $arr = CORE::shift; my $max = $arr->[0]; foreach (@$arr) {$max = $_ if $_ > $max }; $max; }
  sub min { my $arr = CORE::shift; my $min = $arr->[0]; foreach (@$arr) {$min = $_ if $_ < $min }; $min; }

  sub concat { [map{@$_} @_] }

  # Internal

  sub flatten  { ( @{$_[0]} ) }
  sub flatten_recursively {
    map { my $ref = ref($_); ($ref && $ref eq "ARRAY") ? $_->flatten_recursively : $_ } @{$_[0]}
  }

}
{ package HASH;
  use base "Hash";
  sub WHAT {"Hash"}

  # randomness taken from autobox::Core

  sub delete  { my $hash = CORE::shift; my @res = (); CORE::foreach(@_) { push @res, CORE::delete $hash->{$_}; } CORE::wantarray ? @res : \@res }
  sub exists  { my $hash = CORE::shift; CORE::exists $hash->{$_[0]}; }
  sub keys  { [ CORE::keys %{$_[0]} ] }
  sub values  { [ CORE::values %{$_[0]} ] }

  sub each  {
    my $hash = CORE::shift;
    my $cb = CORE::shift;
    while((my $k, my $v) = CORE::each(%$hash)) {
      $cb->($k, $v);
    }
  }

  # spec

  sub kv { my $h = CORE::shift; [map{($_,$h->{$_})} CORE::keys %$h] }
  sub pairs { my $h = CORE::shift; [map{Pair->new("key"=>$_,"value"=>$h->{$_})} CORE::keys %$h] }

  # Speculative

  sub clone {
    my $h = CORE::shift;
    # Do not simplify this to "...ift; {%$h} }".  returns 0.  autobox issue?
    my $h1 = {%$h}; $h1
  }

  # Temporary

  sub dup { my $h = CORE::shift; my $h1 = {%$h}; $h1} # obsolete
}
{ package CODE;
  use base "Code";
  sub WHAT {"Code"}
}

{ package Any; sub Hash { $_[0] } } #X
{ package Hash; sub Hash { $_[0] } }
{ package Array; sub Array { $_[0] } }

{ package Any; #X
  sub postcircumfix__123_32_125 { @_ <= 2 ? $_[0]->{$_[1]} : do{$_[0]->{$_[1]} = $_[2]} }
  sub postcircumfix__60_32_62 { @_ <= 2 ? $_[0]->{$_[1]} : do{$_[0]->{$_[1]} = $_[2]} }
}
{ package HASH;
  sub postcircumfix__123_32_125 { @_ <= 2 ? $_[0]->{$_[1]} : do{$_[0]->{$_[1]} = $_[2]} }
  sub postcircumfix__60_32_62 { @_ <= 2 ? $_[0]->{$_[1]} : do{$_[0]->{$_[1]} = $_[2]} }
}
{ package ARRAY;
  sub postcircumfix__91_32_93 { @_ <= 2 ? $_[0]->[$_[1]] : do{$_[0]->[$_[1]] = $_[2]} }
}

{ package Match;
  sub postcircumfix__123_32_125 { @_ <= 2 ? $_[0]->{"match_hash"}->{$_[1]} : do{$_[0]->{"match_hash"}->{$_[1]} = $_[2]} }
  sub postcircumfix__60_32_62 { @_ <= 2 ? $_[0]->{"match_hash"}->{$_[1]} : do{$_[0]->{"match_hash"}->{$_[1]} = $_[2]} }
  sub postcircumfix__91_32_93 { @_ <= 2 ? $_[0]->{"match_array"}->[$_[1]] : do{$_[0]->{"match_array"}->[$_[1]] = $_[2]} }

  sub Str { $_[0]->{"match_string"} }
  sub Bool { $_[0]->{"match_boolean"} }
  sub Hash { $_[0]->{"match_hash"} }
  sub Array { $_[0]->{"match_array"} }
}

{ package Any; sub Bool { 1 } }
{ package UNDEF; sub Bool { undef } }
{ package ARRAY; sub Bool { @{$_[0]} ? 1 : undef } }
{ package HASH; sub Bool { %{$_[0]} ? 1 : undef } }
{ package FLOAT_and_INTEGER; sub Bool { $_[0] ? 1 : undef } }
{ package STRING; sub Bool { $_[0] ? 1 : undef } }

use warnings;

{ package Any; sub __make_not_empty_for_use_base{}}
{ package STRING; use base "Any";}
{ package INTEGER; use base "Any";}
{ package FLOAT; use base "Any";}
{ package ARRAY; use base "Any";}
{ package HASH; use base "Any";}
{ package CODE; use base "Any";}

{ package Private;
  # Taken from Perl6::Take 0.04.
  our @GATHER;
  sub gather (&) {local @GATHER = (@GATHER, []); shift->(); $GATHER[-1] }
  sub take (@) {push @{ $GATHER[-1] }, @_; undef }
}

{ package GLOBAL;
  { no warnings;
    *gather = \&Private::gather;
    *take   = \&Private::take;}

  our $a_ARGS = [map {encoding::decode("utf8",$_)} @ARGV];

  sub undef{undef}

  use Carp;
  sub slurp {
    my($file)=@_;
    local $/;
    open(my $fh,"<:utf8",$file);
    my $s = <$fh>;
    $s
  }
  sub unslurp {
    my($text,$file)=@_;
    open(my $fh,">:utf8",$file) or CORE::die $!;
    CORE::print $fh $text;
    close $fh;
  }
  sub file_exists{-e $_[0]}
  sub system{CORE::system(@_)}
  sub eval_runtime_code{
    my($p5,$env)=@_;
    if($env) { $env->($p5) }
    else {
      my $code = "package Main; ".$p5;
      my $res = eval($code); croak($@) if $@;
      $res
    }
  }
  sub eval_perl5{
    my($p5,$env)=@_;
    eval_runtime_code($p5,$env);
  }
  sub die{croak @_}
  sub exit{CORE::exit(@_)}
  sub defined{CORE::defined($_[0])}
  sub substr {CORE::substr($_[0],$_[1],$_[2])}
  sub not{$_[0] ? !($_[0]->Bool) : 1}
  sub exec{CORE::exec(@_)}
  sub sleep{CORE::sleep(@_)}

  sub split{[CORE::split($_[0],$_[1])]}
  sub push { my $a = CORE::shift; CORE::push(@$a,@_); $a }

  sub unlink{CORE::unlink(@_)}
  sub sprintf{CORE::sprintf(shift,@_)}
  sub print { CORE::print @_ }
  sub quotemeta { CORE::quotemeta($_[0]) }

  sub chmod_exe { CORE::chmod(0755,$_[0]) } # Hack for Compiler.

  sub private_tidy {
    eval("use Perl::Tidy");
    if ($@) { $_[0] }
    elsif ($ENV{ELF_DEV_NO_TIDY}) { $_[0] }
    else {
      my $source = $_[0];
      my $dest;
      Perl::Tidy::perltidy(argv=>[],source=>\$source,destination=>\$dest);
      $dest;
    }
  }

}

{ package GLOBAL;

  sub parser_format {"p5a"}
  sub parser_name{
    my $e = $ENV{ELF_STD_RED_RUN};
    return $e if $e;
    my $f = $0;
    $f =~ s/[^\/]+$//;
    # $f."elf_h_src/STD_red/STD_red_run"
    $f."../STD_red/STD_red_run"
  }

  our $a_INC = ["."];
  our $h_ENV = \%ENV;

  sub module_require {
    my($module)=@_;
    my $file = find_required_module($module);
    $file || CORE::die "Cant locate $module in ( ".CORE::join(" ",@$GLOBAL::a_INC)." ).\n";
    eval_file($file);
  };
  sub find_required_module {
    my($module)=@_;
    my @names = ($module,$module.".pm",$module.".p6");
    for my $dir (@$GLOBAL::a_INC) {
      for my $name (@names) {
        my $file = $dir."/".$name;
        if(-f $file) {
          return $file;
        }
      }
    }
    return undef;
  }
  sub import {
    my($module,@args)=@_;
    my $args = \@args;
    my $import = "if(defined(&".$module."::import)) { ".$module."->import(\$args); }";
    my $result = eval $import;
    Carp::confess($@) if $@;
    $result;
  }
  sub mkdir {
    my($dir) = @_;
    mkdir($dir);
  }

  our $compiler0;
  our $compiler1;
  our $parser0;
  our $parser1;
  our $ast2ir_0;
  our $ast2ir_1;
  our $emitter0;
  our $emitter1;

  sub eval_file {
    my($file)=@_;
    $GLOBAL::compiler0->eval_file($file);
  }
  sub eval_perl6 {
    my($code,$env)=@_;
    $GLOBAL::compiler0->eval_perl6($code,$env);
  }
  sub eval {
    my($code,$env)=@_;
    eval_perl6($code,$env);
  }
}

{ package Fastundump;
  sub match {my($r,$s,$f,$t,$h)=@_; Match->make_from_rsfth($r,$s,$f,$t,$h)}
}
{ package GLOBAL;
  sub fastundump {my($dump)=@_; eval("package Fastundump; ".$dump);}
  sub mangle_name {my($name)=@_;
    $name =~ s/([^\w])/"_".CORE::ord($1)/eg;
    $name;
  }
  sub symbol_lookup : lvalue {
    my($name)=@_;
    my @parts = split(/::/,$name);
    $parts[0] =~ /\A([\$\@\%])(.*)/ || CORE::die("symbol_lookup: no sigil?: $name");
    $parts[0] = $2;
    my $sigil = $1;
    $parts[-1] = {"\$"=>"","\@"=>"a_","\%"=>"h_"}->{$sigil}.$parts[-1];
    my $var = join("::",@parts);
    no strict "refs";
    $$var;
  }
}

package Main;

use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;
;
;
;
;
;
;
;
;
;
;

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package Bit;
use base "Any";BEGIN{unshift(@Bit::ISA,'Any');}
(do{})
}
;

{ package Int;
use base "Any";BEGIN{unshift(@Int::ISA,'Any');}
(do{})
}
;

{ package Str;
use base "Any";BEGIN{unshift(@Str::ISA,'Any');}
(do{})
}
;

{ package Num;
use base "Any";BEGIN{unshift(@Num::ISA,'Any');}
(do{})
}
;

{ package Complex;
use base "Any";BEGIN{unshift(@Complex::ISA,'Any');}
(do{})
}
;

{ package Bool;
use base "Any";BEGIN{unshift(@Bool::ISA,'Any');}
(do{})
}
;

{ package Code;
use base "Any";BEGIN{unshift(@Code::ISA,'Any');}
(do{})
}
;

{ package Block;
use base "Any";BEGIN{unshift(@Block::ISA,'Code');}
(do{})
}
;

{ package List;
use base "Any";BEGIN{unshift(@List::ISA,'Any');}
(do{})
}
;

{ package Seq;
use base "Any";BEGIN{unshift(@Seq::ISA,'Any');}
(do{})
}
;

{ package Range;
use base "Any";BEGIN{unshift(@Range::ISA,'Any');}
(do{})
}
;

{ package Set;
use base "Any";BEGIN{unshift(@Set::ISA,'Any');}
(do{})
}
;

{ package Bag;
use base "Any";BEGIN{unshift(@Bag::ISA,'Any');}
(do{})
}
;

{ package Junction;
BEGIN{unshift(@Junction::ISA,'Object');}
(do{})
}
;

{ package Pair;
use base "Any";BEGIN{unshift(@Pair::ISA,'Any');}
(do{})
}
;

{ package Mapping;
use base "Any";BEGIN{unshift(@Mapping::ISA,'Any');}
(do{})
}
;

{ package Signature;
use base "Any";BEGIN{unshift(@Signature::ISA,'Any');}
(do{})
}
;

{ package Capture;
use base "Any";BEGIN{unshift(@Capture::ISA,'Any');}
(do{})
}
;

{ package Blob;
use base "Any";BEGIN{unshift(@Blob::ISA,'Any');}
(do{})
}
;

{ package Scalar;
use base "Any";BEGIN{unshift(@Scalar::ISA,'Any');}
(do{})
}
;

{ package Array;
use base "Any";BEGIN{unshift(@Array::ISA,'List');}
(do{})
}
;

{ package Hash;
use base "Any";BEGIN{unshift(@Hash::ISA,'Any');}
(do{})
}
;

{ package KeyHash;
use base "Any";BEGIN{unshift(@KeyHash::ISA,'Any');}
(do{})
}
;

{ package KeySet;
use base "Any";BEGIN{unshift(@KeySet::ISA,'Any');}
(do{})
}
;

{ package KeyBag;
use base "Any";BEGIN{unshift(@KeyBag::ISA,'Any');}
(do{})
}
;

{ package Buf;
use base "Any";BEGIN{unshift(@Buf::ISA,'Any');}
(do{})
}
;

{ package IO;
use base "Any";BEGIN{unshift(@IO::ISA,'Any');}
(do{})
}
;

{ package Routine;
use base "Any";BEGIN{unshift(@Routine::ISA,'Code');}
(do{})
}
;

{ package Sub;
use base "Any";BEGIN{unshift(@Sub::ISA,'Routine');}
(do{})
}
;

{ package Method;
use base "Any";BEGIN{unshift(@Method::ISA,'Routine');}
(do{})
}
;

{ package Subethod;
use base "Any";BEGIN{unshift(@Subethod::ISA,'Routine');}
(do{})
}
;

{ package Macro;
use base "Any";BEGIN{unshift(@Macro::ISA,'Routine');}
(do{})
}
;

{ package Regex;
use base "Any";BEGIN{unshift(@Regex::ISA,'Routine');}
(do{})
}
;

{ package Match;
use base "Any";BEGIN{unshift(@Match::ISA,'Any');}
(do{})
}
;

{ package Package;
use base "Any";BEGIN{unshift(@Package::ISA,'Any');}
(do{})
}
;

{ package Module;
use base "Any";BEGIN{unshift(@Module::ISA,'Package');}
(do{})
}
;

{ package Class;
use base "Any";BEGIN{unshift(@Class::ISA,'Module');}
(do{})
}
;

{ package Role;
use base "Any";BEGIN{unshift(@Role::ISA,'Module');}
(do{})
}
;

{ package Grammar;
use base "Any";BEGIN{unshift(@Grammar::ISA,'Module');}
(do{})
}
;

{ package Any;
BEGIN{unshift(@Any::ISA,'Object');}
(do{})
}
;

{ package Object;
(do{})
}
;

{ package Pair;
use base "Any";(do{sub key { if(@_==2){$_[0]{'key'}=$_[1]}else{$_[0]{'key'}}};
sub value { if(@_==2){$_[0]{'value'}=$_[1]}else{$_[0]{'value'}}}})
}
;

{ package Any;
(do{sub say{my $self=CORE::shift;(do{GLOBAL::say($self)})}})
}
;

{ package GLOBAL;
use base "Any";(do{sub say{my(@a)=@_;
my $a_a = \@a;
(do{for(($a_a)->flatten){
(do{GLOBAL::print($_->Str())})
};
GLOBAL::print("\
")})};
sub infix_xx{my($a_a,$count)=@_;
(do{my $a_result = [];;
for((GLOBAL::infix__46_46(1,$count))){
(do{$a_result->push($a_a)})
};
$a_result})}})
}
;

{ package Int;
use base "Any";(do{sub Num{my $self=CORE::shift;(do{$self})}})
}
;

{ package Num;
use base "Any";(do{sub Num{my $self=CORE::shift;(do{$self})}})
}
;

{ package Str;
use base "Any";(do{sub Num{my $self=CORE::shift;(do{$self->primitive_Num()})}})
}
;

{ package Array;
use base "Any";(do{sub Num{my $self=CORE::shift;(do{$self->elems()})}})
}
;

{ package Hash;
use base "Any";(do{sub Num{my $self=CORE::shift;(do{$self->keys()->elems()})}})
}
;

{ package Pair;
use base "Any";(do{sub Num{my $self=CORE::shift;(do{2})}})
}
;

{ package Int;
use base "Any";(do{sub Str{my $self=CORE::shift;(do{("" . $self)})}})
}
;

{ package Num;
use base "Any";(do{sub Str{my $self=CORE::shift;(do{("" . $self)})}})
}
;

{ package Str;
use base "Any";(do{sub Str{my $self=CORE::shift;(do{$self})}})
}
;

{ package Array;
use base "Any";(do{sub Str{my $self=CORE::shift;(do{$self->join("")})}})
}
;

{ package Hash;
use base "Any";(do{sub Str{my $self=CORE::shift;(do{$self->keys()->map(sub {my($k)=@_;
(do{(($k . "\	") . $self->postcircumfix__123_32_125($k))})})->join("\
")})}})
}
;

{ package Pair;
use base "Any";(do{sub Str{my $self=CORE::shift;(do{(($self->key . "\	") . $self->value)})}})
}
;

{ package Any;
(do{sub print{my $self=CORE::shift;(do{GLOBAL::say($self)})}})
}
;

{ package Any;
(do{sub true{my $self=CORE::shift;(do{GLOBAL::defined($self)})};
sub defined{my $self=CORE::shift;(do{GLOBAL::defined($self)})}})
}
;

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package Match;
use base "Any";(do{sub match_rule { if(@_==2){$_[0]{'match_rule'}=$_[1]}else{$_[0]{'match_rule'}}};
sub match_string { if(@_==2){$_[0]{'match_string'}=$_[1]}else{$_[0]{'match_string'}}};
sub match_from { if(@_==2){$_[0]{'match_from'}=$_[1]}else{$_[0]{'match_from'}}};
sub match_to { if(@_==2){$_[0]{'match_to'}=$_[1]}else{$_[0]{'match_to'}}};
sub match_hash { if(@_==2){$_[0]{'match_hash'}=$_[1]}else{$_[0]{'match_hash'}}};
sub match_array { if(@_==2){$_[0]{'match_array'}=$_[1]}else{$_[0]{'match_array'}}};
sub match_boolean { if(@_==2){$_[0]{'match_boolean'}=$_[1]}else{$_[0]{'match_boolean'}}};
sub make_from_rsfth{my $self=CORE::shift;my($r,$s,$f,$t,$h)=@_;
(do{$self->new("match_rule", $r, "match_string", $s, "match_from", $f, "match_to", $t, "match_hash", $h, "match_array", [], "match_boolean", 1)})};
sub match_new{my $self=CORE::shift;my($b,$s,$a,$h,$f,$t)=@_;
(do{$self->new("match_bool", $b, "match_string", $s, "match_array", $a, "match_hash", $h, "match_from", $f, "match_to", $t)})};
sub match_describe{my $self=CORE::shift;(do{my $b;
if(($self->match_boolean)->Bool) {
(do{($b = "t")})
}else {
(do{($b = "F")})
};
my $f = $self->match_from;
my $t = $self->match_to;
if((GLOBAL::prefix__33(GLOBAL::defined($f)))->Bool) {
(do{($f = "")})
};
if((GLOBAL::prefix__33(GLOBAL::defined($t)))->Bool) {
(do{($t = "")})
};
my $a;
if(($self->match_array->elems())->Bool) {
(do{($a = $self->match_array->match_describe())})
}else {
(do{($a = "\[\]")})
};
my $r = (do{my $__tmp__=($self->match_rule);if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=("");no warnings "void";$__tmp__}});
my $s = ((((((((((($r . "\<") . $b) . "\,") . $f) . "\,") . $t) . "\,\'") . $self->match_string) . "\'\,") . $a) . "\,\{");
for(($self->match_hash->keys())->flatten){
(do{my $k = $_;
my $v = $self->match_hash->postcircumfix__123_32_125($k);
my $vs = "undef";
if((GLOBAL::defined($v))->Bool) {
(do{($vs = $v->match_describe())})
};
($s = ((((($s . "\
\ \ ") . $k) . "\ \=\>\ ") . $self->indent_except_top($vs)) . "\,"))})
};
if(($self->match_hash->keys()->elems())->Bool) {
(do{($s = ($s . "\
"))})
};
($s = ($s . "\}\>"))})};
sub indent{my $self=CORE::shift;my($s)=@_;
(do{$s->re_gsub("\(\?m\:\^\(\?\!\\Z\)\)", "\ \ ")})};
sub indent_except_top{my $self=CORE::shift;my($s)=@_;
(do{$s->re_gsub("\(\?m\:\^\(\?\<\!\\A\)\(\?\!\\Z\)\)", "\ \ ")})};
sub from{my $self=CORE::shift;(do{$self->match_from})};
sub to{my $self=CORE::shift;(do{$self->match_to})}})
}
;

{ package Array;
use base "Any";(do{sub match_describe{my $self=CORE::shift;(do{((("\[\
" . Match->indent($self->map(sub {my($e)=@_;
(do{$e->match_describe()})})->join("\,\
"))) . "\
\]"))})}})
}
;

{ package Hash;
use base "Any";(do{sub match_describe{my $self=CORE::shift;(do{my $s = "\{";
for(($self->keys())->flatten){
(do{my $k = $_;
my $v = $self->postcircumfix__123_32_125($k);
my $vs = "undef";
if((GLOBAL::defined($v))->Bool) {
(do{($vs = $v->match_describe())})
};
($s = ((((($s . "\
\ \ ") . $k) . "\ \=\>\ ") . Match->indent_except_top($vs)) . "\,"))})
};
if(($self->keys()->elems())->Bool) {
(do{($s = ($s . "\
"))})
};
($s . "\}")})}})
}
;

{ package Str;
use base "Any";(do{sub match_describe{my $self=CORE::shift;(do{(("\'" . $self) . "\'")})}})
}
;

{ package Int;
use base "Any";(do{sub match_describe{my $self=CORE::shift;(do{(("\'" . $self) . "\'")})}})
}
;

{ package Num;
use base "Any";(do{sub match_describe{my $self=CORE::shift;(do{(("\'" . $self) . "\'")})}})
}
;

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package Array;
use base "Any";(do{sub irx1_describe{my $self=CORE::shift;(do{(("\[" . $self->map(sub {my($e)=@_;
(do{$e->irx1_describe()})})->join("\,")) . "\]")})}})
}
;

{ package Hash;
use base "Any";(do{sub irx1_describe{my $self=CORE::shift;(do{(("\{" . $self->kv(sub {my($e)=@_;
(do{$e->irx1_describe()})})->join("\,")) . "\}")})}})
}
;

{ package Str;
use base "Any";(do{sub irx1_describe{my $self=CORE::shift;(do{($self . "")})}})
}
;

{ package Int;
use base "Any";(do{sub irx1_describe{my $self=CORE::shift;(do{($self . "")})}})
}
;

{ package Num;
use base "Any";(do{sub irx1_describe{my $self=CORE::shift;(do{($self . "")})}})
}
;

{ package Undef;
use base "Any";(do{sub irx1_describe{my $self=CORE::shift;(do{"undef"})}})
}
;

{ package IRx1;
use base "Any";(do{
{ package IRx1::Capture;
use base "Any";(do{sub newp1{my $self=CORE::shift;my($m,$a)=@_;
(do{$self->newp($m, $a, GLOBAL::undef())})}})
}
;

{ package IRx1::Base;
use base "Any";(do{})
}
;

{ package IRx1::CompUnit;
use base "Any";BEGIN{unshift(@IRx1::CompUnit::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub statements { if(@_==2){$_[0]{'statements'}=$_[1]}else{$_[0]{'statements'}}};
sub filename { if(@_==2){$_[0]{'filename'}=$_[1]}else{$_[0]{'filename'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$statements,$filename)=@_;
(do{$self->new("match", $match, "statements", $statements, "filename", $filename)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__CompUnit($self)})};
sub node_name{my $self=CORE::shift;(do{"CompUnit"})};
sub field_names{my $self=CORE::shift;(do{["statements", "filename"]})};
sub field_values{my $self=CORE::shift;(do{[$self->statements, $self->filename]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("CompUnit\(" . $self->statements->irx1_describe()) . "\,") . $self->filename->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Block;
use base "Any";BEGIN{unshift(@IRx1::Block::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub statements { if(@_==2){$_[0]{'statements'}=$_[1]}else{$_[0]{'statements'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$statements)=@_;
(do{$self->new("match", $match, "statements", $statements)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Block($self)})};
sub node_name{my $self=CORE::shift;(do{"Block"})};
sub field_names{my $self=CORE::shift;(do{["statements"]})};
sub field_values{my $self=CORE::shift;(do{[$self->statements]})};
sub irx1_describe{my $self=CORE::shift;(do{(("Block\(" . $self->statements->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Use;
use base "Any";BEGIN{unshift(@IRx1::Use::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub kind { if(@_==2){$_[0]{'kind'}=$_[1]}else{$_[0]{'kind'}}};
sub module_name { if(@_==2){$_[0]{'module_name'}=$_[1]}else{$_[0]{'module_name'}}};
sub expr { if(@_==2){$_[0]{'expr'}=$_[1]}else{$_[0]{'expr'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$kind,$module_name,$expr)=@_;
(do{$self->new("match", $match, "kind", $kind, "module_name", $module_name, "expr", $expr)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Use($self)})};
sub node_name{my $self=CORE::shift;(do{"Use"})};
sub field_names{my $self=CORE::shift;(do{["kind", "module_name", "expr"]})};
sub field_values{my $self=CORE::shift;(do{[$self->kind, $self->module_name, $self->expr]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((("Use\(" . $self->kind->irx1_describe()) . "\,") . $self->module_name->irx1_describe()) . "\,") . $self->expr->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::PackageDecl;
use base "Any";BEGIN{unshift(@IRx1::PackageDecl::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub scope { if(@_==2){$_[0]{'scope'}=$_[1]}else{$_[0]{'scope'}}};
sub plurality { if(@_==2){$_[0]{'plurality'}=$_[1]}else{$_[0]{'plurality'}}};
sub kind { if(@_==2){$_[0]{'kind'}=$_[1]}else{$_[0]{'kind'}}};
sub name { if(@_==2){$_[0]{'name'}=$_[1]}else{$_[0]{'name'}}};
sub traits { if(@_==2){$_[0]{'traits'}=$_[1]}else{$_[0]{'traits'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$scope,$plurality,$kind,$name,$traits,$block)=@_;
(do{$self->new("match", $match, "scope", $scope, "plurality", $plurality, "kind", $kind, "name", $name, "traits", $traits, "block", $block)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__PackageDecl($self)})};
sub node_name{my $self=CORE::shift;(do{"PackageDecl"})};
sub field_names{my $self=CORE::shift;(do{["scope", "plurality", "kind", "name", "traits", "block"]})};
sub field_values{my $self=CORE::shift;(do{[$self->scope, $self->plurality, $self->kind, $self->name, $self->traits, $self->block]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((((((("PackageDecl\(" . $self->scope->irx1_describe()) . "\,") . $self->plurality->irx1_describe()) . "\,") . $self->kind->irx1_describe()) . "\,") . $self->name->irx1_describe()) . "\,") . $self->traits->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::MethodDecl;
use base "Any";BEGIN{unshift(@IRx1::MethodDecl::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub scope { if(@_==2){$_[0]{'scope'}=$_[1]}else{$_[0]{'scope'}}};
sub typenames { if(@_==2){$_[0]{'typenames'}=$_[1]}else{$_[0]{'typenames'}}};
sub plurality { if(@_==2){$_[0]{'plurality'}=$_[1]}else{$_[0]{'plurality'}}};
sub name { if(@_==2){$_[0]{'name'}=$_[1]}else{$_[0]{'name'}}};
sub multisig { if(@_==2){$_[0]{'multisig'}=$_[1]}else{$_[0]{'multisig'}}};
sub traits { if(@_==2){$_[0]{'traits'}=$_[1]}else{$_[0]{'traits'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub sigil { if(@_==2){$_[0]{'sigil'}=$_[1]}else{$_[0]{'sigil'}}};
sub postcircumfix { if(@_==2){$_[0]{'postcircumfix'}=$_[1]}else{$_[0]{'postcircumfix'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$scope,$typenames,$plurality,$name,$multisig,$traits,$block,$sigil,$postcircumfix)=@_;
(do{$self->new("match", $match, "scope", $scope, "typenames", $typenames, "plurality", $plurality, "name", $name, "multisig", $multisig, "traits", $traits, "block", $block, "sigil", $sigil, "postcircumfix", $postcircumfix)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__MethodDecl($self)})};
sub node_name{my $self=CORE::shift;(do{"MethodDecl"})};
sub field_names{my $self=CORE::shift;(do{["scope", "typenames", "plurality", "name", "multisig", "traits", "block", "sigil", "postcircumfix"]})};
sub field_values{my $self=CORE::shift;(do{[$self->scope, $self->typenames, $self->plurality, $self->name, $self->multisig, $self->traits, $self->block, $self->sigil, $self->postcircumfix]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((((((((((((("MethodDecl\(" . $self->scope->irx1_describe()) . "\,") . $self->typenames->irx1_describe()) . "\,") . $self->plurality->irx1_describe()) . "\,") . $self->name->irx1_describe()) . "\,") . $self->multisig->irx1_describe()) . "\,") . $self->traits->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\,") . $self->sigil->irx1_describe()) . "\,") . $self->postcircumfix->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::SubDecl;
use base "Any";BEGIN{unshift(@IRx1::SubDecl::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub scope { if(@_==2){$_[0]{'scope'}=$_[1]}else{$_[0]{'scope'}}};
sub typenames { if(@_==2){$_[0]{'typenames'}=$_[1]}else{$_[0]{'typenames'}}};
sub plurality { if(@_==2){$_[0]{'plurality'}=$_[1]}else{$_[0]{'plurality'}}};
sub name { if(@_==2){$_[0]{'name'}=$_[1]}else{$_[0]{'name'}}};
sub multisig { if(@_==2){$_[0]{'multisig'}=$_[1]}else{$_[0]{'multisig'}}};
sub traits { if(@_==2){$_[0]{'traits'}=$_[1]}else{$_[0]{'traits'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$scope,$typenames,$plurality,$name,$multisig,$traits,$block)=@_;
(do{$self->new("match", $match, "scope", $scope, "typenames", $typenames, "plurality", $plurality, "name", $name, "multisig", $multisig, "traits", $traits, "block", $block)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__SubDecl($self)})};
sub node_name{my $self=CORE::shift;(do{"SubDecl"})};
sub field_names{my $self=CORE::shift;(do{["scope", "typenames", "plurality", "name", "multisig", "traits", "block"]})};
sub field_values{my $self=CORE::shift;(do{[$self->scope, $self->typenames, $self->plurality, $self->name, $self->multisig, $self->traits, $self->block]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((((((((("SubDecl\(" . $self->scope->irx1_describe()) . "\,") . $self->typenames->irx1_describe()) . "\,") . $self->plurality->irx1_describe()) . "\,") . $self->name->irx1_describe()) . "\,") . $self->multisig->irx1_describe()) . "\,") . $self->traits->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::MacroDecl;
use base "Any";BEGIN{unshift(@IRx1::MacroDecl::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub scope { if(@_==2){$_[0]{'scope'}=$_[1]}else{$_[0]{'scope'}}};
sub typenames { if(@_==2){$_[0]{'typenames'}=$_[1]}else{$_[0]{'typenames'}}};
sub plurality { if(@_==2){$_[0]{'plurality'}=$_[1]}else{$_[0]{'plurality'}}};
sub name { if(@_==2){$_[0]{'name'}=$_[1]}else{$_[0]{'name'}}};
sub multisig { if(@_==2){$_[0]{'multisig'}=$_[1]}else{$_[0]{'multisig'}}};
sub traits { if(@_==2){$_[0]{'traits'}=$_[1]}else{$_[0]{'traits'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$scope,$typenames,$plurality,$name,$multisig,$traits,$block)=@_;
(do{$self->new("match", $match, "scope", $scope, "typenames", $typenames, "plurality", $plurality, "name", $name, "multisig", $multisig, "traits", $traits, "block", $block)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__MacroDecl($self)})};
sub node_name{my $self=CORE::shift;(do{"MacroDecl"})};
sub field_names{my $self=CORE::shift;(do{["scope", "typenames", "plurality", "name", "multisig", "traits", "block"]})};
sub field_values{my $self=CORE::shift;(do{[$self->scope, $self->typenames, $self->plurality, $self->name, $self->multisig, $self->traits, $self->block]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((((((((("MacroDecl\(" . $self->scope->irx1_describe()) . "\,") . $self->typenames->irx1_describe()) . "\,") . $self->plurality->irx1_describe()) . "\,") . $self->name->irx1_describe()) . "\,") . $self->multisig->irx1_describe()) . "\,") . $self->traits->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::VarDecl;
use base "Any";BEGIN{unshift(@IRx1::VarDecl::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub scope { if(@_==2){$_[0]{'scope'}=$_[1]}else{$_[0]{'scope'}}};
sub typenames { if(@_==2){$_[0]{'typenames'}=$_[1]}else{$_[0]{'typenames'}}};
sub plurality { if(@_==2){$_[0]{'plurality'}=$_[1]}else{$_[0]{'plurality'}}};
sub var { if(@_==2){$_[0]{'var'}=$_[1]}else{$_[0]{'var'}}};
sub postcircumfix { if(@_==2){$_[0]{'postcircumfix'}=$_[1]}else{$_[0]{'postcircumfix'}}};
sub traits { if(@_==2){$_[0]{'traits'}=$_[1]}else{$_[0]{'traits'}}};
sub default_op { if(@_==2){$_[0]{'default_op'}=$_[1]}else{$_[0]{'default_op'}}};
sub default_expr { if(@_==2){$_[0]{'default_expr'}=$_[1]}else{$_[0]{'default_expr'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$scope,$typenames,$plurality,$var,$postcircumfix,$traits,$default_op,$default_expr)=@_;
(do{$self->new("match", $match, "scope", $scope, "typenames", $typenames, "plurality", $plurality, "var", $var, "postcircumfix", $postcircumfix, "traits", $traits, "default_op", $default_op, "default_expr", $default_expr)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__VarDecl($self)})};
sub node_name{my $self=CORE::shift;(do{"VarDecl"})};
sub field_names{my $self=CORE::shift;(do{["scope", "typenames", "plurality", "var", "postcircumfix", "traits", "default_op", "default_expr"]})};
sub field_values{my $self=CORE::shift;(do{[$self->scope, $self->typenames, $self->plurality, $self->var, $self->postcircumfix, $self->traits, $self->default_op, $self->default_expr]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((((((((((("VarDecl\(" . $self->scope->irx1_describe()) . "\,") . $self->typenames->irx1_describe()) . "\,") . $self->plurality->irx1_describe()) . "\,") . $self->var->irx1_describe()) . "\,") . $self->postcircumfix->irx1_describe()) . "\,") . $self->traits->irx1_describe()) . "\,") . $self->default_op->irx1_describe()) . "\,") . $self->default_expr->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Var;
use base "Any";BEGIN{unshift(@IRx1::Var::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub sigil { if(@_==2){$_[0]{'sigil'}=$_[1]}else{$_[0]{'sigil'}}};
sub twigil { if(@_==2){$_[0]{'twigil'}=$_[1]}else{$_[0]{'twigil'}}};
sub name { if(@_==2){$_[0]{'name'}=$_[1]}else{$_[0]{'name'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$sigil,$twigil,$name)=@_;
(do{$self->new("match", $match, "sigil", $sigil, "twigil", $twigil, "name", $name)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Var($self)})};
sub node_name{my $self=CORE::shift;(do{"Var"})};
sub field_names{my $self=CORE::shift;(do{["sigil", "twigil", "name"]})};
sub field_values{my $self=CORE::shift;(do{[$self->sigil, $self->twigil, $self->name]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((("Var\(" . $self->sigil->irx1_describe()) . "\,") . $self->twigil->irx1_describe()) . "\,") . $self->name->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Trait;
use base "Any";BEGIN{unshift(@IRx1::Trait::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub verb { if(@_==2){$_[0]{'verb'}=$_[1]}else{$_[0]{'verb'}}};
sub expr { if(@_==2){$_[0]{'expr'}=$_[1]}else{$_[0]{'expr'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$verb,$expr)=@_;
(do{$self->new("match", $match, "verb", $verb, "expr", $expr)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Trait($self)})};
sub node_name{my $self=CORE::shift;(do{"Trait"})};
sub field_names{my $self=CORE::shift;(do{["verb", "expr"]})};
sub field_values{my $self=CORE::shift;(do{[$self->verb, $self->expr]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Trait\(" . $self->verb->irx1_describe()) . "\,") . $self->expr->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::ClosureTrait;
use base "Any";BEGIN{unshift(@IRx1::ClosureTrait::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub kind { if(@_==2){$_[0]{'kind'}=$_[1]}else{$_[0]{'kind'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$kind,$block)=@_;
(do{$self->new("match", $match, "kind", $kind, "block", $block)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__ClosureTrait($self)})};
sub node_name{my $self=CORE::shift;(do{"ClosureTrait"})};
sub field_names{my $self=CORE::shift;(do{["kind", "block"]})};
sub field_values{my $self=CORE::shift;(do{[$self->kind, $self->block]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("ClosureTrait\(" . $self->kind->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::ModuleName;
use base "Any";BEGIN{unshift(@IRx1::ModuleName::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub name { if(@_==2){$_[0]{'name'}=$_[1]}else{$_[0]{'name'}}};
sub pairs { if(@_==2){$_[0]{'pairs'}=$_[1]}else{$_[0]{'pairs'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$name,$pairs)=@_;
(do{$self->new("match", $match, "name", $name, "pairs", $pairs)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__ModuleName($self)})};
sub node_name{my $self=CORE::shift;(do{"ModuleName"})};
sub field_names{my $self=CORE::shift;(do{["name", "pairs"]})};
sub field_values{my $self=CORE::shift;(do{[$self->name, $self->pairs]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("ModuleName\(" . $self->name->irx1_describe()) . "\,") . $self->pairs->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::PathName;
use base "Any";BEGIN{unshift(@IRx1::PathName::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub path { if(@_==2){$_[0]{'path'}=$_[1]}else{$_[0]{'path'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$path)=@_;
(do{$self->new("match", $match, "path", $path)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__PathName($self)})};
sub node_name{my $self=CORE::shift;(do{"PathName"})};
sub field_names{my $self=CORE::shift;(do{["path"]})};
sub field_values{my $self=CORE::shift;(do{[$self->path]})};
sub irx1_describe{my $self=CORE::shift;(do{(("PathName\(" . $self->path->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::SubName;
use base "Any";BEGIN{unshift(@IRx1::SubName::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub category { if(@_==2){$_[0]{'category'}=$_[1]}else{$_[0]{'category'}}};
sub pairs { if(@_==2){$_[0]{'pairs'}=$_[1]}else{$_[0]{'pairs'}}};
sub desigilname { if(@_==2){$_[0]{'desigilname'}=$_[1]}else{$_[0]{'desigilname'}}};
sub signature { if(@_==2){$_[0]{'signature'}=$_[1]}else{$_[0]{'signature'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$category,$pairs,$desigilname,$signature)=@_;
(do{$self->new("match", $match, "category", $category, "pairs", $pairs, "desigilname", $desigilname, "signature", $signature)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__SubName($self)})};
sub node_name{my $self=CORE::shift;(do{"SubName"})};
sub field_names{my $self=CORE::shift;(do{["category", "pairs", "desigilname", "signature"]})};
sub field_values{my $self=CORE::shift;(do{[$self->category, $self->pairs, $self->desigilname, $self->signature]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((("SubName\(" . $self->category->irx1_describe()) . "\,") . $self->pairs->irx1_describe()) . "\,") . $self->desigilname->irx1_describe()) . "\,") . $self->signature->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::ShapedParamName;
use base "Any";BEGIN{unshift(@IRx1::ShapedParamName::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub ident { if(@_==2){$_[0]{'ident'}=$_[1]}else{$_[0]{'ident'}}};
sub postcircumfix { if(@_==2){$_[0]{'postcircumfix'}=$_[1]}else{$_[0]{'postcircumfix'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$ident,$postcircumfix)=@_;
(do{$self->new("match", $match, "ident", $ident, "postcircumfix", $postcircumfix)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__ShapedParamName($self)})};
sub node_name{my $self=CORE::shift;(do{"ShapedParamName"})};
sub field_names{my $self=CORE::shift;(do{["ident", "postcircumfix"]})};
sub field_values{my $self=CORE::shift;(do{[$self->ident, $self->postcircumfix]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("ShapedParamName\(" . $self->ident->irx1_describe()) . "\,") . $self->postcircumfix->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Call;
use base "Any";BEGIN{unshift(@IRx1::Call::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub invocant { if(@_==2){$_[0]{'invocant'}=$_[1]}else{$_[0]{'invocant'}}};
sub method { if(@_==2){$_[0]{'method'}=$_[1]}else{$_[0]{'method'}}};
sub capture { if(@_==2){$_[0]{'capture'}=$_[1]}else{$_[0]{'capture'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$invocant,$method,$capture)=@_;
(do{$self->new("match", $match, "invocant", $invocant, "method", $method, "capture", $capture)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Call($self)})};
sub node_name{my $self=CORE::shift;(do{"Call"})};
sub field_names{my $self=CORE::shift;(do{["invocant", "method", "capture"]})};
sub field_values{my $self=CORE::shift;(do{[$self->invocant, $self->method, $self->capture]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((("Call\(" . $self->invocant->irx1_describe()) . "\,") . $self->method->irx1_describe()) . "\,") . $self->capture->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Apply;
use base "Any";BEGIN{unshift(@IRx1::Apply::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub function { if(@_==2){$_[0]{'function'}=$_[1]}else{$_[0]{'function'}}};
sub capture { if(@_==2){$_[0]{'capture'}=$_[1]}else{$_[0]{'capture'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$function,$capture)=@_;
(do{$self->new("match", $match, "function", $function, "capture", $capture)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Apply($self)})};
sub node_name{my $self=CORE::shift;(do{"Apply"})};
sub field_names{my $self=CORE::shift;(do{["function", "capture"]})};
sub field_values{my $self=CORE::shift;(do{[$self->function, $self->capture]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Apply\(" . $self->function->irx1_describe()) . "\,") . $self->capture->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Hyper;
use base "Any";BEGIN{unshift(@IRx1::Hyper::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub operator { if(@_==2){$_[0]{'operator'}=$_[1]}else{$_[0]{'operator'}}};
sub capture { if(@_==2){$_[0]{'capture'}=$_[1]}else{$_[0]{'capture'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$operator,$capture)=@_;
(do{$self->new("match", $match, "operator", $operator, "capture", $capture)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Hyper($self)})};
sub node_name{my $self=CORE::shift;(do{"Hyper"})};
sub field_names{my $self=CORE::shift;(do{["operator", "capture"]})};
sub field_values{my $self=CORE::shift;(do{[$self->operator, $self->capture]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Hyper\(" . $self->operator->irx1_describe()) . "\,") . $self->capture->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Capture;
use base "Any";BEGIN{unshift(@IRx1::Capture::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub arguments { if(@_==2){$_[0]{'arguments'}=$_[1]}else{$_[0]{'arguments'}}};
sub invocant { if(@_==2){$_[0]{'invocant'}=$_[1]}else{$_[0]{'invocant'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$arguments,$invocant)=@_;
(do{$self->new("match", $match, "arguments", $arguments, "invocant", $invocant)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Capture($self)})};
sub node_name{my $self=CORE::shift;(do{"Capture"})};
sub field_names{my $self=CORE::shift;(do{["arguments", "invocant"]})};
sub field_values{my $self=CORE::shift;(do{[$self->arguments, $self->invocant]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Capture\(" . $self->arguments->irx1_describe()) . "\,") . $self->invocant->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::MultiSig;
use base "Any";BEGIN{unshift(@IRx1::MultiSig::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub signatures { if(@_==2){$_[0]{'signatures'}=$_[1]}else{$_[0]{'signatures'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$signatures)=@_;
(do{$self->new("match", $match, "signatures", $signatures)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__MultiSig($self)})};
sub node_name{my $self=CORE::shift;(do{"MultiSig"})};
sub field_names{my $self=CORE::shift;(do{["signatures"]})};
sub field_values{my $self=CORE::shift;(do{[$self->signatures]})};
sub irx1_describe{my $self=CORE::shift;(do{(("MultiSig\(" . $self->signatures->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Signature;
use base "Any";BEGIN{unshift(@IRx1::Signature::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub parameters { if(@_==2){$_[0]{'parameters'}=$_[1]}else{$_[0]{'parameters'}}};
sub return_type { if(@_==2){$_[0]{'return_type'}=$_[1]}else{$_[0]{'return_type'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$parameters,$return_type)=@_;
(do{$self->new("match", $match, "parameters", $parameters, "return_type", $return_type)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Signature($self)})};
sub node_name{my $self=CORE::shift;(do{"Signature"})};
sub field_names{my $self=CORE::shift;(do{["parameters", "return_type"]})};
sub field_values{my $self=CORE::shift;(do{[$self->parameters, $self->return_type]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Signature\(" . $self->parameters->irx1_describe()) . "\,") . $self->return_type->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Parameter;
use base "Any";BEGIN{unshift(@IRx1::Parameter::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub type_constraints { if(@_==2){$_[0]{'type_constraints'}=$_[1]}else{$_[0]{'type_constraints'}}};
sub quant { if(@_==2){$_[0]{'quant'}=$_[1]}else{$_[0]{'quant'}}};
sub param_var { if(@_==2){$_[0]{'param_var'}=$_[1]}else{$_[0]{'param_var'}}};
sub ident { if(@_==2){$_[0]{'ident'}=$_[1]}else{$_[0]{'ident'}}};
sub traits { if(@_==2){$_[0]{'traits'}=$_[1]}else{$_[0]{'traits'}}};
sub post_constraints { if(@_==2){$_[0]{'post_constraints'}=$_[1]}else{$_[0]{'post_constraints'}}};
sub default_expr { if(@_==2){$_[0]{'default_expr'}=$_[1]}else{$_[0]{'default_expr'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$type_constraints,$quant,$param_var,$ident,$traits,$post_constraints,$default_expr)=@_;
(do{$self->new("match", $match, "type_constraints", $type_constraints, "quant", $quant, "param_var", $param_var, "ident", $ident, "traits", $traits, "post_constraints", $post_constraints, "default_expr", $default_expr)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Parameter($self)})};
sub node_name{my $self=CORE::shift;(do{"Parameter"})};
sub field_names{my $self=CORE::shift;(do{["type_constraints", "quant", "param_var", "ident", "traits", "post_constraints", "default_expr"]})};
sub field_values{my $self=CORE::shift;(do{[$self->type_constraints, $self->quant, $self->param_var, $self->ident, $self->traits, $self->post_constraints, $self->default_expr]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((((((((("Parameter\(" . $self->type_constraints->irx1_describe()) . "\,") . $self->quant->irx1_describe()) . "\,") . $self->param_var->irx1_describe()) . "\,") . $self->ident->irx1_describe()) . "\,") . $self->traits->irx1_describe()) . "\,") . $self->post_constraints->irx1_describe()) . "\,") . $self->default_expr->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::TypeConstraint;
use base "Any";BEGIN{unshift(@IRx1::TypeConstraint::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub value { if(@_==2){$_[0]{'value'}=$_[1]}else{$_[0]{'value'}}};
sub where_expr { if(@_==2){$_[0]{'where_expr'}=$_[1]}else{$_[0]{'where_expr'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$value,$where_expr)=@_;
(do{$self->new("match", $match, "value", $value, "where_expr", $where_expr)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__TypeConstraint($self)})};
sub node_name{my $self=CORE::shift;(do{"TypeConstraint"})};
sub field_names{my $self=CORE::shift;(do{["value", "where_expr"]})};
sub field_values{my $self=CORE::shift;(do{[$self->value, $self->where_expr]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("TypeConstraint\(" . $self->value->irx1_describe()) . "\,") . $self->where_expr->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::PostConstraint;
use base "Any";BEGIN{unshift(@IRx1::PostConstraint::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub multisig { if(@_==2){$_[0]{'multisig'}=$_[1]}else{$_[0]{'multisig'}}};
sub where_expr { if(@_==2){$_[0]{'where_expr'}=$_[1]}else{$_[0]{'where_expr'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$multisig,$where_expr)=@_;
(do{$self->new("match", $match, "multisig", $multisig, "where_expr", $where_expr)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__PostConstraint($self)})};
sub node_name{my $self=CORE::shift;(do{"PostConstraint"})};
sub field_names{my $self=CORE::shift;(do{["multisig", "where_expr"]})};
sub field_values{my $self=CORE::shift;(do{[$self->multisig, $self->where_expr]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("PostConstraint\(" . $self->multisig->irx1_describe()) . "\,") . $self->where_expr->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::ParamVar;
use base "Any";BEGIN{unshift(@IRx1::ParamVar::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub sigil { if(@_==2){$_[0]{'sigil'}=$_[1]}else{$_[0]{'sigil'}}};
sub twigil { if(@_==2){$_[0]{'twigil'}=$_[1]}else{$_[0]{'twigil'}}};
sub name { if(@_==2){$_[0]{'name'}=$_[1]}else{$_[0]{'name'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$sigil,$twigil,$name)=@_;
(do{$self->new("match", $match, "sigil", $sigil, "twigil", $twigil, "name", $name)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__ParamVar($self)})};
sub node_name{my $self=CORE::shift;(do{"ParamVar"})};
sub field_names{my $self=CORE::shift;(do{["sigil", "twigil", "name"]})};
sub field_values{my $self=CORE::shift;(do{[$self->sigil, $self->twigil, $self->name]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((("ParamVar\(" . $self->sigil->irx1_describe()) . "\,") . $self->twigil->irx1_describe()) . "\,") . $self->name->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Undef;
use base "Any";BEGIN{unshift(@IRx1::Undef::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match)=@_;
(do{$self->new("match", $match)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Undef($self)})};
sub node_name{my $self=CORE::shift;(do{"Undef"})};
sub field_names{my $self=CORE::shift;(do{[]})};
sub field_values{my $self=CORE::shift;(do{[]})};
sub irx1_describe{my $self=CORE::shift;(do{("Undef\(" . "\)")})}})
}
;

{ package IRx1::NumInt;
use base "Any";BEGIN{unshift(@IRx1::NumInt::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub text { if(@_==2){$_[0]{'text'}=$_[1]}else{$_[0]{'text'}}};
sub base { if(@_==2){$_[0]{'base'}=$_[1]}else{$_[0]{'base'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$text,$base)=@_;
(do{$self->new("match", $match, "text", $text, "base", $base)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__NumInt($self)})};
sub node_name{my $self=CORE::shift;(do{"NumInt"})};
sub field_names{my $self=CORE::shift;(do{["text", "base"]})};
sub field_values{my $self=CORE::shift;(do{[$self->text, $self->base]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("NumInt\(" . $self->text->irx1_describe()) . "\,") . $self->base->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::NumDec;
use base "Any";BEGIN{unshift(@IRx1::NumDec::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub intpart { if(@_==2){$_[0]{'intpart'}=$_[1]}else{$_[0]{'intpart'}}};
sub fracpart { if(@_==2){$_[0]{'fracpart'}=$_[1]}else{$_[0]{'fracpart'}}};
sub exp { if(@_==2){$_[0]{'exp'}=$_[1]}else{$_[0]{'exp'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$intpart,$fracpart,$exp)=@_;
(do{$self->new("match", $match, "intpart", $intpart, "fracpart", $fracpart, "exp", $exp)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__NumDec($self)})};
sub node_name{my $self=CORE::shift;(do{"NumDec"})};
sub field_names{my $self=CORE::shift;(do{["intpart", "fracpart", "exp"]})};
sub field_values{my $self=CORE::shift;(do{[$self->intpart, $self->fracpart, $self->exp]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((("NumDec\(" . $self->intpart->irx1_describe()) . "\,") . $self->fracpart->irx1_describe()) . "\,") . $self->exp->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::NumRad;
use base "Any";BEGIN{unshift(@IRx1::NumRad::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub radix { if(@_==2){$_[0]{'radix'}=$_[1]}else{$_[0]{'radix'}}};
sub intpart { if(@_==2){$_[0]{'intpart'}=$_[1]}else{$_[0]{'intpart'}}};
sub fracpart { if(@_==2){$_[0]{'fracpart'}=$_[1]}else{$_[0]{'fracpart'}}};
sub base { if(@_==2){$_[0]{'base'}=$_[1]}else{$_[0]{'base'}}};
sub exp { if(@_==2){$_[0]{'exp'}=$_[1]}else{$_[0]{'exp'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$radix,$intpart,$fracpart,$base,$exp)=@_;
(do{$self->new("match", $match, "radix", $radix, "intpart", $intpart, "fracpart", $fracpart, "base", $base, "exp", $exp)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__NumRad($self)})};
sub node_name{my $self=CORE::shift;(do{"NumRad"})};
sub field_names{my $self=CORE::shift;(do{["radix", "intpart", "fracpart", "base", "exp"]})};
sub field_values{my $self=CORE::shift;(do{[$self->radix, $self->intpart, $self->fracpart, $self->base, $self->exp]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((((("NumRad\(" . $self->radix->irx1_describe()) . "\,") . $self->intpart->irx1_describe()) . "\,") . $self->fracpart->irx1_describe()) . "\,") . $self->base->irx1_describe()) . "\,") . $self->exp->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Array;
use base "Any";BEGIN{unshift(@IRx1::Array::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub array { if(@_==2){$_[0]{'array'}=$_[1]}else{$_[0]{'array'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$array)=@_;
(do{$self->new("match", $match, "array", $array)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Array($self)})};
sub node_name{my $self=CORE::shift;(do{"Array"})};
sub field_names{my $self=CORE::shift;(do{["array"]})};
sub field_values{my $self=CORE::shift;(do{[$self->array]})};
sub irx1_describe{my $self=CORE::shift;(do{(("Array\(" . $self->array->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Hash;
use base "Any";BEGIN{unshift(@IRx1::Hash::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub hash { if(@_==2){$_[0]{'hash'}=$_[1]}else{$_[0]{'hash'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$hash)=@_;
(do{$self->new("match", $match, "hash", $hash)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Hash($self)})};
sub node_name{my $self=CORE::shift;(do{"Hash"})};
sub field_names{my $self=CORE::shift;(do{["hash"]})};
sub field_values{my $self=CORE::shift;(do{[$self->hash]})};
sub irx1_describe{my $self=CORE::shift;(do{(("Hash\(" . $self->hash->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Pair;
use base "Any";BEGIN{unshift(@IRx1::Pair::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub key { if(@_==2){$_[0]{'key'}=$_[1]}else{$_[0]{'key'}}};
sub value { if(@_==2){$_[0]{'value'}=$_[1]}else{$_[0]{'value'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$key,$value)=@_;
(do{$self->new("match", $match, "key", $key, "value", $value)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Pair($self)})};
sub node_name{my $self=CORE::shift;(do{"Pair"})};
sub field_names{my $self=CORE::shift;(do{["key", "value"]})};
sub field_values{my $self=CORE::shift;(do{[$self->key, $self->value]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Pair\(" . $self->key->irx1_describe()) . "\,") . $self->value->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Type;
use base "Any";BEGIN{unshift(@IRx1::Type::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub typename { if(@_==2){$_[0]{'typename'}=$_[1]}else{$_[0]{'typename'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$typename)=@_;
(do{$self->new("match", $match, "typename", $typename)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Type($self)})};
sub node_name{my $self=CORE::shift;(do{"Type"})};
sub field_names{my $self=CORE::shift;(do{["typename"]})};
sub field_values{my $self=CORE::shift;(do{[$self->typename]})};
sub irx1_describe{my $self=CORE::shift;(do{(("Type\(" . $self->typename->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Rx;
use base "Any";BEGIN{unshift(@IRx1::Rx::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub pat { if(@_==2){$_[0]{'pat'}=$_[1]}else{$_[0]{'pat'}}};
sub modifiers { if(@_==2){$_[0]{'modifiers'}=$_[1]}else{$_[0]{'modifiers'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$pat,$modifiers)=@_;
(do{$self->new("match", $match, "pat", $pat, "modifiers", $modifiers)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Rx($self)})};
sub node_name{my $self=CORE::shift;(do{"Rx"})};
sub field_names{my $self=CORE::shift;(do{["pat", "modifiers"]})};
sub field_values{my $self=CORE::shift;(do{[$self->pat, $self->modifiers]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Rx\(" . $self->pat->irx1_describe()) . "\,") . $self->modifiers->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Buf;
use base "Any";BEGIN{unshift(@IRx1::Buf::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub buf { if(@_==2){$_[0]{'buf'}=$_[1]}else{$_[0]{'buf'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$buf)=@_;
(do{$self->new("match", $match, "buf", $buf)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Buf($self)})};
sub node_name{my $self=CORE::shift;(do{"Buf"})};
sub field_names{my $self=CORE::shift;(do{["buf"]})};
sub field_values{my $self=CORE::shift;(do{[$self->buf]})};
sub irx1_describe{my $self=CORE::shift;(do{(("Buf\(" . $self->buf->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::For;
use base "Any";BEGIN{unshift(@IRx1::For::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub expr { if(@_==2){$_[0]{'expr'}=$_[1]}else{$_[0]{'expr'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$expr,$block)=@_;
(do{$self->new("match", $match, "expr", $expr, "block", $block)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__For($self)})};
sub node_name{my $self=CORE::shift;(do{"For"})};
sub field_names{my $self=CORE::shift;(do{["expr", "block"]})};
sub field_values{my $self=CORE::shift;(do{[$self->expr, $self->block]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("For\(" . $self->expr->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Cond;
use base "Any";BEGIN{unshift(@IRx1::Cond::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub clauses { if(@_==2){$_[0]{'clauses'}=$_[1]}else{$_[0]{'clauses'}}};
sub default { if(@_==2){$_[0]{'default'}=$_[1]}else{$_[0]{'default'}}};
sub invert_first_test { if(@_==2){$_[0]{'invert_first_test'}=$_[1]}else{$_[0]{'invert_first_test'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$clauses,$default,$invert_first_test)=@_;
(do{$self->new("match", $match, "clauses", $clauses, "default", $default, "invert_first_test", $invert_first_test)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Cond($self)})};
sub node_name{my $self=CORE::shift;(do{"Cond"})};
sub field_names{my $self=CORE::shift;(do{["clauses", "default", "invert_first_test"]})};
sub field_values{my $self=CORE::shift;(do{[$self->clauses, $self->default, $self->invert_first_test]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((("Cond\(" . $self->clauses->irx1_describe()) . "\,") . $self->default->irx1_describe()) . "\,") . $self->invert_first_test->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Loop;
use base "Any";BEGIN{unshift(@IRx1::Loop::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub pretest { if(@_==2){$_[0]{'pretest'}=$_[1]}else{$_[0]{'pretest'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub posttest { if(@_==2){$_[0]{'posttest'}=$_[1]}else{$_[0]{'posttest'}}};
sub label { if(@_==2){$_[0]{'label'}=$_[1]}else{$_[0]{'label'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$pretest,$block,$posttest,$label)=@_;
(do{$self->new("match", $match, "pretest", $pretest, "block", $block, "posttest", $posttest, "label", $label)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Loop($self)})};
sub node_name{my $self=CORE::shift;(do{"Loop"})};
sub field_names{my $self=CORE::shift;(do{["pretest", "block", "posttest", "label"]})};
sub field_values{my $self=CORE::shift;(do{[$self->pretest, $self->block, $self->posttest, $self->label]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((("Loop\(" . $self->pretest->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\,") . $self->posttest->irx1_describe()) . "\,") . $self->label->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Given;
use base "Any";BEGIN{unshift(@IRx1::Given::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub expr { if(@_==2){$_[0]{'expr'}=$_[1]}else{$_[0]{'expr'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$expr,$block)=@_;
(do{$self->new("match", $match, "expr", $expr, "block", $block)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Given($self)})};
sub node_name{my $self=CORE::shift;(do{"Given"})};
sub field_names{my $self=CORE::shift;(do{["expr", "block"]})};
sub field_values{my $self=CORE::shift;(do{[$self->expr, $self->block]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Given\(" . $self->expr->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::When;
use base "Any";BEGIN{unshift(@IRx1::When::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub expr { if(@_==2){$_[0]{'expr'}=$_[1]}else{$_[0]{'expr'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$expr,$block)=@_;
(do{$self->new("match", $match, "expr", $expr, "block", $block)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__When($self)})};
sub node_name{my $self=CORE::shift;(do{"When"})};
sub field_names{my $self=CORE::shift;(do{["expr", "block"]})};
sub field_values{my $self=CORE::shift;(do{[$self->expr, $self->block]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("When\(" . $self->expr->irx1_describe()) . "\,") . $self->block->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Label;
use base "Any";BEGIN{unshift(@IRx1::Label::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub labels { if(@_==2){$_[0]{'labels'}=$_[1]}else{$_[0]{'labels'}}};
sub statement { if(@_==2){$_[0]{'statement'}=$_[1]}else{$_[0]{'statement'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$labels,$statement)=@_;
(do{$self->new("match", $match, "labels", $labels, "statement", $statement)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Label($self)})};
sub node_name{my $self=CORE::shift;(do{"Label"})};
sub field_names{my $self=CORE::shift;(do{["labels", "statement"]})};
sub field_values{my $self=CORE::shift;(do{[$self->labels, $self->statement]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("Label\(" . $self->labels->irx1_describe()) . "\,") . $self->statement->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RegexDef;
use base "Any";BEGIN{unshift(@IRx1::RegexDef::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub kind { if(@_==2){$_[0]{'kind'}=$_[1]}else{$_[0]{'kind'}}};
sub ident { if(@_==2){$_[0]{'ident'}=$_[1]}else{$_[0]{'ident'}}};
sub signature { if(@_==2){$_[0]{'signature'}=$_[1]}else{$_[0]{'signature'}}};
sub traits { if(@_==2){$_[0]{'traits'}=$_[1]}else{$_[0]{'traits'}}};
sub pattern { if(@_==2){$_[0]{'pattern'}=$_[1]}else{$_[0]{'pattern'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$kind,$ident,$signature,$traits,$pattern)=@_;
(do{$self->new("match", $match, "kind", $kind, "ident", $ident, "signature", $signature, "traits", $traits, "pattern", $pattern)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RegexDef($self)})};
sub node_name{my $self=CORE::shift;(do{"RegexDef"})};
sub field_names{my $self=CORE::shift;(do{["kind", "ident", "signature", "traits", "pattern"]})};
sub field_values{my $self=CORE::shift;(do{[$self->kind, $self->ident, $self->signature, $self->traits, $self->pattern]})};
sub irx1_describe{my $self=CORE::shift;(do{(((((((((("RegexDef\(" . $self->kind->irx1_describe()) . "\,") . $self->ident->irx1_describe()) . "\,") . $self->signature->irx1_describe()) . "\,") . $self->traits->irx1_describe()) . "\,") . $self->pattern->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::Regex;
use base "Any";BEGIN{unshift(@IRx1::Regex::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub patterns { if(@_==2){$_[0]{'patterns'}=$_[1]}else{$_[0]{'patterns'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$patterns)=@_;
(do{$self->new("match", $match, "patterns", $patterns)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__Regex($self)})};
sub node_name{my $self=CORE::shift;(do{"Regex"})};
sub field_names{my $self=CORE::shift;(do{["patterns"]})};
sub field_values{my $self=CORE::shift;(do{[$self->patterns]})};
sub irx1_describe{my $self=CORE::shift;(do{(("Regex\(" . $self->patterns->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxFirst;
use base "Any";BEGIN{unshift(@IRx1::RxFirst::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub patterns { if(@_==2){$_[0]{'patterns'}=$_[1]}else{$_[0]{'patterns'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$patterns)=@_;
(do{$self->new("match", $match, "patterns", $patterns)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxFirst($self)})};
sub node_name{my $self=CORE::shift;(do{"RxFirst"})};
sub field_names{my $self=CORE::shift;(do{["patterns"]})};
sub field_values{my $self=CORE::shift;(do{[$self->patterns]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxFirst\(" . $self->patterns->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxEvery;
use base "Any";BEGIN{unshift(@IRx1::RxEvery::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub patterns { if(@_==2){$_[0]{'patterns'}=$_[1]}else{$_[0]{'patterns'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$patterns)=@_;
(do{$self->new("match", $match, "patterns", $patterns)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxEvery($self)})};
sub node_name{my $self=CORE::shift;(do{"RxEvery"})};
sub field_names{my $self=CORE::shift;(do{["patterns"]})};
sub field_values{my $self=CORE::shift;(do{[$self->patterns]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxEvery\(" . $self->patterns->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxSubmatch;
use base "Any";BEGIN{unshift(@IRx1::RxSubmatch::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub patterns { if(@_==2){$_[0]{'patterns'}=$_[1]}else{$_[0]{'patterns'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$patterns)=@_;
(do{$self->new("match", $match, "patterns", $patterns)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxSubmatch($self)})};
sub node_name{my $self=CORE::shift;(do{"RxSubmatch"})};
sub field_names{my $self=CORE::shift;(do{["patterns"]})};
sub field_values{my $self=CORE::shift;(do{[$self->patterns]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxSubmatch\(" . $self->patterns->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxAny;
use base "Any";BEGIN{unshift(@IRx1::RxAny::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub patterns { if(@_==2){$_[0]{'patterns'}=$_[1]}else{$_[0]{'patterns'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$patterns)=@_;
(do{$self->new("match", $match, "patterns", $patterns)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxAny($self)})};
sub node_name{my $self=CORE::shift;(do{"RxAny"})};
sub field_names{my $self=CORE::shift;(do{["patterns"]})};
sub field_values{my $self=CORE::shift;(do{[$self->patterns]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxAny\(" . $self->patterns->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxAll;
use base "Any";BEGIN{unshift(@IRx1::RxAll::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub patterns { if(@_==2){$_[0]{'patterns'}=$_[1]}else{$_[0]{'patterns'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$patterns)=@_;
(do{$self->new("match", $match, "patterns", $patterns)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxAll($self)})};
sub node_name{my $self=CORE::shift;(do{"RxAll"})};
sub field_names{my $self=CORE::shift;(do{["patterns"]})};
sub field_values{my $self=CORE::shift;(do{[$self->patterns]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxAll\(" . $self->patterns->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxSequence;
use base "Any";BEGIN{unshift(@IRx1::RxSequence::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub patterns { if(@_==2){$_[0]{'patterns'}=$_[1]}else{$_[0]{'patterns'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$patterns)=@_;
(do{$self->new("match", $match, "patterns", $patterns)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxSequence($self)})};
sub node_name{my $self=CORE::shift;(do{"RxSequence"})};
sub field_names{my $self=CORE::shift;(do{["patterns"]})};
sub field_values{my $self=CORE::shift;(do{[$self->patterns]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxSequence\(" . $self->patterns->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxQuantifiedAtom;
use base "Any";BEGIN{unshift(@IRx1::RxQuantifiedAtom::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub atom { if(@_==2){$_[0]{'atom'}=$_[1]}else{$_[0]{'atom'}}};
sub quantifier { if(@_==2){$_[0]{'quantifier'}=$_[1]}else{$_[0]{'quantifier'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$atom,$quantifier)=@_;
(do{$self->new("match", $match, "atom", $atom, "quantifier", $quantifier)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxQuantifiedAtom($self)})};
sub node_name{my $self=CORE::shift;(do{"RxQuantifiedAtom"})};
sub field_names{my $self=CORE::shift;(do{["atom", "quantifier"]})};
sub field_values{my $self=CORE::shift;(do{[$self->atom, $self->quantifier]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("RxQuantifiedAtom\(" . $self->atom->irx1_describe()) . "\,") . $self->quantifier->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxBackslash;
use base "Any";BEGIN{unshift(@IRx1::RxBackslash::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub char { if(@_==2){$_[0]{'char'}=$_[1]}else{$_[0]{'char'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$char)=@_;
(do{$self->new("match", $match, "char", $char)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxBackslash($self)})};
sub node_name{my $self=CORE::shift;(do{"RxBackslash"})};
sub field_names{my $self=CORE::shift;(do{["char"]})};
sub field_values{my $self=CORE::shift;(do{[$self->char]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxBackslash\(" . $self->char->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxAssertion;
use base "Any";BEGIN{unshift(@IRx1::RxAssertion::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub ident { if(@_==2){$_[0]{'ident'}=$_[1]}else{$_[0]{'ident'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$ident)=@_;
(do{$self->new("match", $match, "ident", $ident)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxAssertion($self)})};
sub node_name{my $self=CORE::shift;(do{"RxAssertion"})};
sub field_names{my $self=CORE::shift;(do{["ident"]})};
sub field_values{my $self=CORE::shift;(do{[$self->ident]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxAssertion\(" . $self->ident->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxModInternal;
use base "Any";BEGIN{unshift(@IRx1::RxModInternal::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub mod { if(@_==2){$_[0]{'mod'}=$_[1]}else{$_[0]{'mod'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$mod)=@_;
(do{$self->new("match", $match, "mod", $mod)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxModInternal($self)})};
sub node_name{my $self=CORE::shift;(do{"RxModInternal"})};
sub field_names{my $self=CORE::shift;(do{["mod"]})};
sub field_values{my $self=CORE::shift;(do{[$self->mod]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxModInternal\(" . $self->mod->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxCapture;
use base "Any";BEGIN{unshift(@IRx1::RxCapture::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub pattern { if(@_==2){$_[0]{'pattern'}=$_[1]}else{$_[0]{'pattern'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$pattern)=@_;
(do{$self->new("match", $match, "pattern", $pattern)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxCapture($self)})};
sub node_name{my $self=CORE::shift;(do{"RxCapture"})};
sub field_names{my $self=CORE::shift;(do{["pattern"]})};
sub field_values{my $self=CORE::shift;(do{[$self->pattern]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxCapture\(" . $self->pattern->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxGroup;
use base "Any";BEGIN{unshift(@IRx1::RxGroup::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub pattern { if(@_==2){$_[0]{'pattern'}=$_[1]}else{$_[0]{'pattern'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$pattern)=@_;
(do{$self->new("match", $match, "pattern", $pattern)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxGroup($self)})};
sub node_name{my $self=CORE::shift;(do{"RxGroup"})};
sub field_names{my $self=CORE::shift;(do{["pattern"]})};
sub field_values{my $self=CORE::shift;(do{[$self->pattern]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxGroup\(" . $self->pattern->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxBlock;
use base "Any";BEGIN{unshift(@IRx1::RxBlock::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub block { if(@_==2){$_[0]{'block'}=$_[1]}else{$_[0]{'block'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$block)=@_;
(do{$self->new("match", $match, "block", $block)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxBlock($self)})};
sub node_name{my $self=CORE::shift;(do{"RxBlock"})};
sub field_names{my $self=CORE::shift;(do{["block"]})};
sub field_values{my $self=CORE::shift;(do{[$self->block]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxBlock\(" . $self->block->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxBind;
use base "Any";BEGIN{unshift(@IRx1::RxBind::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub var { if(@_==2){$_[0]{'var'}=$_[1]}else{$_[0]{'var'}}};
sub binding { if(@_==2){$_[0]{'binding'}=$_[1]}else{$_[0]{'binding'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$var,$binding)=@_;
(do{$self->new("match", $match, "var", $var, "binding", $binding)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxBind($self)})};
sub node_name{my $self=CORE::shift;(do{"RxBind"})};
sub field_names{my $self=CORE::shift;(do{["var", "binding"]})};
sub field_values{my $self=CORE::shift;(do{[$self->var, $self->binding]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("RxBind\(" . $self->var->irx1_describe()) . "\,") . $self->binding->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxLiteral;
use base "Any";BEGIN{unshift(@IRx1::RxLiteral::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub text { if(@_==2){$_[0]{'text'}=$_[1]}else{$_[0]{'text'}}};
sub quote { if(@_==2){$_[0]{'quote'}=$_[1]}else{$_[0]{'quote'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$text,$quote)=@_;
(do{$self->new("match", $match, "text", $text, "quote", $quote)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxLiteral($self)})};
sub node_name{my $self=CORE::shift;(do{"RxLiteral"})};
sub field_names{my $self=CORE::shift;(do{["text", "quote"]})};
sub field_values{my $self=CORE::shift;(do{[$self->text, $self->quote]})};
sub irx1_describe{my $self=CORE::shift;(do{(((("RxLiteral\(" . $self->text->irx1_describe()) . "\,") . $self->quote->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::RxSymbol;
use base "Any";BEGIN{unshift(@IRx1::RxSymbol::ISA,'IRx1::Base');}
(do{sub match { if(@_==2){$_[0]{'match'}=$_[1]}else{$_[0]{'match'}}};
sub symbol { if(@_==2){$_[0]{'symbol'}=$_[1]}else{$_[0]{'symbol'}}};
sub notes { if(@_==2){$_[0]{'notes'}=$_[1]}else{$_[0]{'notes'}}};
sub newp{my $self=CORE::shift;my($match,$symbol)=@_;
(do{$self->new("match", $match, "symbol", $symbol)})};
sub callback{my $self=CORE::shift;my($emitter)=@_;
(do{$emitter->cb__RxSymbol($self)})};
sub node_name{my $self=CORE::shift;(do{"RxSymbol"})};
sub field_names{my $self=CORE::shift;(do{["symbol"]})};
sub field_values{my $self=CORE::shift;(do{[$self->symbol]})};
sub irx1_describe{my $self=CORE::shift;(do{(("RxSymbol\(" . $self->symbol->irx1_describe()) . "\)")})}})
}
;

{ package IRx1::CompUnit_and_Block;
use base "Any";(do{})
}
;

{ package IRx1::CompUnit;
use base "Any";BEGIN{unshift(@IRx1::CompUnit::ISA,'IRx1::CompUnit_and_Block');}
(do{})
}
;

{ package IRx1::Block;
use base "Any";BEGIN{unshift(@IRx1::Block::ISA,'IRx1::CompUnit_and_Block');}
(do{})
}
})
}
;

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package IRx1_Build;
use base "Any";(do{sub constructors { if(@_==2){$_[0]{'constructors'}=$_[1]}else{$_[0]{'constructors'}}};
sub add_constructor{my $self=CORE::shift;my($k,$constructor)=@_;
(do{if(($self->constructors)->Bool) {
(do{})
}else {
(do{my $h = {};
$self->constructors($h)})
};
$self->constructors->postcircumfix__123_32_125($k, $constructor)})};
sub make_ir_from_Match_tree{my $self=CORE::shift;my($m)=@_;
(do{my $rule = $m->match_rule();
my $constructor = $self->constructors->postcircumfix__123_32_125($rule);
if((($constructor))->Bool) {
(do{$constructor->($m)})
}else {
(do{GLOBAL::die((("Unknown\ rule\:\ " . $rule) . "\
It\ needs\ to\ be\ added\ to\ ast_handlers\.\
"))})
}})}})
}
;

{ package Match;
use base "Any";(do{sub make_ir_from_Match_tree{my $self=CORE::shift;(do{$main::irbuilder->make_ir_from_Match_tree($self)})}})
}
;

{ package Array;
use base "Any";(do{sub make_ir_from_Match_tree{my $self=CORE::shift;(do{$self->map(sub {my($e)=@_;
(do{$e->make_ir_from_Match_tree()})})})}})
}
;

{ package Str;
use base "Any";(do{sub make_ir_from_Match_tree{my $self=CORE::shift;(do{$self})}})
}
;

{ package Int;
use base "Any";(do{sub make_ir_from_Match_tree{my $self=CORE::shift;(do{$self})}})
}
;

{ package Num;
use base "Any";(do{sub make_ir_from_Match_tree{my $self=CORE::shift;(do{$self})}})
}
;

{ package Undef;
use base "Any";(do{sub make_ir_from_Match_tree{my $self=CORE::shift;(do{$self})}})
}
;

{ package IRx1_Build;
use base "Any";(do{sub irbuild_ir{my($x)=@_;
(do{$x->make_ir_from_Match_tree()})};
my $construct_comp_unit = sub {my($m)=@_;
(do{IRx1::CompUnit->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("statementlist")), GLOBAL::undef())})};
my $construct_statement = sub {my($m)=@_;
(do{my $labels = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("label"));
my $result = (do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("expr")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("control")));no warnings "void";$__tmp__}});
if(((do{my $__tmp__=($m->match_hash()->postcircumfix__123_32_125("expr"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(((do{my $__tmp__=($m->match_hash()->postcircumfix__123_32_125("mod_loop"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($m->match_hash()->postcircumfix__123_32_125("mod_cond"));no warnings "void";$__tmp__}})));no warnings "void";$__tmp__}}))->Bool) {
(do{{ package IRx1_Build; use vars '$statement_expr'};local $blackboard::statement_expr = $result;
($result = (do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("mod_loop")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("mod_cond")));no warnings "void";$__tmp__}}));
if(($m->match_hash()->postcircumfix__123_32_125("mod_condloop"))->Bool) {
(do{($blackboard::statement_expr = $result);
($result = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("mod_condloop")))})
}})
};
if(($labels)->Bool) {
(do{IRx1::Label->newp($m, $labels, $result)})
}else {
(do{$result})
}})};
my $construct_expect_infix = sub {my($m)=@_;
(do{if((irbuild_ir($m->match_hash()->postcircumfix__123_32_125("infix")))->Bool) {
(do{if((irbuild_ir($m->match_hash()->postcircumfix__123_32_125("infix_postfix_meta_operator")))->Bool) {
(do{GLOBAL::die("Unimplemented\ infix_postfix_meta_operator")})
};
my $op = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("infix")->match_hash()->postcircumfix__123_32_125("sym"));
if((($op eq "\=\>"))->Bool) {
(do{my $args = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("args"));
if(($args->postcircumfix__91_32_93(2))->Bool) {
(do{GLOBAL::die("chained\ \=\>\ unimplemented")})
};
IRx1::Pair->newp($m, $args->postcircumfix__91_32_93(0), $args->postcircumfix__91_32_93(1))})
}else {
(do{IRx1::Apply->newp($m, ("infix\:" . $op), IRx1::Capture->newp1($m, (do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("args")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})
}})
}else {
(do{GLOBAL::die("Unimplemented\ infix_prefix_meta_operator\ or\ infix_circumfix_meta_operator")})
}})};
my $construct_fatarrow = sub {my($m)=@_;
(do{IRx1::Pair->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("key")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("val")))})};
my $construct_expect_term = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$expect_term_base'};local $blackboard::expect_term_base = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("noun"));
my $ops = [];
if(($m->match_hash()->postcircumfix__123_32_125("pre"))->Bool) {
(do{$ops->push($m->match_hash()->postcircumfix__123_32_125("pre")->flatten())})
};
if(($m->match_hash()->postcircumfix__123_32_125("post"))->Bool) {
(do{$ops->push($m->match_hash()->postcircumfix__123_32_125("post")->flatten())})
};
for(($ops)->flatten){
(do{($blackboard::expect_term_base = irbuild_ir($_))})
};
$blackboard::expect_term_base})};
my $construct_term_58expect_term = sub {my($m)=@_;
(do{irbuild_ir($m->match_hash()->postcircumfix__123_32_125("noun"))})};
my $construct_post = sub {my($m)=@_;
(do{if(($m->match_hash()->postcircumfix__123_32_125("args"))->Bool) {
(do{irbuild_ir($m->match_hash()->postcircumfix__123_32_125("args"))->postcircumfix__91_32_93(0)})
}else {
(do{(do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("dotty")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("postop")));no warnings "void";$__tmp__}})})
}})};
my $construct_pre = sub {my($m)=@_;
(do{if(($m->match_hash()->postcircumfix__123_32_125("args"))->Bool) {
(do{irbuild_ir($m->match_hash()->postcircumfix__123_32_125("args"))->postcircumfix__91_32_93(0)})
}elsif(($m->match_hash()->postcircumfix__123_32_125("prefix"))->Bool) {
(do{irbuild_ir($m->match_hash()->postcircumfix__123_32_125("prefix"))})
}else {
(do{GLOBAL::die("pre\ without\ a\ prefix\ is\ unimplemented")})
}})};
my $construct_dotty_58methodop = sub {my($m)=@_;
(do{IRx1::Call->newp($m, $blackboard::expect_term_base, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), IRx1::Capture->newp1($m, (do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("semilist")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})};
my $construct_dotty_58_46_94_33 = sub {my($m)=@_;
(do{IRx1::Call->newp($m, $blackboard::expect_term_base, ("\^\!" . irbuild_ir($m->match_hash()->postcircumfix__123_32_125("methodop")->match_hash()->postcircumfix__123_32_125("ident"))), IRx1::Capture->newp1($m, (do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("methodop")->match_hash()->postcircumfix__123_32_125("semilist")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})};
my $construct_dotty_58postcircumfix = sub {my($m)=@_;
(do{my $s = ($m->match_string());
my $name = ((GLOBAL::substr($s, 0, 1) . "\ ") . GLOBAL::substr($s, (-1), 1));
my $ident = ("postcircumfix\:" . $name);
my $args = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("kludge_name"));
if(((do{my $__tmp__=($args);if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=((($args->WHAT() ne "Array")));no warnings "void";$__tmp__}}))->Bool) {
(do{($args = [$args])})
};
IRx1::Call->newp($m, $blackboard::expect_term_base, $ident, IRx1::Capture->newp1($m, (do{my $__tmp__=($args);if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})};
my $construct_postcircumfix = sub {my($m)=@_;
(do{my $s = ($m->match_string());
my $name = ((GLOBAL::substr($s, 0, 1) . "\ ") . GLOBAL::substr($s, (-1), 1));
my $ident = ("postcircumfix\:" . $name);
my $args = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("kludge_name"));
if(((do{my $__tmp__=($args);if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=((($args->WHAT() ne "Array")));no warnings "void";$__tmp__}}))->Bool) {
(do{($args = [$args])})
};
IRx1::Call->newp($m, $blackboard::expect_term_base, $ident, IRx1::Capture->newp1($m, (do{my $__tmp__=($args);if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})};
my $construct_postfix = sub {my($m)=@_;
(do{my $op = ($m->match_string());
IRx1::Apply->newp($m, ("postfix\:" . $op), IRx1::Capture->newp1($m, [$blackboard::expect_term_base]))})};
my $construct_prefix = sub {my($m)=@_;
(do{my $op = ($m->match_string());
IRx1::Apply->newp($m, ("prefix\:" . $op), IRx1::Capture->newp1($m, [$blackboard::expect_term_base]))})};
my $construct_infix = sub {my($m)=@_;
(do{my $op = ($m->match_string());
IRx1::Apply->newp($m, ("infix\:" . $op), IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("left")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("right"))]))})};
my $construct_term = sub {my($m)=@_;
(do{my $text = ($m->match_string());
if((($text eq "self"))->Bool) {
(do{IRx1::Apply->newp($m, "self", IRx1::Capture->newp1($m, []))})
}elsif((($text eq "\*"))->Bool) {
(do{IRx1::Apply->newp($m, "whatever", IRx1::Capture->newp1($m, []))})
}else {
(do{GLOBAL::die("AST\ term\ partially\ unimplemented\.\
")})
}})};
my $construct_integer = sub {my($m)=@_;
(do{IRx1::NumInt->newp($m, ($m->match_string()), 10)})};
my $construct_subcall = sub {my($m)=@_;
(do{my $t = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("subshortname")->match_hash()->postcircumfix__123_32_125("twigil"));
if(((do{my $__tmp__=($t);if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($t eq "\."));no warnings "void";$__tmp__}}))->Bool) {
(do{IRx1::Call->newp($m, IRx1::Apply->newp($m, "self", IRx1::Capture->newp1($m, [])), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("subshortname")->match_hash()->postcircumfix__123_32_125("desigilname")->match_hash()->postcircumfix__123_32_125("ident")), IRx1::Capture->newp1($m, (do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("semilist")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})
}else {
(do{IRx1::Apply->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("subshortname")), IRx1::Capture->newp1($m, (do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("semilist")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})
}})};
my $construct_name = sub {my($m)=@_;
(do{($m->match_string())})};
my $construct_subshortname = sub {my($m)=@_;
(do{if(($m->match_hash()->postcircumfix__123_32_125("category"))->Bool) {
(do{my $cat = $m->match_hash()->postcircumfix__123_32_125("category")->match_string();
my $op;
if(($m->match_hash()->postcircumfix__123_32_125("colonpair")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("structural"))->Bool) {
(do{($op = $m->match_hash()->postcircumfix__123_32_125("colonpair")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("structural")->match_hash()->postcircumfix__123_32_125("kludge_name"))})
}else {
(do{($op = $m->match_hash()->postcircumfix__123_32_125("colonpair")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("value")->match_hash()->postcircumfix__123_32_125("postcircumfix")->match_hash()->postcircumfix__123_32_125("kludge_name"))})
};
if((($op->WHAT() eq "Array"))->Bool) {
(do{($op = $op->join(""))})
};
(($cat . "\:") . $op)})
}else {
(do{($m->match_string())})
}})};
my $construct_statement_control_58use = sub {my($m)=@_;
(do{IRx1::Use->newp($m, "use", irbuild_ir($m->match_hash()->postcircumfix__123_32_125("module_name")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("EXPR")))})};
my $construct_module_name_58depreciated = sub {my($m)=@_;
(do{($m->match_string())})};
my $construct_module_name_58normal = sub {my($m)=@_;
(do{($m->match_string())})};
my $construct_role_name = sub {my($m)=@_;
(do{($m->match_string())})};
my $construct_statement_control_58BEGIN = sub {my($m)=@_;
(do{IRx1::ClosureTrait->newp($m, "BEGIN", irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_term_58listop = sub {my($m)=@_;
(do{my $not_really_an_arglist = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("arglist"));
if((irbuild_ir($m->match_hash()->postcircumfix__123_32_125("arglist")))->Bool) {
(do{IRx1::Apply->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), IRx1::Capture->newp1($m, [$not_really_an_arglist]))})
}else {
(do{IRx1::Apply->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), IRx1::Capture->newp1($m, []))})
}})};
my $construct_quote_58q = sub {my($m)=@_;
(do{my $s = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("text"));
($s = $s->re_gsub_pat("\\\\\(\[\\\\\'\]\)", "\$1"));
IRx1::Buf->newp($m, $s)})};
my $construct_quote_58qq = sub {my($m)=@_;
(do{my $s = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("text"));
($s = $s->re_gsub("\(\?\<\!\\\\\)\\\\n", "\
"));
($s = $s->re_gsub("\(\?\<\!\\\\\)\\\\t", "\	"));
($s = $s->re_gsub_pat("\\\\\(\.\)", "\$1"));
IRx1::Buf->newp($m, $s)})};
my $construct_quote_58regex = sub {my($m)=@_;
(do{my $s = (do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("text")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("quotesnabber")->match_hash()->postcircumfix__123_32_125("text")));no warnings "void";$__tmp__}});
IRx1::Rx->newp($m, $s, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("quotepair")))})};
my $construct_scope_declarator_58my = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$scope'};local $blackboard::scope = "my";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("scoped"))})};
my $construct_scope_declarator_58has = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$scope'};local $blackboard::scope = "has";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("scoped"))})};
my $construct_scope_declarator_58our = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$scope'};local $blackboard::scope = "our";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("scoped"))})};
my $construct_scope_declarator_58temp = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$scope'};local $blackboard::scope = "temp";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("scoped"))})};
my $construct_scoped = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$typenames'};local $blackboard::typenames = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("fulltypename"));
(do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("variable_decl")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("signature")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("plurality_declarator")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("routine_declarator")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("type_declarator")));no warnings "void";$__tmp__}}}}})})};
my $construct_variable_decl = sub {my($m)=@_;
(do{my $scope = $blackboard::scope;
{ package IRx1_Build; use vars '$scope'};local $blackboard::scope;
my $typenames = $blackboard::typenames;
{ package IRx1_Build; use vars '$typenames'};local $blackboard::typenames = GLOBAL::undef();
IRx1::VarDecl->newp($m, $scope, $typenames, GLOBAL::undef(), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("variable")), GLOBAL::undef(), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("traits")), "\=", irbuild_ir($m->match_hash()->postcircumfix__123_32_125("default_value")))})};
my $construct_variable = sub {my($m)=@_;
(do{my $tw = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("twigil"));
if(($m->match_hash()->postcircumfix__123_32_125("postcircumfix"))->Bool) {
(do{if((($tw eq "\."))->Bool) {
(do{my $slf = IRx1::Apply->newp($m, "self", IRx1::Capture->newp1($m, []));
my $args = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("postcircumfix")->match_hash()->postcircumfix__123_32_125("kludge_name"));
if(((do{my $__tmp__=($args);if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=((($args->WHAT() ne "Array")));no warnings "void";$__tmp__}}))->Bool) {
(do{($args = [$args])})
};
IRx1::Call->newp($m, $slf, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("desigilname")), IRx1::Capture->newp1($m, (do{my $__tmp__=($args);if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})
}else {
(do{my $v = IRx1::Var->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("sigil")), $tw, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("desigilname")));
{ package IRx1_Build; use vars '$expect_term_base'};local $blackboard::expect_term_base = $v;
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("postcircumfix"))})
}})
}else {
(do{IRx1::Var->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("sigil")), $tw, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("desigilname")))})
}})};
my $construct_sigil = sub {my($m)=@_;
(do{($m->match_string())})};
my $construct_twigil = sub {my($m)=@_;
(do{($m->match_string())})};
my $construct_special_variable = sub {my($m)=@_;
(do{my $v = ($m->match_string());
my $s = GLOBAL::substr($v, 0, 1);
my $n = GLOBAL::substr($v, 1, $v->chars());
IRx1::Var->newp($m, $s, GLOBAL::undef(), $n)})};
my $construct_circumfix = sub {my($m)=@_;
(do{my $s = ($m->match_string());
my $name = ((GLOBAL::substr($s, 0, 1) . "\ ") . GLOBAL::substr($s, (-1), 1));
my $args = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("kludge_name"));
if(((do{my $__tmp__=($args);if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=((($args->WHAT() ne "Array")));no warnings "void";$__tmp__}}))->Bool) {
(do{($args = [$args])})
};
IRx1::Apply->newp($m, ("circumfix\:" . $name), IRx1::Capture->newp1($m, (do{my $__tmp__=($args);if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}})))})};
my $construct_statement_control_58for = sub {my($m)=@_;
(do{IRx1::For->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("expr")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_statement_mod_loop_58for = sub {my($m)=@_;
(do{IRx1::For->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("modifier_expr")), $blackboard::statement_expr)})};
my $construct_statement_control_58while = sub {my($m)=@_;
(do{IRx1::Loop->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("expr")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")), GLOBAL::undef(), GLOBAL::undef())})};
my $construct_statement_mod_loop_58while = sub {my($m)=@_;
(do{IRx1::Loop->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("modifier_expr")), $blackboard::statement_expr, GLOBAL::undef(), GLOBAL::undef())})};
my $construct_statement_control_58until = sub {my($m)=@_;
(do{my $test = IRx1::Apply->newp($m, "not", IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("expr"))]));
IRx1::Loop->newp($m, $test, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")), GLOBAL::undef(), GLOBAL::undef())})};
my $construct_statement_mod_loop_58until = sub {my($m)=@_;
(do{my $test = IRx1::Apply->newp($m, "not", IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("modifier_expr"))]));
IRx1::Loop->newp($m, $test, $blackboard::statement_expr, GLOBAL::undef(), GLOBAL::undef())})};
my $construct_statement_control_58loop = sub {my($m)=@_;
(do{my $e1 = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("loop_eee")->match_hash()->postcircumfix__123_32_125("loop_e1"));
my $e2 = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("loop_eee")->match_hash()->postcircumfix__123_32_125("loop_e2"));
my $e3 = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("loop_eee")->match_hash()->postcircumfix__123_32_125("loop_e3"));
my $block = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("loop_block"));
my $body = IRx1::Loop->newp($m, $e2, IRx1::Block->newp($m, [$block, $e3]), GLOBAL::undef(), GLOBAL::undef());
IRx1::Block->newp($m, [$e1, $body])})};
my $construct_statement_control_58if = sub {my($m)=@_;
(do{my $els = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("else"));
if(($els)->Bool) {
(do{($els = $els->postcircumfix__91_32_93(0))})
};
IRx1::Cond->newp($m, [[irbuild_ir($m->match_hash()->postcircumfix__123_32_125("if_expr")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("if_block"))]]->push(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("elsif"))->flatten()), $els, GLOBAL::undef())})};
my $construct_elsif = sub {my($m)=@_;
(do{[irbuild_ir($m->match_hash()->postcircumfix__123_32_125("elsif_expr")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("elsif_block"))]})};
my $construct_if__else = sub {my($m)=@_;
(do{my $key;
for(($m->match_hash()->keys())->flatten){
(do{if((($_ ne "match"))->Bool) {
(do{if(($key)->Bool) {
(do{GLOBAL::die("Unexpectedly\ more\ than\ 1\ field\ \-\ dont\ know\ which\ to\ choose\
")})
};
($key = $_)})
}})
};
my $one = irbuild_ir($m->match_hash()->postcircumfix__123_32_125($key));
$one})};
my $construct_statement_mod_cond_58if = sub {my($m)=@_;
(do{IRx1::Cond->newp($m, [[irbuild_ir($m->match_hash()->postcircumfix__123_32_125("modifier_expr")), $blackboard::statement_expr]], GLOBAL::undef(), GLOBAL::undef())})};
my $construct_statement_control_58unless = sub {my($m)=@_;
(do{IRx1::Cond->newp($m, [[irbuild_ir($m->match_hash()->postcircumfix__123_32_125("expr")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block"))]], GLOBAL::undef(), 1)})};
my $construct_statement_mod_cond_58unless = sub {my($m)=@_;
(do{IRx1::Cond->newp($m, [[irbuild_ir($m->match_hash()->postcircumfix__123_32_125("modifier_expr")), $blackboard::statement_expr]], GLOBAL::undef(), 1)})};
my $construct_statement_control_58given = sub {my($m)=@_;
(do{IRx1::Given->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("expr")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_statement_mod_loop_58given = sub {my($m)=@_;
(do{IRx1::Given->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("modifier_expr")), $blackboard::statement_expr)})};
my $construct_statement_control_58when = sub {my($m)=@_;
(do{IRx1::When->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("expr")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_statement_mod_cond_58when = sub {my($m)=@_;
(do{IRx1::When->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("modifier_expr")), $blackboard::statement_expr)})};
my $construct_statement_control_58default = sub {my($m)=@_;
(do{IRx1::When->newp($m, GLOBAL::undef(), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_statement_prefix_58do = sub {my($m)=@_;
(do{IRx1::Apply->newp($m, "statement_prefix\:do", IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("statement"))]))})};
my $construct_statement_prefix_58try = sub {my($m)=@_;
(do{IRx1::Apply->newp($m, "statement_prefix\:try", IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("statement"))]))})};
my $construct_statement_prefix_58gather = sub {my($m)=@_;
(do{IRx1::Apply->newp($m, "statement_prefix\:gather", IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("statement"))]))})};
my $construct_statement_prefix_58contend = sub {my($m)=@_;
(do{IRx1::Apply->newp($m, "statement_prefix\:contend", IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("statement"))]))})};
my $construct_statement_prefix_58async = sub {my($m)=@_;
(do{IRx1::Apply->newp($m, "statement_prefix\:async", IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("statement"))]))})};
my $construct_statement_prefix_58lazy = sub {my($m)=@_;
(do{IRx1::Apply->newp($m, "statement_prefix\:lazy", IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("statement"))]))})};
my $construct_pblock = sub {my($m)=@_;
(do{if(($m->match_hash()->postcircumfix__123_32_125("signature"))->Bool) {
(do{IRx1::SubDecl->newp($m, GLOBAL::undef(), GLOBAL::undef(), GLOBAL::undef(), GLOBAL::undef(), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("signature")), GLOBAL::undef(), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})
}else {
(do{irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block"))})
}})};
my $construct_block = sub {my($m)=@_;
(do{IRx1::Block->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("statementlist")))})};
my $construct_plurality_declarator_58multi = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$plurality'};local $blackboard::plurality = "multi";
(do{my $__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("pluralized")));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("routine_def")));no warnings "void";$__tmp__}})})};
my $construct_routine_declarator_58routine_def = sub {my($m)=@_;
(do{my $scope = $blackboard::scope;
{ package IRx1_Build; use vars '$scope'};local $blackboard::scope;
my $plurality = $blackboard::plurality;
{ package IRx1_Build; use vars '$plurality'};local $blackboard::plurality;
my $ident = "";
if(($m->match_hash()->postcircumfix__123_32_125("ident"))->Bool) {
(do{($ident = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")))})
};
if((((do{my $__tmp__=($m->match_hash()->postcircumfix__123_32_125("ident"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(GLOBAL::not($scope));no warnings "void";$__tmp__}})))->Bool) {
(do{($scope = "our")})
};
my $sig = IRx1::Signature->newp($m, [], GLOBAL::undef());
if((irbuild_ir($m->match_hash()->postcircumfix__123_32_125("multisig")))->Bool) {
(do{($sig = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("multisig"))->postcircumfix__91_32_93(0))})
};
IRx1::SubDecl->newp($m, $scope, GLOBAL::undef(), $plurality, $ident, $sig, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("trait")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_routine_def = sub {my($m)=@_;
(do{my $scope = $blackboard::scope;
{ package IRx1_Build; use vars '$scope'};local $blackboard::scope;
my $plurality = $blackboard::plurality;
{ package IRx1_Build; use vars '$plurality'};local $blackboard::plurality;
my $ident = "";
if(($m->match_hash()->postcircumfix__123_32_125("ident"))->Bool) {
(do{($ident = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")))})
};
if((((do{my $__tmp__=($m->match_hash()->postcircumfix__123_32_125("ident"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(GLOBAL::not($scope));no warnings "void";$__tmp__}})))->Bool) {
(do{($scope = "our")})
};
my $sig = IRx1::Signature->newp($m, [], GLOBAL::undef());
if((irbuild_ir($m->match_hash()->postcircumfix__123_32_125("multisig")))->Bool) {
(do{($sig = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("multisig"))->postcircumfix__91_32_93(0))})
};
IRx1::SubDecl->newp($m, $scope, GLOBAL::undef(), $plurality, $ident, $sig, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("trait")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_routine_declarator_58method_def = sub {my($m)=@_;
(do{my $plurality = $blackboard::plurality;
{ package IRx1_Build; use vars '$plurality'};local $blackboard::plurality;
my $multisig = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("multisig"));
if((GLOBAL::not($multisig))->Bool) {
(do{($multisig = [IRx1::Signature->newp($m, [], GLOBAL::undef())])})
};
IRx1::MethodDecl->newp($m, GLOBAL::undef(), GLOBAL::undef(), $plurality, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), $multisig->postcircumfix__91_32_93(0), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("trait")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")), GLOBAL::undef(), GLOBAL::undef())})};
my $construct_signature = sub {my($m)=@_;
(do{IRx1::Signature->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("parsep")), GLOBAL::undef())})};
my $construct_parameter = sub {my($m)=@_;
(do{IRx1::Parameter->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("type_constraint")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("quantchar")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("param_var")), GLOBAL::undef(), GLOBAL::undef(), GLOBAL::undef(), GLOBAL::undef())})};
my $construct_param_var = sub {my($m)=@_;
(do{IRx1::ParamVar->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("sigil")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("twigil")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")))})};
my $construct_capture = sub {my($m)=@_;
(do{if((GLOBAL::not($m->match_hash()->postcircumfix__123_32_125("EXPR")))->Bool) {
(do{IRx1::Capture->newp1($m, [])})
}elsif(($m->match_hash()->postcircumfix__123_32_125("EXPR")->match_hash()->postcircumfix__123_32_125("noun"))->Bool) {
(do{IRx1::Capture->newp1($m, [irbuild_ir($m->match_hash()->postcircumfix__123_32_125("EXPR")->match_hash()->postcircumfix__123_32_125("noun"))])})
}elsif(((do{my $__tmp__=($m->match_hash()->postcircumfix__123_32_125("EXPR")->match_hash()->postcircumfix__123_32_125("sym"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($m->match_hash()->postcircumfix__123_32_125("EXPR")->match_hash()->postcircumfix__123_32_125("sym") eq "\:"));no warnings "void";$__tmp__}}))->Bool) {
(do{my $args = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("EXPR")->match_hash()->postcircumfix__123_32_125("args"));
my $inv = $args->shift();
IRx1::Capture->newp($m, (do{my $__tmp__=($args);if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}}), $inv)})
}elsif(((do{my $__tmp__=($m->match_hash()->postcircumfix__123_32_125("EXPR")->match_hash()->postcircumfix__123_32_125("sym"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($m->match_hash()->postcircumfix__123_32_125("EXPR")->match_hash()->postcircumfix__123_32_125("sym") eq "\,"));no warnings "void";$__tmp__}}))->Bool) {
(do{my $args = $m->match_hash()->postcircumfix__123_32_125("EXPR")->match_hash()->postcircumfix__123_32_125("args");
my $arg0 = (do{my $__tmp__=($args);if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($args->postcircumfix__91_32_93(0));no warnings "void";$__tmp__}});
my $inv = GLOBAL::undef();
if(((do{my $__tmp__=($arg0);if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($arg0->match_hash()->postcircumfix__123_32_125("sym"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($arg0->match_hash()->postcircumfix__123_32_125("sym") eq "\:"));no warnings "void";$__tmp__}}}))->Bool) {
(do{$args->shift();
($inv = $arg0->match_hash()->postcircumfix__123_32_125("args")->postcircumfix__91_32_93(0));
if(($arg0->match_hash()->postcircumfix__123_32_125("args")->postcircumfix__91_32_93(1))->Bool) {
(do{$args->unshift($arg0->match_hash()->postcircumfix__123_32_125("args")->postcircumfix__91_32_93(1))})
}})
};
IRx1::Capture->newp($m, (do{my $__tmp__=(irbuild_ir($args));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}}), irbuild_ir($inv))})
}else {
(do{GLOBAL::die("capture\ AST\ form\ not\ recognized")})
}})};
my $construct_colonpair = sub {my($m)=@_;
(do{my $key;
for(($m->match_hash()->keys())->flatten){
(do{if((($_ ne "match"))->Bool) {
(do{if(($key)->Bool) {
(do{GLOBAL::die("Unexpectedly\ more\ than\ 1\ field\ \-\ dont\ know\ which\ to\ choose\
")})
};
($key = $_)})
}})
};
my $one = irbuild_ir($m->match_hash()->postcircumfix__123_32_125($key));
$one})};
my $construct_colonpair__false = sub {my($m)=@_;
(do{IRx1::Pair->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), IRx1::NumInt->newp($m, 0))})};
my $construct_colonpair__value = sub {my($m)=@_;
(do{my $value;
if(($m->match_hash()->postcircumfix__123_32_125("postcircumfix"))->Bool) {
(do{($value = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("postcircumfix")->match_hash()->postcircumfix__123_32_125("kludge_name")))})
}else {
(do{($value = IRx1::NumInt->newp($m, 1))})
};
IRx1::Pair->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), $value)})};
my $construct_quotepair = sub {my($m)=@_;
(do{my $key;
for(($m->match_hash()->keys())->flatten){
(do{if((($_ ne "match"))->Bool) {
(do{if(($key)->Bool) {
(do{GLOBAL::die("Unexpectedly\ more\ than\ 1\ field\ \-\ dont\ know\ which\ to\ choose\
")})
};
($key = $_)})
}})
};
my $one = irbuild_ir($m->match_hash()->postcircumfix__123_32_125($key));
$one})};
my $construct_quotepair__false = sub {my($m)=@_;
(do{IRx1::Pair->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), IRx1::NumInt->newp($m, 0))})};
my $construct_quotepair__value = sub {my($m)=@_;
(do{my $value;
if(($m->match_hash()->postcircumfix__123_32_125("postcircumfix"))->Bool) {
(do{($value = irbuild_ir($m->match_hash()->postcircumfix__123_32_125("postcircumfix")->match_hash()->postcircumfix__123_32_125("kludge_name")))})
}else {
(do{($value = IRx1::NumInt->newp($m, 1))})
};
IRx1::Pair->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), $value)})};
my $construct_quotepair__nth = sub {my($m)=@_;
(do{IRx1::Pair->newp($m, "nth", irbuild_ir($m->match_hash()->postcircumfix__123_32_125("n")))})};
my $construct_package_declarator_58role = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$package_declarator'};local $blackboard::package_declarator = "role";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("package_def"))})};
my $construct_package_declarator_58class = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$package_declarator'};local $blackboard::package_declarator = "class";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("package_def"))})};
my $construct_package_declarator_58module = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$package_declarator'};local $blackboard::package_declarator = "module";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("package_def"))})};
my $construct_package_declarator_58package = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$package_declarator'};local $blackboard::package_declarator = "package";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("package_def"))})};
my $construct_package_declarator_58grammar = sub {my($m)=@_;
(do{{ package IRx1_Build; use vars '$package_declarator'};local $blackboard::package_declarator = "grammar";
irbuild_ir($m->match_hash()->postcircumfix__123_32_125("package_def"))})};
my $construct_package_def = sub {my($m)=@_;
(do{IRx1::PackageDecl->newp($m, GLOBAL::undef(), GLOBAL::undef(), $blackboard::package_declarator, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("module_name"))->postcircumfix__91_32_93(0), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("traits")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_fulltypename = sub {my($m)=@_;
(do{irbuild_ir($m->match_hash()->postcircumfix__123_32_125("typename"))->join("\:\:")})};
my $construct_typename = sub {my($m)=@_;
(do{($m->match_string())})};
my $construct_trait_verb_58is = sub {my($m)=@_;
(do{IRx1::Trait->newp($m, "is", irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")))})};
my $construct_trait_verb_58does = sub {my($m)=@_;
(do{IRx1::Trait->newp($m, "does", irbuild_ir($m->match_hash()->postcircumfix__123_32_125("role_name")))})};
my $construct_circumfix_58pblock = sub {my($m)=@_;
(do{if(((do{my $__tmp__=(($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")->elems() == 0));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")->postcircumfix__91_32_93(0)->match_string()->re_matchp("\^\:"));no warnings "void";$__tmp__}}))->Bool) {
(do{IRx1::Hash->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")))})
}elsif(((do{my $__tmp__=($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("expr"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("expr")->match_hash()->postcircumfix__123_32_125("sym"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("expr")->match_hash()->postcircumfix__123_32_125("sym") eq "\,"));no warnings "void";$__tmp__}}}))->Bool) {
(do{IRx1::Hash->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")))})
}elsif(((do{my $__tmp__=($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("expr"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("expr")->match_hash()->postcircumfix__123_32_125("sym"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")->postcircumfix__91_32_93(0)->match_hash()->postcircumfix__123_32_125("expr")->match_hash()->postcircumfix__123_32_125("sym") eq "\=\>"));no warnings "void";$__tmp__}}}))->Bool) {
(do{IRx1::Hash->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")->match_hash()->postcircumfix__123_32_125("statementlist")))})
}elsif(((do{my $__tmp__=(GLOBAL::not(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("lambda"))));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(GLOBAL::not(irbuild_ir($m->match_hash()->postcircumfix__123_32_125("signature"))));no warnings "void";$__tmp__}}))->Bool) {
(do{irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block"))})
}else {
(do{GLOBAL::die("AST\ handler\ circumfix\:pblock\ partially\ unimplemented")})
}})};
my $construct_regex_declarator_58regex_def = sub {my($m)=@_;
(do{IRx1::RegexDef->newp($m, "regex", irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")), GLOBAL::undef(), GLOBAL::undef(), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("regex_block")))})};
my $construct_regex_block = sub {my($m)=@_;
(do{irbuild_ir($m->match_hash()->postcircumfix__123_32_125("regex"))})};
my $construct_regex = sub {my($m)=@_;
(do{IRx1::Regex->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("pattern")))})};
my $construct_regex_first = sub {my($m)=@_;
(do{IRx1::RxFirst->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("patterns")))})};
my $construct_regex_every = sub {my($m)=@_;
(do{IRx1::RxEvery->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("patterns")))})};
my $construct_regex_submatch = sub {my($m)=@_;
(do{IRx1::RxSubmatch->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("patterns")))})};
my $construct_regex_any = sub {my($m)=@_;
(do{IRx1::RxAny->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("patterns")))})};
my $construct_regex_all = sub {my($m)=@_;
(do{IRx1::RxAll->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("patterns")))})};
my $construct_regex_sequence = sub {my($m)=@_;
(do{IRx1::RxSequence->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("patterns")))})};
my $construct_regex_quantified_atom = sub {my($m)=@_;
(do{IRx1::RxQuantifiedAtom->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("regex_atom")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("regex_quantifier")))})};
my $construct_regex_quantifier = sub {my($m)=@_;
(do{($m->match_string())})};
my $construct_regex_atom = sub {my($m)=@_;
(do{my $key;
for(($m->match_hash()->keys())->flatten){
(do{if((($_ ne "match"))->Bool) {
(do{if(($key)->Bool) {
(do{GLOBAL::die("Unexpectedly\ more\ than\ 1\ field\ \-\ dont\ know\ which\ to\ choose\
")})
};
($key = $_)})
}})
};
my $one = irbuild_ir($m->match_hash()->postcircumfix__123_32_125($key));
if((irbuild_ir($m->match_hash()->postcircumfix__123_32_125("char")))->Bool) {
(do{IRx1::RxLiteral->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("char")), "\'")})
}else {
(do{$one})
}})};
my $construct_regex_metachar_58regex_backslash = sub {my($m)=@_;
(do{IRx1::RxBackslash->newp($m, ($m->match_string()))})};
my $construct_regex_metachar_58regex_mod_internal = sub {my($m)=@_;
(do{IRx1::RxModInternal->newp($m, ($m->match_string()))})};
my $construct_regex_assertion_58ident = sub {my($m)=@_;
(do{IRx1::RxAssertion->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("ident")))})};
my $construct_regex_metachar_58capture = sub {my($m)=@_;
(do{IRx1::RxCapture->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("regex")->match_hash()->postcircumfix__123_32_125("pattern")))})};
my $construct_regex_metachar_58group = sub {my($m)=@_;
(do{IRx1::RxGroup->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("regex")->match_hash()->postcircumfix__123_32_125("pattern")))})};
my $construct_regex_metachar_58block = sub {my($m)=@_;
(do{IRx1::RxBlock->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("block")))})};
my $construct_regex_metachar_58var = sub {my($m)=@_;
(do{IRx1::RxBind->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("variable")), irbuild_ir($m->match_hash()->postcircumfix__123_32_125("binding")))})};
my $construct_regex_metachar_58q = sub {my($m)=@_;
(do{IRx1::RxLiteral->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("text")), "\'")})};
my $construct_regex_metachar_58qq = sub {my($m)=@_;
(do{IRx1::RxLiteral->newp($m, irbuild_ir($m->match_hash()->postcircumfix__123_32_125("text")), "\"")})};
my $construct_regex_metachar = sub {my($m)=@_;
(do{IRx1::RxSymbol->newp($m, ($m->match_string()))})};
sub init{my $self=CORE::shift;(do{$self->add_constructor("comp_unit", $construct_comp_unit);
$self->add_constructor("statement", $construct_statement);
$self->add_constructor("expect_infix", $construct_expect_infix);
$self->add_constructor("fatarrow", $construct_fatarrow);
$self->add_constructor("expect_term", $construct_expect_term);
$self->add_constructor("term\:expect_term", $construct_term_58expect_term);
$self->add_constructor("post", $construct_post);
$self->add_constructor("pre", $construct_pre);
$self->add_constructor("dotty\:methodop", $construct_dotty_58methodop);
$self->add_constructor("dotty\:\.\^\!", $construct_dotty_58_46_94_33);
$self->add_constructor("dotty\:postcircumfix", $construct_dotty_58postcircumfix);
$self->add_constructor("postcircumfix", $construct_postcircumfix);
$self->add_constructor("postfix", $construct_postfix);
$self->add_constructor("prefix", $construct_prefix);
$self->add_constructor("infix", $construct_infix);
$self->add_constructor("term", $construct_term);
$self->add_constructor("integer", $construct_integer);
$self->add_constructor("subcall", $construct_subcall);
$self->add_constructor("name", $construct_name);
$self->add_constructor("subshortname", $construct_subshortname);
$self->add_constructor("statement_control\:use", $construct_statement_control_58use);
$self->add_constructor("module_name\:depreciated", $construct_module_name_58depreciated);
$self->add_constructor("module_name\:normal", $construct_module_name_58normal);
$self->add_constructor("role_name", $construct_role_name);
$self->add_constructor("statement_control\:BEGIN", $construct_statement_control_58BEGIN);
$self->add_constructor("term\:listop", $construct_term_58listop);
$self->add_constructor("quote\:q", $construct_quote_58q);
$self->add_constructor("quote\:qq", $construct_quote_58qq);
$self->add_constructor("quote\:regex", $construct_quote_58regex);
$self->add_constructor("scope_declarator\:my", $construct_scope_declarator_58my);
$self->add_constructor("scope_declarator\:has", $construct_scope_declarator_58has);
$self->add_constructor("scope_declarator\:our", $construct_scope_declarator_58our);
$self->add_constructor("scope_declarator\:temp", $construct_scope_declarator_58temp);
$self->add_constructor("scoped", $construct_scoped);
$self->add_constructor("variable_decl", $construct_variable_decl);
$self->add_constructor("variable", $construct_variable);
$self->add_constructor("sigil", $construct_sigil);
$self->add_constructor("twigil", $construct_twigil);
$self->add_constructor("special_variable", $construct_special_variable);
$self->add_constructor("circumfix", $construct_circumfix);
$self->add_constructor("statement_control\:for", $construct_statement_control_58for);
$self->add_constructor("statement_mod_loop\:for", $construct_statement_mod_loop_58for);
$self->add_constructor("statement_control\:while", $construct_statement_control_58while);
$self->add_constructor("statement_mod_loop\:while", $construct_statement_mod_loop_58while);
$self->add_constructor("statement_control\:until", $construct_statement_control_58until);
$self->add_constructor("statement_mod_loop\:until", $construct_statement_mod_loop_58until);
$self->add_constructor("statement_control\:loop", $construct_statement_control_58loop);
$self->add_constructor("statement_control\:if", $construct_statement_control_58if);
$self->add_constructor("elsif", $construct_elsif);
$self->add_constructor("if__else", $construct_if__else);
$self->add_constructor("statement_mod_cond\:if", $construct_statement_mod_cond_58if);
$self->add_constructor("statement_control\:unless", $construct_statement_control_58unless);
$self->add_constructor("statement_mod_cond\:unless", $construct_statement_mod_cond_58unless);
$self->add_constructor("statement_control\:given", $construct_statement_control_58given);
$self->add_constructor("statement_mod_loop\:given", $construct_statement_mod_loop_58given);
$self->add_constructor("statement_control\:when", $construct_statement_control_58when);
$self->add_constructor("statement_mod_cond\:when", $construct_statement_mod_cond_58when);
$self->add_constructor("statement_control\:default", $construct_statement_control_58default);
$self->add_constructor("statement_prefix\:do", $construct_statement_prefix_58do);
$self->add_constructor("statement_prefix\:try", $construct_statement_prefix_58try);
$self->add_constructor("statement_prefix\:gather", $construct_statement_prefix_58gather);
$self->add_constructor("statement_prefix\:contend", $construct_statement_prefix_58contend);
$self->add_constructor("statement_prefix\:async", $construct_statement_prefix_58async);
$self->add_constructor("statement_prefix\:lazy", $construct_statement_prefix_58lazy);
$self->add_constructor("pblock", $construct_pblock);
$self->add_constructor("block", $construct_block);
$self->add_constructor("plurality_declarator\:multi", $construct_plurality_declarator_58multi);
$self->add_constructor("routine_declarator\:routine_def", $construct_routine_declarator_58routine_def);
$self->add_constructor("routine_def", $construct_routine_def);
$self->add_constructor("routine_declarator\:method_def", $construct_routine_declarator_58method_def);
$self->add_constructor("signature", $construct_signature);
$self->add_constructor("parameter", $construct_parameter);
$self->add_constructor("param_var", $construct_param_var);
$self->add_constructor("capture", $construct_capture);
$self->add_constructor("colonpair", $construct_colonpair);
$self->add_constructor("colonpair__false", $construct_colonpair__false);
$self->add_constructor("colonpair__value", $construct_colonpair__value);
$self->add_constructor("quotepair", $construct_quotepair);
$self->add_constructor("quotepair__false", $construct_quotepair__false);
$self->add_constructor("quotepair__value", $construct_quotepair__value);
$self->add_constructor("quotepair__nth", $construct_quotepair__nth);
$self->add_constructor("package_declarator\:role", $construct_package_declarator_58role);
$self->add_constructor("package_declarator\:class", $construct_package_declarator_58class);
$self->add_constructor("package_declarator\:module", $construct_package_declarator_58module);
$self->add_constructor("package_declarator\:package", $construct_package_declarator_58package);
$self->add_constructor("package_declarator\:grammar", $construct_package_declarator_58grammar);
$self->add_constructor("package_def", $construct_package_def);
$self->add_constructor("fulltypename", $construct_fulltypename);
$self->add_constructor("typename", $construct_typename);
$self->add_constructor("trait_verb\:is", $construct_trait_verb_58is);
$self->add_constructor("trait_verb\:does", $construct_trait_verb_58does);
$self->add_constructor("circumfix\:pblock", $construct_circumfix_58pblock);
$self->add_constructor("regex_declarator\:regex_def", $construct_regex_declarator_58regex_def);
$self->add_constructor("regex_block", $construct_regex_block);
$self->add_constructor("regex", $construct_regex);
$self->add_constructor("regex_first", $construct_regex_first);
$self->add_constructor("regex_every", $construct_regex_every);
$self->add_constructor("regex_submatch", $construct_regex_submatch);
$self->add_constructor("regex_any", $construct_regex_any);
$self->add_constructor("regex_all", $construct_regex_all);
$self->add_constructor("regex_sequence", $construct_regex_sequence);
$self->add_constructor("regex_quantified_atom", $construct_regex_quantified_atom);
$self->add_constructor("regex_quantifier", $construct_regex_quantifier);
$self->add_constructor("regex_atom", $construct_regex_atom);
$self->add_constructor("regex_metachar\:regex_backslash", $construct_regex_metachar_58regex_backslash);
$self->add_constructor("regex_metachar\:regex_mod_internal", $construct_regex_metachar_58regex_mod_internal);
$self->add_constructor("regex_assertion\:ident", $construct_regex_assertion_58ident);
$self->add_constructor("regex_metachar\:capture", $construct_regex_metachar_58capture);
$self->add_constructor("regex_metachar\:group", $construct_regex_metachar_58group);
$self->add_constructor("regex_metachar\:block", $construct_regex_metachar_58block);
$self->add_constructor("regex_metachar\:var", $construct_regex_metachar_58var);
$self->add_constructor("regex_metachar\:q", $construct_regex_metachar_58q);
$self->add_constructor("regex_metachar\:qq", $construct_regex_metachar_58qq);
$self->add_constructor("regex_metachar", $construct_regex_metachar);
$self})}})
}
;
if((GLOBAL::not($GLOBAL::ast2ir_0))->Bool) {
(do{($GLOBAL::ast2ir_0 = IRx1_Build->new()->init())})
};
($GLOBAL::ast2ir_1 = IRx1_Build->new()->init());

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package IRx1::CompUnit;
use base "Any";(do{sub do_all_analysis{my $self=CORE::shift;(do{$self->initialize_notes;
$self->note_parents;
$self->note_block_lexical_variable_decls;
$self->note_environment})}})
}
;

{ package IRx1::Base;
use base "Any";(do{sub is_IR_node{my $self=CORE::shift;(do{1})};
sub initialize_notes{my $self=CORE::shift;(do{$self->notes({});
my $a = [];
for(($self->field_values)->flatten){
(do{if(($_->can("is_IR_node"))->Bool) {
(do{$a->push($_)})
}elsif((($_->WHAT() eq "Array"))->Bool) {
(do{for(($_)->flatten){
(do{if(($_->can("is_IR_node"))->Bool) {
(do{$a->push($_)})
}elsif((($_->WHAT() eq "Array"))->Bool) {
(do{for(($_)->flatten){
(do{if(($_->can("is_IR_node"))->Bool) {
(do{$a->push($_)})
}})
}})
}})
}})
}})
};
$self->notes->postcircumfix__60_32_62('child_nodes', $a);
for(($self->child_nodes)->flatten){
(do{$_->initialize_notes()})
}})};
sub destroy_notes{my $self=CORE::shift;(do{for(($self->notes->postcircumfix__60_32_62('child_nodes'))->flatten){
(do{$_->destroy_notes()})
};
$self->notes(GLOBAL::undef())})};
sub child_nodes{my $self=CORE::shift;(do{$self->notes->postcircumfix__60_32_62('child_nodes')})}})
}
;

{ package IRx1::CompUnit;
use base "Any";(do{sub note_parents{my $self=CORE::shift;(do{{ package IRx1::CompUnit; use vars '$parent'};local $whiteboard::parent = $self;
for(($self->child_nodes)->flatten){
(do{$_->note_parents()})
}})}})
}
;

{ package IRx1::Base;
use base "Any";(do{sub note_parents{my $self=CORE::shift;(do{$self->notes->postcircumfix__60_32_62('parent', $whiteboard::parent);
{ package IRx1::Base; use vars '$parent'};local $whiteboard::parent = $self;
for(($self->child_nodes)->flatten){
(do{$_->note_parents()})
}})}})
}
;

{ package IRx1::CompUnit_and_Block;
use base "Any";(do{sub note_block_lexical_variable_decls{my $self=CORE::shift;(do{my $a = [];
{ package IRx1::CompUnit_and_Block; use vars '$lexical_variable_decls'};local $whiteboard::lexical_variable_decls = $a;
$self->notes->postcircumfix__60_32_62('lexical_variable_decls', $a);
for(($self->child_nodes)->flatten){
(do{$_->note_block_lexical_variable_decls()})
}})}})
}
;

{ package IRx1::VarDecl;
use base "Any";(do{sub note_block_lexical_variable_decls{my $self=CORE::shift;(do{if(($self->is_lexical)->Bool) {
(do{$whiteboard::lexical_variable_decls->push($self)})
};
$self->notes->postcircumfix__60_32_62('is', {});
my $traits = (do{my $__tmp__=($self->traits);if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}});
for(($traits)->flatten){
(do{if((($_->verb() eq "is"))->Bool) {
(do{$self->notes->postcircumfix__60_32_62('is')->postcircumfix__123_32_125($_->expr(), 1)})
}})
};
if(((((do{my $__tmp__=($self->var()->twigil());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=("");no warnings "void";$__tmp__}})) eq "\+"))->Bool) {
(do{$self->notes->postcircumfix__60_32_62('is')->postcircumfix__60_32_62('context', 1)})
};
if((($self->scope() eq "temp"))->Bool) {
(do{$self->notes->postcircumfix__60_32_62('is')->postcircumfix__60_32_62('temp', 1)})
};
for(($self->child_nodes)->flatten){
(do{$_->note_block_lexical_variable_decls()})
}})}})
}
;

{ package IRx1::SubDecl;
use base "Any";(do{sub note_block_lexical_variable_decls{my $self=CORE::shift;(do{if(($self->name)->Bool) {
(do{$whiteboard::lexical_variable_decls->push($self)})
};
for(($self->child_nodes)->flatten){
(do{$_->note_block_lexical_variable_decls()})
}})}})
}
;

{ package IRx1::Base;
use base "Any";(do{sub note_block_lexical_variable_decls{my $self=CORE::shift;(do{for(($self->child_nodes)->flatten){
(do{$_->note_block_lexical_variable_decls()})
}})}})
}
;

{ package IRx1::CompUnit;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{{ package IRx1::CompUnit; use vars '$package_chain'};local $whiteboard::package_chain = [];
{ package IRx1::CompUnit; use vars '$lexical_bindings'};local $whiteboard::lexical_bindings = $self->update_lexical_bindings({}, $self->notes->postcircumfix__60_32_62('lexical_variable_decls'));
for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})}})
}
;

{ package IRx1::Block;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{{ package IRx1::Block; use vars '$lexical_bindings'};local $whiteboard::lexical_bindings = $self->update_lexical_bindings($whiteboard::lexical_bindings, $self->notes->postcircumfix__60_32_62('lexical_variable_decls'));
for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})}})
}
;

{ package IRx1::CompUnit_and_Block;
use base "Any";(do{sub update_lexical_bindings{my $self=CORE::shift;my($h,$decls)=@_;
(do{my $h1 = $h->dup();
for(($decls)->flatten){
(do{my $k = ($_->sigil() . $_->name());
$h1->postcircumfix__123_32_125($k, $_)})
};
$h1})}})
}
;

{ package IRx1::PackageDecl;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{my $new_chain;
if(($self->path_is_absolute)->Bool) {
(do{($new_chain = [$self])})
}else {
(do{($new_chain = [$whiteboard::package_chain->flatten(), $self])})
};
if((GLOBAL::not(GLOBAL::defined($self->block)))->Bool) {
(do{($whiteboard::package_chain = $new_chain)})
}else {
(do{{ package IRx1::PackageDecl; use vars '$package_chain'};local $whiteboard::package_chain = $new_chain;
for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})
}})}})
}
;

{ package IRx1::SubDecl;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{$self->record_crnt_package;
for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})}})
}
;

{ package IRx1::MethodDecl;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{$self->record_crnt_package;
for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})}})
}
;

{ package IRx1::VarDecl;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{$self->record_crnt_package;
for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})}})
}
;

{ package IRx1::Apply;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{$self->notes->postcircumfix__60_32_62('lexical_bindings', $whiteboard::lexical_bindings);
for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})}})
}
;

{ package IRx1::Var;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{my $key = ($self->sigil() . $self->name());
$self->notes->postcircumfix__60_32_62('decl', $whiteboard::lexical_bindings->postcircumfix__123_32_125($key));
if(($self->notes->postcircumfix__60_32_62('decl'))->Bool) {
(do{$self->notes->postcircumfix__60_32_62('is', $self->notes->postcircumfix__60_32_62('decl')->notes()->postcircumfix__60_32_62('is'))})
}else {
(do{$self->notes->postcircumfix__60_32_62('is', {})})
};
$self->record_crnt_package;
my $g = $self->name->re_groups("\(\?\:\(\.\+\)\:\:\)\?\(\[\^\:\]\+\)\$");
$self->notes->postcircumfix__60_32_62('package', $g->postcircumfix__91_32_93(0));
$self->notes->postcircumfix__60_32_62('bare_name', $g->postcircumfix__91_32_93(1));
for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})}})
}
;

{ package IRx1::Base;
use base "Any";(do{sub record_crnt_package{my $self=CORE::shift;(do{$self->notes->postcircumfix__60_32_62('crnt_package_chain', $whiteboard::package_chain);
$self->notes->postcircumfix__60_32_62('crnt_package', $self->notes->postcircumfix__60_32_62('crnt_package_chain')->map(sub {my($n)=@_;
(do{$n->name()})})->join("\:\:"));
if((($self->notes->postcircumfix__60_32_62('crnt_package_chain')->elems() == 0))->Bool) {
(do{$self->notes->postcircumfix__60_32_62('crnt_package', "Main")})
}})}})
}
;

{ package IRx1::Base;
use base "Any";(do{sub note_environment{my $self=CORE::shift;(do{for(($self->child_nodes)->flatten){
(do{$_->note_environment()})
}})}})
}
;

{ package IRx1::VarDecl;
use base "Any";(do{sub is_lexical{my $self=CORE::shift;(do{(do{my $__tmp__=(($self->scope eq "my"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(GLOBAL::not($self->var->package()));no warnings "void";$__tmp__}})})};
sub is_context{my $self=CORE::shift;(do{$self->notes->postcircumfix__60_32_62('is')->postcircumfix__60_32_62('context')})};
sub is_temp{my $self=CORE::shift;(do{$self->notes->postcircumfix__60_32_62('is')->postcircumfix__60_32_62('temp')})};
sub name{my $self=CORE::shift;(do{$self->var()->name()})};
sub bare_name{my $self=CORE::shift;(do{$self->var()->bare_name()})};
sub package{my $self=CORE::shift;(do{$self->var()->package()})};
sub crnt_package{my $self=CORE::shift;(do{$self->var()->crnt_package()})};
sub sigil{my $self=CORE::shift;(do{$self->var()->sigil()})};
sub twigil{my $self=CORE::shift;(do{$self->var()->twigil()})};
sub is_scalar{my $self=CORE::shift;(do{($self->var()->sigil() eq "\$")})};
sub is_array{my $self=CORE::shift;(do{($self->var()->sigil() eq "\@")})};
sub is_hash{my $self=CORE::shift;(do{($self->var()->sigil() eq "\%")})}})
}
;

{ package IRx1::SubDecl;
use base "Any";(do{sub sigil{my $self=CORE::shift;(do{"\&"})};
sub twigil{my $self=CORE::shift;(do{""})};
sub is_scalar{my $self=CORE::shift;(do{GLOBAL::undef()})};
sub is_array{my $self=CORE::shift;(do{GLOBAL::undef()})};
sub is_hash{my $self=CORE::shift;(do{GLOBAL::undef()})}})
}
;

{ package IRx1::Var;
use base "Any";(do{sub decl{my $self=CORE::shift;(do{$self->notes->postcircumfix__60_32_62('decl')})};
sub bare_name{my $self=CORE::shift;(do{$self->notes()->postcircumfix__60_32_62('bare_name')})};
sub package{my $self=CORE::shift;(do{$self->notes()->postcircumfix__60_32_62('package')})};
sub crnt_package{my $self=CORE::shift;(do{$self->notes()->postcircumfix__60_32_62('crnt_package')})};
sub is_context{my $self=CORE::shift;(do{(do{my $__tmp__=((((do{my $__tmp__=($self->twigil());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=("");no warnings "void";$__tmp__}})) eq "\+"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($self->notes->postcircumfix__60_32_62('is')->postcircumfix__60_32_62('context'));no warnings "void";$__tmp__}})})};
sub is_temp{my $self=CORE::shift;(do{$self->notes->postcircumfix__60_32_62('is')->postcircumfix__60_32_62('temp')})}})
}
;

{ package IRx1::PackageDecl;
use base "Any";(do{sub path_is_absolute{my $self=CORE::shift;(do{(do{my $__tmp__=($self->name());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($self->name()->re_matchp("\^GLOBAL\\b"));no warnings "void";$__tmp__}})})}})
}
;

{ package IRx1::Base;
use base "Any";(do{sub provides_a_list{my $self=CORE::shift;(do{GLOBAL::undef()})}})
}
;

{ package IRx1::Call;
use base "Any";(do{sub provides_a_list{my $self=CORE::shift;(do{($self->method() eq "flatten")})}})
}
;

{ package IRx1::Apply;
use base "Any";(do{sub provides_a_list{my $self=CORE::shift;(do{(do{my $__tmp__=(($self->function eq "infix\:\,"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($self->capture->contains_a_list());no warnings "void";$__tmp__}})})}})
}
;

{ package IRx1::Capture;
use base "Any";(do{sub contains_a_list{my $self=CORE::shift;(do{for(($self->arguments)->flatten){
(do{if((((do{my $__tmp__=($_->isa("IRx1\:\:Base"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($_->provides_a_list());no warnings "void";$__tmp__}})))->Bool) {
(do{return(1)})
}})
};
GLOBAL::undef()})}})
}
;

{ package IRx1::Apply;
use base "Any";(do{sub is_whatever{my $self=CORE::shift;(do{($self->function eq "whatever")})}})
}
;

{ package IRx1::Base;
use base "Any";(do{sub is_whatever{my $self=CORE::shift;(do{GLOBAL::undef()})}})
}
;

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package EmitSimpleP5;
use base "Any";(do{sub new_emitter{my $self=CORE::shift;my($ignore,$compiler,$ignore2,$filename)=@_;
(do{$self->new("compiler", $compiler, "filename", $filename)})};
sub compiler { if(@_==2){$_[0]{'compiler'}=$_[1]}else{$_[0]{'compiler'}}};
sub filename { if(@_==2){$_[0]{'filename'}=$_[1]}else{$_[0]{'filename'}}};
sub tidy{my $self=CORE::shift;my($source)=@_;
(do{GLOBAL::private_tidy($source)})};
sub prelude_for_entering_a_package{my $self=CORE::shift;(do{""})};
sub prelude_lexical{my $self=CORE::shift;(do{"use\ autobox\ ARRAY\ \=\>\ \'ARRAY\'\,\ HASH\ \=\>\ \'HASH\'\,\ CODE\ \=\>\ \'CODE\'\,\ INTEGER\ \=\>\ \'INTEGER\'\,\ FLOAT\ \=\>\ \'FLOAT\'\,\ STRING\ \=\>\ \'STRING\'\,\ UNDEF\ \=\>\ \'UNDEF\'\;\ \ use\ encoding\ \'utf8\'\;\
\ \ \ \ \ \ "})};
sub using_Moose{my $self=CORE::shift;(do{0})};
sub create_default_for{my $self=CORE::shift;my($cls,$field_name,$default)=@_;
(do{(((((("\$Object\:\:DEFAULTS\{" . $cls) . "\}\{\'") . $field_name) . "\'\}\ \=\ sub\ \{") . $default) . "\}\;")})};
sub prelude_oo{my $self=CORE::shift;(do{if(($self->using_Moose)->Bool) {
(do{"\{package\ AssertCurrentModuleVersions\;\ \ use\ Moose\ 0\.44\;\ \}"})
}else {
(do{"\
\{package\ Object\;\
\ \ \ \ our\ \%DEFAULTS\;\
\ \ \ \ sub\ new\ \{\
\ \ \ \ \ \ \ \ my\ \$self\ \=\ shift\;\
\ \ \ \ \ \ \ \ my\ \$class\ \=\ ref\ \$self\ \|\|\ \$self\;\
\ \ \ \ \ \ \ \ my\ \$obj\ \=\ bless\ \{\@_\}\,\ \$class\;\
\ \ \ \ \ \ \ \ for\ \(keys\ \%\{\$DEFAULTS\{\$class\}\}\)\ \{\
\ \ \ \ \ \ \ \ \ \ \ \ \$obj\-\>\{\$_\}\ \=\ \$DEFAULTS\{\$class\}\{\$_\}\-\>\(\)\ unless\ \$obj\-\>\{\$_\}\;\
\ \ \ \ \ \ \ \ \}\
\ \ \ \ \ \ \ \ \$obj\;\
\ \ \ \ \}\
\ \ \ \ sub\ become\ \{\
\ \ \ \ \ \ my\(\$self\,\$cls\)\=\@_\;\
\ \ \ \ \ \ bless\ \$self\,\$cls\;\
\ \ \ \ \}\
\}\
"})
}})};
sub prelude{my $self=CORE::shift;(do{((("\#\!\/usr\/bin\/env\ perl\
use\ strict\;\
no\ strict\ \"subs\"\;\ \#\ XXX\ remove\ once\ Type\-names\ are\ quoted\.\ \#\ say\ Int\.isa\(Any\)\
use\ warnings\;\
\
\{package\ AssertCurrentModuleVersions\;\
\ use\ autobox\ 2\.51\;\
\}\
\{\ package\ NoSideEffects\;\
\ \ use\ Class\:\:Multimethods\;\
\ \ use\ Data\:\:Dumper\;\
\}\
" . $self->prelude_oo()) . $self->prelude_lexical()) . "\
\
\#\ Workaround\ autobox\ 2\.53\ api\ change\.\ \:\(\
if\(\!defined\(\&autobox\:\:universal\:\:type\)\)\ \{\
\ \ eval\ q\{package\ autobox\:\:universal\;\ sub\ type\ \{\ autobox\-\>type\(\$_\[0\]\)\ \}\}\;\
\}\
\{package\ UNIVERSAL\;\ sub\ ref\ \{CORE\:\:ref\(\$_\[0\]\)\ \|\|\ autobox\:\:universal\:\:type\(\$_\[0\]\)\ \}\ \}\ \#\ For\ IRx1_FromAST\.pm\.\
\{package\ UNIVERSAL\;\ sub\ WHAT\ \{CORE\:\:ref\(\$_\[0\]\)\ \|\|\ autobox\:\:universal\:\:type\(\$_\[0\]\)\ \}\ \}\
\
\{\ package\ Any\;\
\ \ sub\ can\ \{\ UNIVERSAL\:\:can\(\$_\[0\]\,\$_\[1\]\)\ \}\
\ \ sub\ isa\ \{\ UNIVERSAL\:\:isa\(\$_\[0\]\,\$_\[1\]\)\ \}\
\ \ sub\ does\ \{\ UNIVERSAL\:\:isa\(\$_\[0\]\,\$_\[1\]\)\ \}\
\}\ \ \
\
\#\ Avoid\ \"use\ base\"\ error\:\ Base\ class\ package\ \"Xxx\"\ is\ empty\.\ \:\/\
\{\ package\ Num\;\ our\ \$_tell_use_base_i_am_not_empty_\;\ \}\
\{\ package\ Int\;\ our\ \$_tell_use_base_i_am_not_empty_\;\ \}\
\{\ package\ Str\;\ our\ \$_tell_use_base_i_am_not_empty_\;\ \}\
\{\ package\ Array\;\ our\ \$_tell_use_base_i_am_not_empty_\;\ \}\
\{\ package\ Hash\;\ our\ \$_tell_use_base_i_am_not_empty_\;\ \}\
\{\ package\ Undef\;\ our\ \$_tell_use_base_i_am_not_empty_\;\ \}\
\{\ package\ Code\;\ our\ \$_tell_use_base_i_am_not_empty_\;\ \}\
\
\{package\ UNDEF\;\
\ use\ base\ \"Undef\"\;\
\ sub\ WHAT\ \{\"Undef\"\}\
\ sub\ perl\ \{\ \"undef\"\ \}\
\}\
no\ warnings\ qw\(redefine\ prototype\)\;\
\{\ package\ STRING\;\
\ \ use\ base\ \"Str\"\;\
\ \ sub\ WHAT\ \{\ \"Str\"\ \}\
\
\ \ sub\ re_matchp\ \{\ \(\$_\[0\]\ \=\~\ m\{\$_\[1\]\}\)\ \?\ 1\ \:\ 0\ \}\
\ \ sub\ re_groups\ \{\
\ \ \ \ my\ \@g\ \=\ \$_\[0\]\ \=\~\ m\{\$_\[1\]\}\;\
\ \ \ \ \@g\ \?\ \\\@g\ \:\ undef\;\
\ \ \}\
\
\ \ sub\ re_gsub_pat\ \{\ \#\ slower\,\ but\ needed\ for\ \$1\.\
\ \ \ \ my\(\$s\,\$pat\,\$replace_pat\)\=\@_\;\
\ \ \ \ eval\ \"\\\$s\ \=\~\ s\/\$pat\/\$replace_pat\/g\"\;\
\ \ \ \ Carp\:\:confess\(\$\@\)\ if\ \$\@\;\
\ \ \ \ \$s\;\
\ \ \}\
\ \ sub\ re_gsub\ \{\
\ \ \ \ my\(\$s\,\$pat\,\$replace_str\)\=\@_\;\
\ \ \ \ \$s\ \=\~\ s\/\$pat\/\$replace_str\/g\;\
\ \ \ \ \$s\;\
\ \ \}\
\
\ \ \#\ unused\
\ \ sub\ re_sub\ \ \ \ \ \ \ \ \ \{\
\ \ \ \ my\ \$expr\ \=\ \"\\\$_\[0\]\ \=\~\ s\/\$_\[1\]\/\$_\[2\]\/\"\.\(\$_\[3\]\|\|\"\"\)\;\
\ \ \ \ eval\ \$expr\;\
\ \ \ \ Carp\:\:confess\(\$\@\)\ if\ \$\@\;\
\ \ \ \ \$_\[0\]\
\ \ \}\
\
\ \ sub\ hex\ \ \ \{\ CORE\:\:hex\(\$_\[0\]\)\;\ \}\
\
\ \ \#\ randomness\ taken\ from\ autobox\:\:Core\
\
\ \ sub\ chomp\ \ \ \ \{\ CORE\:\:chomp\(\$_\[0\]\)\;\ \}\
\ \ sub\ chop\ \ \ \ \ \{\ CORE\:\:chop\(\$_\[0\]\)\;\ \}\
\ \ sub\ chr\ \ \ \ \ \ \{\ CORE\:\:chr\(\$_\[0\]\)\;\ \}\
\ \ sub\ crypt\ \ \ \ \{\ CORE\:\:crypt\(\$_\[0\]\,\ \$_\[1\]\)\;\ \}\
\ \ sub\ index\ \ \ \ \{\ CORE\:\:index\(\$_\[0\]\,\ \$_\[1\]\,\ \@_\[2\.\.\ \$\#_\]\)\;\ \}\
\ \ sub\ lc\ \ \ \ \ \ \ \{\ CORE\:\:lc\(\$_\[0\]\)\;\ \}\
\ \ sub\ lcfirst\ \ \{\ CORE\:\:lcfirst\(\$_\[0\]\)\;\ \}\
\
\ \ sub\ bytes\ \ \ \ \{\ use\ bytes\;\ CORE\:\:length\(\$_\[0\]\)\;\ \}\
\ \ sub\ chars\ \ \ \ \{\ CORE\:\:length\(\$_\[0\]\)\;\ \}\
\ \ sub\ codes\ \ \ \ \{\ my\ \@c\ \=\ unpack\(\"U\*\"\,\$_\[0\]\)\;\ 0\+\@c\ \}\
\ \ sub\ graphs\ \ \ \{\ require\ String\:\:Multibyte\;\ String\:\:Multibyte\-\>new\(\"Grapheme\"\)\-\>length\(\$_\[0\]\)\ \}\
\
\ \ sub\ ord\ \ \ \ \ \ \{\ CORE\:\:ord\(\$_\[0\]\)\;\ \}\
\ \ sub\ pack\ \ \ \ \ \{\ CORE\:\:pack\(\@_\)\;\ \}\
\ \ sub\ reverse\ \ \{\ CORE\:\:reverse\(\$_\[0\]\)\;\ \}\
\ \ sub\ rindex\ \ \ \{\ CORE\:\:rindex\(\$_\[0\]\,\ \$_\[1\]\,\ \@_\[2\.\.\ \$\#_\]\)\;\ \}\
\ \ sub\ sprintf\ \ \{\ CORE\:\:sprintf\(\$_\[0\]\,\ \$_\[1\]\,\ \@_\[2\.\.\ \$\#_\]\)\;\ \}\
\ \ sub\ substr\ \ \ \{\ CORE\:\:substr\(\$_\[0\]\,\ \$_\[1\]\,\ \@_\[2\ \.\.\ \$\#_\]\)\;\ \}\
\ \ sub\ uc\ \ \ \ \ \ \ \{\ CORE\:\:uc\(\$_\[0\]\)\;\ \}\
\ \ sub\ ucfirst\ \ \{\ CORE\:\:ucfirst\(\$_\[0\]\)\;\ \}\
\ \ sub\ unpack\ \ \ \{\ CORE\:\:unpack\(\$_\[0\]\,\ \@_\[1\.\.\$\#_\]\)\;\ \}\
\ \ sub\ undef\ \ \ \ \{\ \$_\[0\]\ \=\ undef\ \}\
\ \ sub\ m\ \ \ \ \ \ \ \ \{\ \[\ \$_\[0\]\ \=\~\ m\{\$_\[1\]\}\ \]\ \}\
\ \ sub\ nm\ \ \ \ \ \ \ \ \{\ \[\ \$_\[0\]\ \!\~\ m\{\$_\[1\]\}\ \]\ \}\
\ \ sub\ s\ \ \ \ \ \ \ \ \{\ \$_\[0\]\ \=\~\ s\{\$_\[1\]\}\{\$_\[2\]\}\ \}\
\ \ sub\ split\ \ \ \ \{\ \[\ split\ \$_\[1\]\,\ \$_\[0\]\ \]\ \}\
\
\ \ sub\ primitive_Num\ \{\ no\ warnings\ \"numeric\"\;\ 0\+\$_\[0\]\ \}\
\}\
\
\{\ package\ FLOAT_and_INTEGER\;\
\ \ use\ base\ \"Num\"\;\
\ \ sub\ abs\ \ \ \{\ CORE\:\:abs\(\$_\[0\]\)\ \}\
\ \ sub\ atan2\ \{\ CORE\:\:atan2\(\$_\[0\]\,\ \$_\[1\]\)\ \}\
\ \ sub\ cos\ \ \ \{\ CORE\:\:cos\(\$_\[0\]\)\ \}\
\ \ sub\ exp\ \ \ \{\ CORE\:\:exp\(\$_\[0\]\)\ \}\
\ \ sub\ int\ \ \ \{\ CORE\:\:int\(\$_\[0\]\)\ \}\
\ \ sub\ log\ \ \ \{\ CORE\:\:log\(\$_\[0\]\)\ \}\
\ \ sub\ oct\ \ \ \{\ CORE\:\:oct\(\$_\[0\]\)\ \}\
\ \ sub\ hex\ \ \ \{\ CORE\:\:hex\(\$_\[0\]\)\;\ \}\
\ \ sub\ rand\ \ \{\ CORE\:\:rand\(\$_\[0\]\)\ \}\
\ \ sub\ sin\ \ \ \{\ CORE\:\:sin\(\$_\[0\]\)\ \}\
\ \ sub\ sqrt\ \ \{\ CORE\:\:sqrt\(\$_\[0\]\)\ \}\
\
\}\
\{\ package\ FLOAT\;\
\ \ use\ base\ \"FLOAT_and_INTEGER\"\;\
\ \ sub\ WHAT\ \{\ \"Num\"\ \}\
\}\
\{\ package\ INTEGER\;\
\ \ use\ base\ \"FLOAT_and_INTEGER\"\;\
\ \ use\ base\ \"Int\"\;\
\
\ \ sub\ WHAT\ \{\ \"Int\"\ \}\
\ \ sub\ to\ \(\$\$\)\ \{\ \$_\[0\]\ \<\ \$_\[1\]\ \?\ \[\$_\[0\]\.\.\$_\[1\]\]\ \:\ \[CORE\:\:reverse\ \$_\[1\]\.\.\$_\[0\]\]\}\
\ \ sub\ upto\ \(\$\$\)\ \{\ \[\ \$_\[0\]\.\.\$_\[1\]\ \]\ \}\
\ \ sub\ downto\ \(\$\$\)\ \{\ \[\ CORE\:\:reverse\ \$_\[1\]\.\.\$_\[0\]\ \]\ \}\
\
\ \ sub\ chr\ \ \ \ \ \ \{\ CORE\:\:chr\(\$_\[0\]\)\;\ \}\
\}\
\{\ package\ ARRAY\;\
\ \ use\ base\ \"Array\"\;\
\ \ sub\ WHAT\ \{\"Array\"\}\
\
\ \ sub\ shape\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ 0\+\@\$a\ \}\ \#\ \?\
\ \ sub\ end\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ \-1\+\@\$a\ \}\ \#\ \?\
\ \ sub\ elems\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ CORE\:\:scalar\ \@\$a\ \}\
\ \ sub\ delete\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ \@_\ \?\ CORE\:\:delete\(\$a\-\>\[\$_\[0\]\]\)\ \:\ undef\ \}\
\ \ sub\ exists\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ \@_\ \?\ CORE\:\:exists\(\$a\-\>\[\$_\[0\]\]\)\ \:\ undef\ \}\
\ \ sub\ pop\ \ \ \{\ CORE\:\:pop\ \@\{\$_\[0\]\}\;\ \}\
\ \ sub\ shift\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ CORE\:\:shift\(\@\$a\)\ \}\
\ \ sub\ push\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ CORE\:\:push\(\@\$a\,\@_\)\;\ \$a\ \}\
\ \ sub\ unshift\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ CORE\:\:unshift\(\@\$a\,\@_\)\ \}\
\ \ sub\ splice\ \{\
\ \ \ \ my\ \$a\ \=\ CORE\:\:shift\;\
\ \ \ \ my\ \$offset\ \=\ CORE\:\:shift\ \|\|\ 0\;\
\ \ \ \ my\ \$size\ \=\ CORE\:\:shift\ \|\|\ 0\;\
\ \ \ \ \[CORE\:\:splice\(\@\{\$a\}\,\$offset\,\$size\,\@_\)\]\
\ \ \}\
\ \ sub\ keys\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ \[0\.\.\(\@\$a\-1\)\]\ \}\
\ \ sub\ kv\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ my\ \$idx\ \=\ 0\;\ \[map\{\(\$idx\+\+\,\$_\)\}\@\$a\]\ \}\
\ \ sub\ pairs\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ my\ \$idx\ \=\ 0\;\ \[map\{Pair\-\>new\(\"key\"\=\>\$idx\+\+\,\"value\"\=\>\$_\)\}\@\$a\]\ \}\
\ \ sub\ values\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ \@\$a\ \}\
\
\ \ \#\ Speculative\
\
\ \ sub\ clone\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ \[\@\$a\]\ \}\
\
\ \ \#\ Non\-spec\
\
\ \ sub\ grep\ \ \{\ my\ \$arr\ \=\ CORE\:\:shift\;\ my\ \$sub\ \=\ CORE\:\:shift\;\ \[\ CORE\:\:grep\ \{\ \$sub\-\>\(\$_\)\ \}\ \@\$arr\ \]\;\ \}\
\ \ sub\ join\ \ \{\ my\ \$arr\ \=\ CORE\:\:shift\;\ my\ \$sep\ \=\ CORE\:\:shift\;\ CORE\:\:join\ \$sep\,\ \@\$arr\;\ \}\
\ \ sub\ map\ \ \{\ my\ \$arr\ \=\ CORE\:\:shift\;\ my\ \$sub\ \=\ CORE\:\:shift\;\ \[\ CORE\:\:map\ \{\ \$sub\-\>\(\$_\)\ \}\ \@\$arr\ \]\;\ \}\
\ \ sub\ reverse\ \ \{\ \[\ CORE\:\:reverse\ \@\{\$_\[0\]\}\ \]\ \}\
\ \ sub\ sort\ \ \{\ my\ \$arr\ \=\ CORE\:\:shift\;\ my\ \$sub\ \=\ CORE\:\:shift\(\)\ \|\|\ sub\ \{\ \$a\ cmp\ \$b\ \}\;\ \[\ CORE\:\:sort\ \{\ \$sub\-\>\(\$a\,\ \$b\)\ \}\ \@\$arr\ \]\;\ \}\
\ \ sub\ max\ \{\ my\ \$arr\ \=\ CORE\:\:shift\;\ my\ \$max\ \=\ \$arr\-\>\[0\]\;\ foreach\ \(\@\$arr\)\ \{\$max\ \=\ \$_\ if\ \$_\ \>\ \$max\ \}\;\ \$max\;\ \}\
\ \ sub\ min\ \{\ my\ \$arr\ \=\ CORE\:\:shift\;\ my\ \$min\ \=\ \$arr\-\>\[0\]\;\ foreach\ \(\@\$arr\)\ \{\$min\ \=\ \$_\ if\ \$_\ \<\ \$min\ \}\;\ \$min\;\ \}\
\
\ \ sub\ concat\ \{\ \[map\{\@\$_\}\ \@_\]\ \}\
\
\ \ \#\ Internal\
\
\ \ sub\ flatten\ \ \{\ \(\ \@\{\$_\[0\]\}\ \)\ \}\
\ \ sub\ flatten_recursively\ \{\
\ \ \ \ map\ \{\ my\ \$ref\ \=\ ref\(\$_\)\;\ \(\$ref\ \&\&\ \$ref\ eq\ \"ARRAY\"\)\ \?\ \$_\-\>flatten_recursively\ \:\ \$_\ \}\ \@\{\$_\[0\]\}\
\ \ \}\
\
\}\
\{\ package\ HASH\;\
\ \ use\ base\ \"Hash\"\;\
\ \ sub\ WHAT\ \{\"Hash\"\}\
\
\ \ \#\ randomness\ taken\ from\ autobox\:\:Core\
\
\ \ sub\ delete\ \ \{\ my\ \$hash\ \=\ CORE\:\:shift\;\ my\ \@res\ \=\ \(\)\;\ CORE\:\:foreach\(\@_\)\ \{\ push\ \@res\,\ CORE\:\:delete\ \$hash\-\>\{\$_\}\;\ \}\ CORE\:\:wantarray\ \?\ \@res\ \:\ \\\@res\ \}\
\ \ sub\ exists\ \ \{\ my\ \$hash\ \=\ CORE\:\:shift\;\ CORE\:\:exists\ \$hash\-\>\{\$_\[0\]\}\;\ \}\
\ \ sub\ keys\ \ \{\ \[\ CORE\:\:keys\ \%\{\$_\[0\]\}\ \]\ \}\
\ \ sub\ values\ \ \{\ \[\ CORE\:\:values\ \%\{\$_\[0\]\}\ \]\ \}\
\
\ \ sub\ each\ \ \{\
\ \ \ \ my\ \$hash\ \=\ CORE\:\:shift\;\
\ \ \ \ my\ \$cb\ \=\ CORE\:\:shift\;\
\ \ \ \ while\(\(my\ \$k\,\ my\ \$v\)\ \=\ CORE\:\:each\(\%\$hash\)\)\ \{\
\ \ \ \ \ \ \$cb\-\>\(\$k\,\ \$v\)\;\
\ \ \ \ \}\
\ \ \}\
\
\ \ \#\ spec\
\
\ \ sub\ kv\ \{\ my\ \$h\ \=\ CORE\:\:shift\;\ \[map\{\(\$_\,\$h\-\>\{\$_\}\)\}\ CORE\:\:keys\ \%\$h\]\ \}\
\ \ sub\ pairs\ \{\ my\ \$h\ \=\ CORE\:\:shift\;\ \[map\{Pair\-\>new\(\"key\"\=\>\$_\,\"value\"\=\>\$h\-\>\{\$_\}\)\}\ CORE\:\:keys\ \%\$h\]\ \}\
\
\ \ \#\ Speculative\
\
\ \ sub\ clone\ \{\
\ \ \ \ my\ \$h\ \=\ CORE\:\:shift\;\
\ \ \ \ \#\ Do\ not\ simplify\ this\ to\ \"\.\.\.ift\;\ \{\%\$h\}\ \}\"\.\ \ returns\ 0\.\ \ autobox\ issue\?\
\ \ \ \ my\ \$h1\ \=\ \{\%\$h\}\;\ \$h1\
\ \ \}\
\
\ \ \#\ Temporary\
\
\ \ sub\ dup\ \{\ my\ \$h\ \=\ CORE\:\:shift\;\ my\ \$h1\ \=\ \{\%\$h\}\;\ \$h1\}\ \#\ obsolete\
\}\
\{\ package\ CODE\;\
\ \ use\ base\ \"Code\"\;\
\ \ sub\ WHAT\ \{\"Code\"\}\
\}\
\
\{\ package\ Any\;\ sub\ Hash\ \{\ \$_\[0\]\ \}\ \}\ \#X\
\{\ package\ Hash\;\ sub\ Hash\ \{\ \$_\[0\]\ \}\ \}\
\{\ package\ Array\;\ sub\ Array\ \{\ \$_\[0\]\ \}\ \}\
\
\{\ package\ Any\;\ \#X\
\ \ sub\ postcircumfix__123_32_125\ \{\ \@_\ \<\=\ 2\ \?\ \$_\[0\]\-\>\{\$_\[1\]\}\ \:\ do\{\$_\[0\]\-\>\{\$_\[1\]\}\ \=\ \$_\[2\]\}\ \}\
\ \ sub\ postcircumfix__60_32_62\ \{\ \@_\ \<\=\ 2\ \?\ \$_\[0\]\-\>\{\$_\[1\]\}\ \:\ do\{\$_\[0\]\-\>\{\$_\[1\]\}\ \=\ \$_\[2\]\}\ \}\
\}\
\{\ package\ HASH\;\
\ \ sub\ postcircumfix__123_32_125\ \{\ \@_\ \<\=\ 2\ \?\ \$_\[0\]\-\>\{\$_\[1\]\}\ \:\ do\{\$_\[0\]\-\>\{\$_\[1\]\}\ \=\ \$_\[2\]\}\ \}\
\ \ sub\ postcircumfix__60_32_62\ \{\ \@_\ \<\=\ 2\ \?\ \$_\[0\]\-\>\{\$_\[1\]\}\ \:\ do\{\$_\[0\]\-\>\{\$_\[1\]\}\ \=\ \$_\[2\]\}\ \}\
\}\
\{\ package\ ARRAY\;\
\ \ sub\ postcircumfix__91_32_93\ \{\ \@_\ \<\=\ 2\ \?\ \$_\[0\]\-\>\[\$_\[1\]\]\ \:\ do\{\$_\[0\]\-\>\[\$_\[1\]\]\ \=\ \$_\[2\]\}\ \}\
\}\
\
\{\ package\ Match\;\
\ \ sub\ postcircumfix__123_32_125\ \{\ \@_\ \<\=\ 2\ \?\ \$_\[0\]\-\>\{\"match_hash\"\}\-\>\{\$_\[1\]\}\ \:\ do\{\$_\[0\]\-\>\{\"match_hash\"\}\-\>\{\$_\[1\]\}\ \=\ \$_\[2\]\}\ \}\
\ \ sub\ postcircumfix__60_32_62\ \{\ \@_\ \<\=\ 2\ \?\ \$_\[0\]\-\>\{\"match_hash\"\}\-\>\{\$_\[1\]\}\ \:\ do\{\$_\[0\]\-\>\{\"match_hash\"\}\-\>\{\$_\[1\]\}\ \=\ \$_\[2\]\}\ \}\
\ \ sub\ postcircumfix__91_32_93\ \{\ \@_\ \<\=\ 2\ \?\ \$_\[0\]\-\>\{\"match_array\"\}\-\>\[\$_\[1\]\]\ \:\ do\{\$_\[0\]\-\>\{\"match_array\"\}\-\>\[\$_\[1\]\]\ \=\ \$_\[2\]\}\ \}\
\
\ \ sub\ Str\ \{\ \$_\[0\]\-\>\{\"match_string\"\}\ \}\
\ \ sub\ Bool\ \{\ \$_\[0\]\-\>\{\"match_boolean\"\}\ \}\
\ \ sub\ Hash\ \{\ \$_\[0\]\-\>\{\"match_hash\"\}\ \}\
\ \ sub\ Array\ \{\ \$_\[0\]\-\>\{\"match_array\"\}\ \}\
\}\
\
\{\ package\ Any\;\ sub\ Bool\ \{\ 1\ \}\ \}\
\{\ package\ UNDEF\;\ sub\ Bool\ \{\ undef\ \}\ \}\
\{\ package\ ARRAY\;\ sub\ Bool\ \{\ \@\{\$_\[0\]\}\ \?\ 1\ \:\ undef\ \}\ \}\
\{\ package\ HASH\;\ sub\ Bool\ \{\ \%\{\$_\[0\]\}\ \?\ 1\ \:\ undef\ \}\ \}\
\{\ package\ FLOAT_and_INTEGER\;\ sub\ Bool\ \{\ \$_\[0\]\ \?\ 1\ \:\ undef\ \}\ \}\
\{\ package\ STRING\;\ sub\ Bool\ \{\ \$_\[0\]\ \?\ 1\ \:\ undef\ \}\ \}\
\
use\ warnings\;\
\
\{\ package\ Any\;\ sub\ __make_not_empty_for_use_base\{\}\}\
\{\ package\ STRING\;\ use\ base\ \"Any\"\;\}\
\{\ package\ INTEGER\;\ use\ base\ \"Any\"\;\}\
\{\ package\ FLOAT\;\ use\ base\ \"Any\"\;\}\
\{\ package\ ARRAY\;\ use\ base\ \"Any\"\;\}\
\{\ package\ HASH\;\ use\ base\ \"Any\"\;\}\
\{\ package\ CODE\;\ use\ base\ \"Any\"\;\}\
\
\{\ package\ Private\;\
\ \ \#\ Taken\ from\ Perl6\:\:Take\ 0\.04\.\
\ \ our\ \@GATHER\;\
\ \ sub\ gather\ \(\&\)\ \{local\ \@GATHER\ \=\ \(\@GATHER\,\ \[\]\)\;\ shift\-\>\(\)\;\ \$GATHER\[\-1\]\ \}\
\ \ sub\ take\ \(\@\)\ \{push\ \@\{\ \$GATHER\[\-1\]\ \}\,\ \@_\;\ undef\ \}\
\}\
\
\{\ package\ GLOBAL\;\
\ \ \{\ no\ warnings\;\
\ \ \ \ \*gather\ \=\ \\\&Private\:\:gather\;\
\ \ \ \ \*take\ \ \ \=\ \\\&Private\:\:take\;\}\
\
\ \ our\ \$a_ARGS\ \=\ \[map\ \{encoding\:\:decode\(\"utf8\"\,\$_\)\}\ \@ARGV\]\;\
\
\ \ sub\ undef\{undef\}\
\
\ \ use\ Carp\;\
\ \ sub\ slurp\ \{\
\ \ \ \ my\(\$file\)\=\@_\;\
\ \ \ \ local\ \$\/\;\
\ \ \ \ open\(my\ \$fh\,\"\<\:utf8\"\,\$file\)\;\
\ \ \ \ my\ \$s\ \=\ \<\$fh\>\;\
\ \ \ \ \$s\
\ \ \}\
\ \ sub\ unslurp\ \{\
\ \ \ \ my\(\$text\,\$file\)\=\@_\;\
\ \ \ \ open\(my\ \$fh\,\"\>\:utf8\"\,\$file\)\ or\ CORE\:\:die\ \$\!\;\
\ \ \ \ CORE\:\:print\ \$fh\ \$text\;\
\ \ \ \ close\ \$fh\;\
\ \ \}\
\ \ sub\ file_exists\{\-e\ \$_\[0\]\}\
\ \ sub\ system\{CORE\:\:system\(\@_\)\}\
\ \ sub\ eval_runtime_code\{\
\ \ \ \ my\(\$p5\,\$env\)\=\@_\;\
\ \ \ \ if\(\$env\)\ \{\ \$env\-\>\(\$p5\)\ \}\
\ \ \ \ else\ \{\
\ \ \ \ \ \ my\ \$code\ \=\ \"package\ Main\;\ \"\.\$p5\;\
\ \ \ \ \ \ my\ \$res\ \=\ eval\(\$code\)\;\ croak\(\$\@\)\ if\ \$\@\;\
\ \ \ \ \ \ \$res\
\ \ \ \ \}\
\ \ \}\
\ \ sub\ eval_perl5\{\
\ \ \ \ my\(\$p5\,\$env\)\=\@_\;\
\ \ \ \ eval_runtime_code\(\$p5\,\$env\)\;\
\ \ \}\
\ \ sub\ die\{croak\ \@_\}\
\ \ sub\ exit\{CORE\:\:exit\(\@_\)\}\
\ \ sub\ defined\{CORE\:\:defined\(\$_\[0\]\)\}\
\ \ sub\ substr\ \{CORE\:\:substr\(\$_\[0\]\,\$_\[1\]\,\$_\[2\]\)\}\
\ \ sub\ not\{\$_\[0\]\ \?\ \!\(\$_\[0\]\-\>Bool\)\ \:\ 1\}\
\ \ sub\ exec\{CORE\:\:exec\(\@_\)\}\
\ \ sub\ sleep\{CORE\:\:sleep\(\@_\)\}\
\
\ \ sub\ split\{\[CORE\:\:split\(\$_\[0\]\,\$_\[1\]\)\]\}\
\ \ sub\ push\ \{\ my\ \$a\ \=\ CORE\:\:shift\;\ CORE\:\:push\(\@\$a\,\@_\)\;\ \$a\ \}\
\
\ \ sub\ unlink\{CORE\:\:unlink\(\@_\)\}\
\ \ sub\ sprintf\{CORE\:\:sprintf\(shift\,\@_\)\}\
\ \ sub\ print\ \{\ CORE\:\:print\ \@_\ \}\
\ \ sub\ quotemeta\ \{\ CORE\:\:quotemeta\(\$_\[0\]\)\ \}\
\
\ \ sub\ chmod_exe\ \{\ CORE\:\:chmod\(0755\,\$_\[0\]\)\ \}\ \#\ Hack\ for\ Compiler\.\
\
\ \ sub\ private_tidy\ \{\
\ \ \ \ eval\(\"use\ Perl\:\:Tidy\"\)\;\
\ \ \ \ if\ \(\$\@\)\ \{\ \$_\[0\]\ \}\
\ \ \ \ elsif\ \(\$ENV\{ELF_DEV_NO_TIDY\}\)\ \{\ \$_\[0\]\ \}\
\ \ \ \ else\ \{\
\ \ \ \ \ \ my\ \$source\ \=\ \$_\[0\]\;\
\ \ \ \ \ \ my\ \$dest\;\
\ \ \ \ \ \ Perl\:\:Tidy\:\:perltidy\(argv\=\>\[\]\,source\=\>\\\$source\,destination\=\>\\\$dest\)\;\
\ \ \ \ \ \ \$dest\;\
\ \ \ \ \}\
\ \ \}\
\
\}\
\
\{\ package\ GLOBAL\;\
\
\ \ sub\ parser_format\ \{\"p5a\"\}\
\ \ sub\ parser_name\{\
\ \ \ \ my\ \$e\ \=\ \$ENV\{ELF_STD_RED_RUN\}\;\
\ \ \ \ return\ \$e\ if\ \$e\;\
\ \ \ \ my\ \$f\ \=\ \$0\;\
\ \ \ \ \$f\ \=\~\ s\/\[\^\\\/\]\+\$\/\/\;\
\ \ \ \ \#\ \$f\.\"elf_h_src\/STD_red\/STD_red_run\"\
\ \ \ \ \$f\.\"\.\.\/STD_red\/STD_red_run\"\
\ \ \}\
\
\ \ our\ \$a_INC\ \=\ \[\"\.\"\]\;\
\ \ our\ \$h_ENV\ \=\ \\\%ENV\;\
\
\ \ sub\ module_require\ \{\
\ \ \ \ my\(\$module\)\=\@_\;\
\ \ \ \ my\ \$file\ \=\ find_required_module\(\$module\)\;\
\ \ \ \ \$file\ \|\|\ CORE\:\:die\ \"Cant\ locate\ \$module\ in\ \(\ \"\.CORE\:\:join\(\"\ \"\,\@\$GLOBAL\:\:a_INC\)\.\"\ \)\.\\n\"\;\
\ \ \ \ eval_file\(\$file\)\;\
\ \ \}\;\
\ \ sub\ find_required_module\ \{\
\ \ \ \ my\(\$module\)\=\@_\;\
\ \ \ \ my\ \@names\ \=\ \(\$module\,\$module\.\"\.pm\"\,\$module\.\"\.p6\"\)\;\
\ \ \ \ for\ my\ \$dir\ \(\@\$GLOBAL\:\:a_INC\)\ \{\
\ \ \ \ \ \ for\ my\ \$name\ \(\@names\)\ \{\
\ \ \ \ \ \ \ \ my\ \$file\ \=\ \$dir\.\"\/\"\.\$name\;\
\ \ \ \ \ \ \ \ if\(\-f\ \$file\)\ \{\
\ \ \ \ \ \ \ \ \ \ return\ \$file\;\
\ \ \ \ \ \ \ \ \}\
\ \ \ \ \ \ \}\
\ \ \ \ \}\
\ \ \ \ return\ undef\;\
\ \ \}\
\ \ sub\ import\ \{\
\ \ \ \ my\(\$module\,\@args\)\=\@_\;\
\ \ \ \ my\ \$args\ \=\ \\\@args\;\
\ \ \ \ my\ \$import\ \=\ \"if\(defined\(\&\"\.\$module\.\"\:\:import\)\)\ \{\ \"\.\$module\.\"\-\>import\(\\\$args\)\;\ \}\"\;\
\ \ \ \ my\ \$result\ \=\ eval\ \$import\;\
\ \ \ \ Carp\:\:confess\(\$\@\)\ if\ \$\@\;\
\ \ \ \ \$result\;\
\ \ \}\
\ \ sub\ mkdir\ \{\
\ \ \ \ my\(\$dir\)\ \=\ \@_\;\
\ \ \ \ mkdir\(\$dir\)\;\
\ \ \}\
\
\ \ our\ \$compiler0\;\
\ \ our\ \$compiler1\;\
\ \ our\ \$parser0\;\
\ \ our\ \$parser1\;\
\ \ our\ \$ast2ir_0\;\
\ \ our\ \$ast2ir_1\;\
\ \ our\ \$emitter0\;\
\ \ our\ \$emitter1\;\
\
\ \ sub\ eval_file\ \{\
\ \ \ \ my\(\$file\)\=\@_\;\
\ \ \ \ \$GLOBAL\:\:compiler0\-\>eval_file\(\$file\)\;\
\ \ \}\
\ \ sub\ eval_perl6\ \{\
\ \ \ \ my\(\$code\,\$env\)\=\@_\;\
\ \ \ \ \$GLOBAL\:\:compiler0\-\>eval_perl6\(\$code\,\$env\)\;\
\ \ \}\
\ \ sub\ eval\ \{\
\ \ \ \ my\(\$code\,\$env\)\=\@_\;\
\ \ \ \ eval_perl6\(\$code\,\$env\)\;\
\ \ \}\
\}\
\
\{\ package\ Fastundump\;\
\ \ sub\ match\ \{my\(\$r\,\$s\,\$f\,\$t\,\$h\)\=\@_\;\ Match\-\>make_from_rsfth\(\$r\,\$s\,\$f\,\$t\,\$h\)\}\
\}\
\{\ package\ GLOBAL\;\
\ \ sub\ fastundump\ \{my\(\$dump\)\=\@_\;\ eval\(\"package\ Fastundump\;\ \"\.\$dump\)\;\}\
\ \ sub\ mangle_name\ \{my\(\$name\)\=\@_\;\
\ \ \ \ \$name\ \=\~\ s\/\(\[\^\\w\]\)\/\"_\"\.CORE\:\:ord\(\$1\)\/eg\;\
\ \ \ \ \$name\;\
\ \ \}\
\ \ sub\ symbol_lookup\ \:\ lvalue\ \{\
\ \ \ \ my\(\$name\)\=\@_\;\
\ \ \ \ my\ \@parts\ \=\ split\(\/\:\:\/\,\$name\)\;\
\ \ \ \ \$parts\[0\]\ \=\~\ \/\\A\(\[\\\$\\\@\\\%\]\)\(\.\*\)\/\ \|\|\ CORE\:\:die\(\"symbol_lookup\:\ no\ sigil\?\:\ \$name\"\)\;\
\ \ \ \ \$parts\[0\]\ \=\ \$2\;\
\ \ \ \ my\ \$sigil\ \=\ \$1\;\
\ \ \ \ \$parts\[\-1\]\ \=\ \{\"\\\$\"\=\>\"\"\,\"\\\@\"\=\>\"a_\"\,\"\\\%\"\=\>\"h_\"\}\-\>\{\$sigil\}\.\$parts\[\-1\]\;\
\ \ \ \ my\ \$var\ \=\ join\(\"\:\:\"\,\@parts\)\;\
\ \ \ \ no\ strict\ \"refs\"\;\
\ \ \ \ \$\$var\;\
\ \ \}\
\}\
\
package\ Main\;\
")})};
sub e{my $self=CORE::shift;my($x)=@_;
(do{my $ref = $x->WHAT();
if((($ref eq "Undef"))->Bool) {
(do{$x})
}elsif(((do{my $__tmp__=(($ref eq "Str"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($ref eq "Int"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($ref eq "Num"));no warnings "void";$__tmp__}}}))->Bool) {
(do{$x})
}elsif((($ref eq "Array"))->Bool) {
(do{$x->map(sub {my($ae)=@_;
(do{$self->e($ae)})})})
}else {
(do{$x->callback($self)})
}})};
sub cb__CompUnit{my $self=CORE::shift;my($n)=@_;
(do{$n->do_all_analysis();
{ package EmitSimpleP5; use vars '$current_emitter'};local $whiteboard::current_emitter = $self;
if((0)->Bool) {
GLOBAL::say($whiteboard::current_emitter)
};
{ package EmitSimpleP5; use vars '$in_package'};local $whiteboard::in_package = [];
{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 0;
{ package EmitSimpleP5; use vars '$compunit_footer'};local $whiteboard::compunit_footer = [];
my $code = (("package\ Main\;\
" . $self->prelude_for_entering_a_package()));
my $stmts = $self->e($n->statements());
($stmts = $stmts->map(sub {my($x)=@_;
(do{if((GLOBAL::defined($x))->Bool) {
(do{$x})
}else {
(do{""})
}})}));
my $foot = $whiteboard::compunit_footer->join("\;\
");
((($code . $stmts->join("\;\
")) . $foot) . "\;\
")})};
sub cb__Block{my $self=CORE::shift;my($n)=@_;
(do{{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 0;
my $stmts = $self->e($n->statements());
($stmts = $stmts->map(sub {my($x)=@_;
(do{if((GLOBAL::defined($x))->Bool) {
(do{$x})
}else {
(do{""})
}})}));
(("\(do\{" . $stmts->join("\;\
")) . "\}\)")})};
sub cb__Use{my $self=CORE::shift;my($n)=@_;
(do{my $module = $self->e($n->module_name());
my $expr = $self->e($n->expr());
if((($module eq "v6\-alpha"))->Bool) {
(do{""})
}elsif((($module eq "v6"))->Bool) {
(do{""})
}elsif((($module eq "lib"))->Bool) {
(do{my $name = $n->expr()->buf();
if(($self->compiler->hook_for_use_lib($name))->Bool) {
(do{""})
}else {
(do{""})
}})
}elsif(($self->compiler->hook_for_use($module, $expr))->Bool) {
(do{""})
}else {
(do{("use\ " . $module)})
}})};
sub cb__ClosureTrait{my $self=CORE::shift;my($n)=@_;
(do{{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 0;
((($n->kind() . "\{") . $self->e($n->block())) . "\}")})};
sub cb__PackageDecl{my $self=CORE::shift;my($n)=@_;
(do{my $in_package = [$whiteboard::in_package->flatten(), $n->name()];
my $name = $in_package->join("\:\:");
my $base = "use\ base\ \"Any\"\;";
if((($name eq "Any"))->Bool) {
(do{($base = "")})
};
if((($name eq "Object"))->Bool) {
(do{($base = "")})
};
if((($name eq "Junction"))->Bool) {
(do{($base = "")})
};
my $head = (("\
\{\ package\ " . $name) . "\;\
");
my $foot = "\
\}\
";
if(($self->using_Moose)->Bool) {
(do{($head = (($head . "use\ Moose\;") . "\ __PACKAGE__\-\>meta\-\>make_mutable\(\)\;\
"));
($foot = ("\;\
__PACKAGE__\-\>meta\-\>make_immutable\(\)\;\
" . "\
\}\
"))})
}else {
(do{})
};
($head = (($head . $base) . $self->prelude_for_entering_a_package()));
if(($n->block())->Bool) {
(do{{ package EmitSimpleP5; use vars '$in_package'};local $whiteboard::in_package = $in_package;
((($head . $self->e((do{my $__tmp__=($n->traits());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}}))->reverse()->join("\
")) . $self->e($n->block())) . $foot)})
}else {
(do{($whiteboard::in_package = $in_package);
$whiteboard::compunit_footer->unshift($foot);
(($head . $self->e((do{my $__tmp__=($n->traits());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}}))->reverse()->join("\
")) . "\;\
")})
}})};
sub cb__Trait{my $self=CORE::shift;my($n)=@_;
(do{if((((do{my $__tmp__=(($n->verb() eq "is"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($n->verb() eq "does"));no warnings "void";$__tmp__}})))->Bool) {
(do{my $pkgname = $whiteboard::in_package->join("\:\:");
my $name = (($whiteboard::in_package->splice(0, (-1))->join("\:\:") . "\:\:") . $self->e($n->expr()));
($name = $name->re_gsub("\^\:\:", ""));
(((("BEGIN\{unshift\(\@" . $pkgname) . "\:\:ISA\,\'") . $name) . "\'\)\;\}\
")})
}else {
(do{GLOBAL::say((("ERROR\:\ Emitting\ p5\ for\ Trait\ verb\ " . $n->verb()) . "\ has\ not\ been\ implemented\.\
"));
"\*\*\*Trait\*\*\*"})
}})};
sub do_VarDecl_has{my $self=CORE::shift;my($n,$default)=@_;
(do{my $name = $self->e($n->var()->name());
if(($self->using_Moose)->Bool) {
(do{my $dflt = $default;
if(($dflt)->Bool) {
(do{($dflt = (("\,\ default\ \=\>\ sub\{\ " . $default) . "\ \}"))})
};
(((("has\ \'" . $name) . "\'\ \=\>\ \(is\ \=\>\ \'rw\'") . $dflt) . "\)\;")})
}else {
(do{my $x = (((("\$_\[0\]\{" . "\'") . $name) . "\'") . "\}");
my $code = (((((("sub\ " . $name) . "\ \{\ if\(\@_\=\=2\)\{") . $x) . "\=\$_\[1\]\}else\{") . $x) . "\}\}");
if(($default)->Bool) {
(do{my $pkg = $whiteboard::in_package->join("\:\:");
($code = (($code . "\;\
") . $self->create_default_for($pkg, $name, $default)))})
};
$code})
}})};
sub cb__VarDecl{my $self=CORE::shift;my($n)=@_;
(do{{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 0;
if(((($n->scope() eq "has")))->Bool) {
(do{my $default = "";
my $default_expr = $self->e($n->default_expr());
if(($default_expr)->Bool) {
(do{($default = $default_expr)})
}else {
(do{if(((($n->var()->sigil() eq "\@")))->Bool) {
(do{($default = "\[\]")})
};
if(((($n->var()->sigil() eq "\%")))->Bool) {
(do{($default = "\{\}")})
}})
};
$self->do_VarDecl_has($n, $default)})
}else {
(do{my $default = "";
if(($n->default_expr())->Bool) {
(do{if((((do{my $__tmp__=((GLOBAL::not(($n->var()->sigil() eq "\$"))));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($n->default_expr()->isa("IRx1\:\:Apply"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(((do{my $__tmp__=(($n->default_expr()->function() eq "circumfix\:\(\ \)"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($n->default_expr()->function() eq "infix\:\,"));no warnings "void";$__tmp__}})));no warnings "void";$__tmp__}}})))->Bool) {
(do{my $pre = "";
my $post = "";
if(($n->is_array())->Bool) {
(do{($pre = "\[");
($post = "\]")})
};
if(($n->is_hash())->Bool) {
(do{($pre = "\{");
($post = "\}")})
};
{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 1;
($default = ((("\ \=\ " . $pre) . $self->e($n->default_expr())) . $post))})
}else {
(do{($default = ("\ \=\ " . $self->e($n->default_expr())))})
}})
}else {
(do{if(((($n->var()->sigil() eq "\@")))->Bool) {
(do{($default = "\ \=\ \[\]\;")})
};
if(((($n->var()->sigil() eq "\%")))->Bool) {
(do{($default = "\ \=\ \{\}\;")})
}})
};
if((($n->is_context()))->Bool) {
(do{my $var = $n->var();
my $nam = $self->e($n->var());
($nam = $nam->re_gsub_pat("\^\(\.\+\)\:\:", "\$1"));
((((((("\{package\ main\;\ use\ vars\ \'" . $nam) . "\'\}\;") . "local") . "\ ") . $self->e($n->var())) . $default))})
}elsif((($n->is_temp()))->Bool) {
(do{my $var = $n->var();
my $nam = $self->encode_varname($var->sigil(), $var->twigil(), $var->bare_name());
my $pkg = $n->notes()->postcircumfix__60_32_62('crnt_package');
((((((((("\{\ package\ " . $pkg) . "\;\ use\ vars\ \'") . $nam) . "\'\}\;") . "local") . "\ ") . $self->e($n->var())) . $default))})
}else {
(do{my $scope = $n->scope();
if((($scope eq "constant"))->Bool) {
(do{($scope = "my")})
};
((($scope . "\ ") . $self->e($n->var())) . $default)})
}})
}})};
sub multimethods_using_hack{my $self=CORE::shift;my($n,$name,$param_types)=@_;
(do{my $name = $self->e($n->name());
my $param_types = $n->multisig()->parameters()->map(sub {my($p)=@_;
(do{my $types = $self->e($p->type_constraints());
if(($types)->Bool) {
(do{if((($types->elems() != 1))->Bool) {
(do{GLOBAL::die("unsupported\:\ parameter\ with\ \!\=1\ type\ constraint\.")})
};
$types->postcircumfix__91_32_93(0)})
}else {
(do{GLOBAL::undef()})
}})});
my $type0 = $param_types->postcircumfix__91_32_93(0);
if((GLOBAL::not($type0))->Bool) {
(do{GLOBAL::die((("implementation\ limitation\:\ a\ multi\ method\'s\ first\ parameter\ must\ have\ a\ type\:\ " . $name) . "\
"))})
};
my $stem = (("_mmd__" . $name) . "__");
my $branch_name = ($stem . $type0);
my $setup_name = ("_reset" . $stem);
my $code = "";
($code = ((((((((((((($code . "\
\{\ my\ \$setup\ \=\ sub\ \{\
\ \ \ \ my\ \@meths\ \=\ __PACKAGE__\-\>meta\-\>compute_all_applicable_methods\;\
\ \ \ \ my\ \$h\ \=\ \{\}\;\
\ \ \ \ for\ my\ \$m\ \(\@meths\)\ \{\
\ \ \ \ \ \ next\ if\ not\ \$m\-\>\{name\}\ \=\~\ \/\^") . $stem) . "\(\\w\+\)\/\;\
\ \ \ \ \ \ my\ \$type\ \=\ \$1\;\
\ \ \ \ \ \ \$h\-\>\{\$type\}\ \=\ \$m\-\>\{code\}\{q\{\&\!body\}\}\;\
\ \ \ \ \}\;\
\ \ \ \ my\ \$s\ \=\ eval\ q\{sub\ \{\
\ \ \ \ \ \ my\ \$ref\ \=\ ref\(\$_\[1\]\)\ \|\|\ \$_\[1\]\-\>WHAT\;\
\ \ \ \ \ \ my\ \$f\ \=\ \$h\-\>\{\$ref\}\;\ goto\ \$f\ if\ \$f\;\
\ \ \ \ \ \ Carp\:\:croak\ \"multi\ method\ ") . $name) . "\ cant\ dispatch\ on\ type\:\ \"\.\$ref\.\"\\n\"\;\
\ \ \ \ \}\}\;\
\ \ \ \ die\ \$\@\ if\ \$\@\;\
\ \ \ \ eval\ q\{\{no\ warnings\;\ \*") . $name) . "\ \=\ \$s\;\}\}\;\
\ \ \ \ die\ \$\@\ if\ \$\@\;\
\ \ \ \ goto\ \&") . $name) . "\;\
\ \ \}\;\
\ \ eval\ q\{\{no\ warnings\;\ \*") . $setup_name) . "\ \=\ \$setup\;\}\}\;\
\ \ die\ \$\@\ if\ \$\@\;\
\ \ eval\ q\{\{no\ warnings\;\ \*") . $name) . "\ \=\ \$setup\;\}\}\;\
\ \ die\ \$\@\ if\ \$\@\;\
\}\;\
"));
(((((("sub\ " . $branch_name) . "\{my\ \$self\=CORE\:\:shift\;") . $self->e($n->multisig())) . $self->e($n->block())) . "\}") . $code)})};
sub multi_using_CM{my $self=CORE::shift;my($n,$is_method,$f_emitted)=@_;
(do{my $name = $self->e($n->name());
my $enc_name = $self->mangle_function_name($name);
my $param_types = $n->multisig()->parameters()->map(sub {my($p)=@_;
(do{my $types = $self->e($p->type_constraints());
if(($types)->Bool) {
(do{if((($types->elems() != 1))->Bool) {
(do{GLOBAL::die("unsupported\:\ parameter\ with\ \!\=1\ type\ constraint\.")})
};
$types->postcircumfix__91_32_93(0)})
}else {
(do{"Any"})
}})});
if(($is_method)->Bool) {
(do{$param_types->unshift("Any")})
};
my $sig = $param_types->map(sub {my($t)=@_;
(do{if((($t eq "Any"))->Bool) {
(do{"\*"})
}elsif((($t eq "Int"))->Bool) {
(do{"\#"})
}elsif((($t eq "Num"))->Bool) {
(do{"\#"})
}elsif((($t eq "Str"))->Bool) {
(do{"\$"})
}else {
(do{$t})
}})})->join("\ ");
((((((("Class\:\:Multimethods\:\:multimethod\ " . $enc_name) . "\ \=\>\ split\(\/\\s\+\/") . "\,\'") . $sig) . "\'\)\ \=\>\ ") . $f_emitted) . "\;")})};
sub cb__MethodDecl{my $self=CORE::shift;my($n)=@_;
(do{my $body;
if(((do{my $__tmp__=($n->traits());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($n->traits()->postcircumfix__91_32_93(0)->expr());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($n->traits()->postcircumfix__91_32_93(0)->expr() eq "p5"));no warnings "void";$__tmp__}}}))->Bool) {
(do{($body = $n->block()->statements()->postcircumfix__91_32_93(0)->buf())})
}else {
(do{($body = $self->e($n->block()))})
};
if(((do{my $__tmp__=($n->plurality());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($n->plurality() eq "multi"));no warnings "void";$__tmp__}}))->Bool) {
(do{my $ef = ((("sub\ \{my\ \$self\=CORE\:\:shift\;" . $self->e($n->multisig())) . $body) . "\}");
$self->multi_using_CM($n, 1, $ef)})
}else {
(do{my $enc_name = $self->mangle_function_name($self->e($n->name()));
((((("sub\ " . $enc_name) . "\{my\ \$self\=CORE\:\:shift\;") . $self->e($n->multisig())) . $body) . "\}")})
}})};
sub cb__SubDecl{my $self=CORE::shift;my($n)=@_;
(do{{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 0;
my $name = $n->name();
if(($name)->Bool) {
(do{($name = $self->e($name))})
}else {
(do{($name = "")})
};
my $sig = $n->multisig();
if(($sig)->Bool) {
(do{($sig = $self->e($sig))})
}else {
(do{($sig = "")})
};
my $body;
if(((do{my $__tmp__=($n->traits());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($n->traits()->postcircumfix__91_32_93(0)->expr());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($n->traits()->postcircumfix__91_32_93(0)->expr() eq "p5"));no warnings "void";$__tmp__}}}))->Bool) {
(do{($body = $n->block()->statements()->postcircumfix__91_32_93(0)->buf())})
}else {
(do{($body = $self->e($n->block()))})
};
if(((do{my $__tmp__=($n->plurality());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($n->plurality() eq "multi"));no warnings "void";$__tmp__}}))->Bool) {
(do{my $ef = ((("sub\ \{" . $sig) . $body) . "\}");
$self->multi_using_CM($n, 0, $ef)})
}else {
(do{my $enc_name = $self->mangle_function_name($name);
((((("sub\ " . $enc_name) . "\{") . $sig) . $body) . "\}")})
}})};
sub cb__Signature{my $self=CORE::shift;my($n)=@_;
(do{if(((($n->parameters()->elems() == 0)))->Bool) {
(do{""})
}else {
(do{{ package EmitSimpleP5; use vars '$signature_inits'};local $whiteboard::signature_inits = "";
my $pl = $self->e($n->parameters())->join("\,");
(((("my\(" . $pl) . "\)\=\@_\;") . $whiteboard::signature_inits) . "\
")})
}})};
sub cb__Parameter{my $self=CORE::shift;my($n)=@_;
(do{my $enc = $self->e($n->param_var());
if(((do{my $__tmp__=($n->quant());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($n->quant() eq "\*"));no warnings "void";$__tmp__}}))->Bool) {
(do{my $tmp = ("\@" . $n->param_var()->name());
($whiteboard::signature_inits = ((((($whiteboard::signature_inits . "\
my\ ") . $enc) . "\ \=\ \\") . $tmp) . "\;"));
$tmp})
}else {
(do{if(($n->default_expr())->Bool) {
(do{($whiteboard::signature_inits = ((((((($whiteboard::signature_inits . "\
if\(\!defined\(") . $enc) . "\)\)\{\ ") . $enc) . "\ \=\ ") . $self->e($n->default_expr())) . "\ \}"))})
};
$enc})
}})};
sub cb__ParamVar{my $self=CORE::shift;my($n)=@_;
(do{my $s = $n->sigil();
my $t = "";
my $dsn = $self->e($n->name());
$self->encode_varname($s, $t, $dsn)})};
sub cb__Call{my $self=CORE::shift;my($n)=@_;
(do{my $g;
{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 0;
my $method = $self->e($n->method());
my $meth = $self->mangle_function_name($method);
if(((($method eq "postcircumfix\:\<\ \>")))->Bool) {
(do{((((((($self->e($n->invocant()) . "\-\>") . $meth) . "\(") . "\'") . $self->e($n->capture())) . "\'") . "\)")})
}elsif(((($method eq "postcircumfix\:\(\ \)")))->Bool) {
(do{(((($self->e($n->invocant()) . "\-\>") . "\(") . $self->e($n->capture())) . "\)")})
}else {
(do{((((($self->e($n->invocant()) . "\-\>") . $meth) . "\(") . $self->e($n->capture())) . "\)")})
}})};
sub mangle_function_name{my $self=CORE::shift;my($name)=@_;
(do{$name->split("\(\?\<\!fix\)\:\:")->map(sub {my($s)=@_;
(do{my $s1 = $s->re_gsub_pat("\^\(\\w\+\)\:\(\?\!\:\)", "\$\{1\}_");
GLOBAL::mangle_name($s1)})})->join("\:\:")})};
sub cb__Apply{my $self=CORE::shift;my($n)=@_;
(do{my $g;
my $fun = $self->e($n->function());
if(($n->notes()->postcircumfix__60_32_62('lexical_bindings')->postcircumfix__123_32_125(("\&" . $fun)))->Bool) {
(do{my $fe = $self->mangle_function_name($fun);
return((((("" . $fe) . "\(") . $self->e($n->capture())) . "\)"))})
};
if((($g = $fun->re_groups("\^infix\:\(\.\+\)\$")))->Bool) {
(do{my $op = $g->postcircumfix__91_32_93(0);
my $args = $n->capture()->arguments();
if(((do{my $__tmp__=(($args->elems() == 1));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($args->postcircumfix__91_32_93(0)->isa("IRx1\:\:Apply"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($args->postcircumfix__91_32_93(0)->function() eq "infix\:\,"));no warnings "void";$__tmp__}}}))->Bool) {
(do{($args = $args->postcircumfix__91_32_93(0)->capture()->arguments())})
};
my $a = $self->e($args);
my $l = $a->postcircumfix__91_32_93(0);
my $r = $a->postcircumfix__91_32_93(1);
if(((do{my $__tmp__=($a->elems());if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(GLOBAL::prefix__33(GLOBAL::defined($a->postcircumfix__91_32_93((-1)))));no warnings "void";$__tmp__}}))->Bool) {
(do{$a->pop()})
};
if(((($op eq "\~")))->Bool) {
(do{my $s = $a->shift();
while(($a->elems())->Bool) {
(do{($s = (((("\(" . $s) . "\ \.\ ") . $a->shift()) . "\)"))})
};
return($s)})
};
if(((($op eq "\,")))->Bool) {
(do{my $s = $a->shift();
while(($a->elems())->Bool) {
(do{($s = (($s . "\,\ ") . $a->shift()))})
};
return($s)})
};
if(((($op eq "\=")))->Bool) {
(do{if(($args->postcircumfix__91_32_93(0)->isa("IRx1\:\:Var"))->Bool) {
(do{my $t = $args->postcircumfix__91_32_93(0)->twigil();
if((((do{my $__tmp__=($t);if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($t eq "\."));no warnings "void";$__tmp__}})))->Bool) {
(do{return(((($l . "\(") . $r) . "\)"))})
}})
};
if((($args->postcircumfix__91_32_93(0)->isa("IRx1\:\:Call")))->Bool) {
(do{if((($args->postcircumfix__91_32_93(0)->capture()->arguments()->elems() == 0))->Bool) {
(do{my $meth = $self->mangle_function_name($args->postcircumfix__91_32_93(0)->method());
return(((((($self->e($args->postcircumfix__91_32_93(0)->invocant()) . "\-\>") . $meth) . "\(") . $r) . "\)"))})
}else {
(do{my $call = $self->e($args->postcircumfix__91_32_93(0));
my $lvalue_call = $call->re_gsub("\\\)\$", (("\,\ " . $r) . "\)"));
if((($call eq $lvalue_call))->Bool) {
(do{GLOBAL::die("bug")})
};
return($lvalue_call)})
}})
}})
};
if(($op->re_matchp("\^\(\\\+\|\-\|\\\*\|\\\/\)\$"))->Bool) {
(do{my $s = $a->shift();
while(($a->elems())->Bool) {
(do{($s = (((((("\(" . $s) . "\ ") . $op) . "\ ") . $a->shift()) . "\)"))})
};
return($s)})
};
if(((do{my $__tmp__=($op->re_matchp("\^\(\!\=\|ne\|\=\|\=\~\)\$"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($a->elems() == 2));no warnings "void";$__tmp__}}))->Bool) {
(do{my $s = (((((("\(" . $a->shift()) . "\ ") . $op) . "\ ") . $a->shift()) . "\)");
return($s)})
};
if(((do{my $__tmp__=($op->re_matchp("\^\(\<\|\>\|\=\=\|lt\|gt\|eq\)\$"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($a->elems() == 2));no warnings "void";$__tmp__}}))->Bool) {
(do{my $s = (((((("\(" . $a->shift()) . "\ ") . $op) . "\ ") . $a->shift()) . "\)");
return($s)})
};
if(($op->re_matchp("\^\(\\\|\\\|\|\\\&\\\&\|and\|or\)\$"))->Bool) {
(do{my $argsf = $args->clone();
while(((do{my $__tmp__=(($argsf->postcircumfix__91_32_93(0)->WHAT() eq "IRx1\:\:Apply"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($argsf->postcircumfix__91_32_93(0)->function() eq $n->function()));no warnings "void";$__tmp__}}))->Bool) {
(do{$argsf->unshift($argsf->shift()->capture()->arguments()->flatten())})
};
my $a = $self->e($argsf);
my $s1 = "";
my $s2 = "";
my $stop = "";
if(((do{my $__tmp__=(($op eq "\&\&"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($op eq "and"));no warnings "void";$__tmp__}}))->Bool) {
(do{($stop = "\!")})
};
my $a_end = $a->pop();
while(($a->elems())->Bool) {
(do{($s1 = (((((($s1 . "\$__tmp__\=\(") . $a->shift()) . "\)\;if\(") . $stop) . "\$__tmp__\-\>Bool\)\{no\ warnings\ \"void\"\;\$__tmp__\}else\{")));
($s2 = ($s2 . "\}"))})
};
my $s = ((((((("\(do\{my\ " . $s1) . "\$__tmp__\=\(") . $a_end) . "\)\;no\ warnings\ \"void\"\;\$__tmp__") . $s2) . "\}\)"));
return($s)})
}})
}elsif((($g = $fun->re_groups("\^prefix\:\(\.\+\)\$")))->Bool) {
(do{my $op = $g->postcircumfix__91_32_93(0);
my $a = $self->e($n->capture()->arguments());
my $x = $a->postcircumfix__91_32_93(0);
if(($op->re_matchp("\^\(\-\)\$"))->Bool) {
(do{return((((("\(" . $op) . "") . $x) . "\)"))})
}})
}elsif((($g = $fun->re_groups("\^statement_prefix\:\(\.\+\)\$")))->Bool) {
(do{my $op = $g->postcircumfix__91_32_93(0);
if((($op eq "do"))->Bool) {
(do{return((("do\{" . $self->e($n->capture()->arguments()->postcircumfix__91_32_93(0))) . "\}"))})
}elsif((($op eq "try"))->Bool) {
(do{return((("eval\{" . $self->e($n->capture())) . "\}"))})
}elsif((($op eq "gather"))->Bool) {
(do{return((("GLOBAL\:\:gather" . $self->e($n->capture())) . ""))})
}else {
(do{GLOBAL::die(($fun . "\:\ unimplemented"))})
}})
}elsif((($g = $fun->re_groups("\^postfix\:\(\.\+\)\$")))->Bool) {
(do{my $op = $g->postcircumfix__91_32_93(0);
my $a = $self->e($n->capture()->arguments());
my $x = $a->postcircumfix__91_32_93(0);
if(($op->re_matchp("\^\(\\\+\\\+\)\$"))->Bool) {
(do{return((((("\(" . $x) . "") . $op) . "\)"))})
}})
}elsif((($g = $fun->re_groups("\^circumfix\:\(\.\+\)")))->Bool) {
(do{my $op = $g->postcircumfix__91_32_93(0);
if((($op eq "\<\ \>"))->Bool) {
(do{my $s = $n->capture()->arguments()->postcircumfix__91_32_93(0);
my $words = $s->split("\\s\+");
if((($words->elems() == 0))->Bool) {
(do{return("\[\]")})
}else {
(do{return((("\[\'" . $words->join("\'\,\'")) . "\'\]"))})
}})
}elsif(($op->re_matchp("\^\(\\\(\ \\\)\|\\\[\ \\\]\)\$"))->Bool) {
(do{my $arg = $self->e($n->capture());
return($op->re_gsub("\ ", $arg))})
}})
}elsif(((($fun eq "self")))->Bool) {
(do{return("\$self")})
}elsif(((($fun eq "next")))->Bool) {
(do{return("next")})
}elsif(((($fun eq "last")))->Bool) {
(do{return("last")})
}elsif(((($fun eq "return")))->Bool) {
(do{return((("return\(" . $self->e($n->capture())) . "\)"))})
}elsif((($fun->re_matchp("\^\\\$\\w\+\$")))->Bool) {
(do{return(((($fun . "\-\>\(") . $self->e($n->capture())) . "\)"))})
}elsif((($fun->re_matchp("\^sub\\s\*\{")))->Bool) {
(do{return((((("\(" . $fun) . "\)\-\>\(") . $self->e($n->capture())) . "\)"))})
}elsif((($fun eq "eval"))->Bool) {
(do{my $env = "sub\{my\$s\=eval\(\$_\[0\]\)\;Carp\:\:carp\(\$\@\)if\$\@\;\$s\}";
return((((((("GLOBAL\:\:" . $fun) . "\(") . $self->e($n->capture())) . "\,") . $env) . "\)"))})
}elsif((($fun eq "_inline_p5"))->Bool) {
(do{return($n->capture()->arguments()->postcircumfix__91_32_93(0)->buf())})
};
if(($fun->re_matchp("\^\\w"))->Bool) {
(do{my $fe = $self->mangle_function_name($fun);
return((((("GLOBAL\:\:" . $fe) . "\(") . $self->e($n->capture())) . "\)"))})
}else {
(do{return(((($fun . "\(") . $self->e($n->capture())) . "\)"))})
}})};
sub cb__Capture{my $self=CORE::shift;my($n)=@_;
(do{my $a = $self->e((do{my $__tmp__=($n->arguments());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}}))->join("\,");
if(($n->invocant())->Bool) {
(do{my $inv = $self->e($n->invocant());
if(($a)->Bool) {
(do{(($inv . "\,\ ") . $a)})
}else {
(do{$inv})
}})
}else {
(do{$a})
}})};
sub cb__For{my $self=CORE::shift;my($n)=@_;
(do{my $push = "";
if((($n->expr()->WHAT() ne "IRx1\:\:Apply"))->Bool) {
(do{($push = "\-\>flatten")})
};
my $pull = "";
if((($n->block()->WHAT() eq "IRx1\:\:SubDecl"))->Bool) {
(do{($pull = "\-\>\(\$_\)")})
};
((((((("for\(\(" . $self->e($n->expr())) . "\)") . $push) . "\)\{\
") . $self->e($n->block())) . $pull) . "\
\}")})};
sub cb__Loop{my $self=CORE::shift;my($n)=@_;
(do{(((("while\(\(" . $self->e($n->pretest())) . "\)\-\>Bool\)\ \{\
") . $self->e($n->block())) . "\
\}")})};
sub cb__Cond{my $self=CORE::shift;my($n)=@_;
(do{my $els = "";
if(($n->default())->Bool) {
(do{($els = (("else\ \{\
" . $self->e($n->default())) . "\
\}"))})
};
my $clauses = $self->e($n->clauses());
my $first = $clauses->shift();
my $first_test = $first->postcircumfix__91_32_93(0);
($first_test = (("\(" . $first_test) . "\)\-\>Bool"));
if(($n->invert_first_test())->Bool) {
(do{($first_test = (("not\(" . $first_test) . "\)"))})
};
((((((("if\(" . $first_test) . "\)\ \{\
") . $first->postcircumfix__91_32_93(1)) . "\
\}") . $clauses->map(sub {my($e)=@_;
(do{(((("elsif\(\(" . $e->postcircumfix__91_32_93(0)) . "\)\-\>Bool\)\ \{\
") . $e->postcircumfix__91_32_93(1)) . "\
\}")})})->join("")) . $els))})};
sub cb__Given{my $self=CORE::shift;my($n)=@_;
(do{my $expr = $self->e($n->expr());
my $stmts = $self->e($n->block()->statements())->map(sub {my($s)=@_;
(do{if(($s->re_matchp("\\\)\\z"))->Bool) {
(do{($s . "\;")})
}else {
(do{$s})
}})})->join("\
");
(((((("\(do\{\ local\ \$_\ \=\ " . $expr) . "\;\
") . "if\(0\)\{\}") . "\
") . $stmts) . "\
\}\)")})};
sub cb__When{my $self=CORE::shift;my($n)=@_;
(do{my $expr = $self->e($n->expr());
my $test;
if((GLOBAL::not(GLOBAL::defined($expr)))->Bool) {
(do{($test = "1")})
}elsif(($n->expr()->is_whatever())->Bool) {
(do{($test = "1")})
}else {
(do{($test = (("\$_\ eq\ " . $expr) . ""))})
};
my $block = $self->e($n->block());
(((("elsif\(" . $test) . "\)\ \{") . $block) . "\}")})};
sub encode_varname{my $self=CORE::shift;my($s,$t,$dsn)=@_;
(do{my $env = "";
my $pre = "";
if((($t eq "\+"))->Bool) {
(do{($env = "x")})
};
if(((do{my $__tmp__=(($s eq "\$"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($env eq "x"));no warnings "void";$__tmp__}}))->Bool) {
(do{($pre = "s_")})
};
if((($s eq "\@"))->Bool) {
(do{($pre = "a_")})
};
if((($s eq "\%"))->Bool) {
(do{($pre = "h_")})
};
my $mn = $dsn->split("\:\:")->map(sub {my($nam)=@_;
(do{GLOBAL::mangle_name($nam)})})->join("\:\:");
my $name = (($env . $pre) . $mn);
if(((($t eq "\.")))->Bool) {
(do{("\$self\-\>" . $name)})
}elsif(((($t eq "\+")))->Bool) {
(do{($name = $name->re_gsub("\:\:", "__"));
(("\$" . "\:\:") . $name)})
}elsif(((($t eq "\*")))->Bool) {
(do{($name = $name->re_gsub("\:\:", "__"));
(("\$" . "GLOBAL\:\:") . $name)})
}else {
(do{("\$" . $name)})
}})};
sub cb__Var_selective_override{my $self=CORE::shift;my($n)=@_;
(do{GLOBAL::undef()})};
sub cb__Var{my $self=CORE::shift;my($n)=@_;
(do{my $override = $self->cb__Var_selective_override($n);
if((GLOBAL::defined($override))->Bool) {
(do{return($override)})
};
my $s = $n->sigil();
my $t = (do{my $__tmp__=($n->twigil());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=("");no warnings "void";$__tmp__}});
if(($n->is_context())->Bool) {
(do{($t = "\+")})
};
my $dsn = $self->e($n->name());
my $v = (($s . $t) . $dsn);
if(((do{my $__tmp__=(($v eq "\$\?PACKAGE"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($v eq "\$\?MODULE"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($v eq "\$\?CLASS"));no warnings "void";$__tmp__}}}))->Bool) {
(do{my $pkgname = $whiteboard::in_package->join("\:\:");
($pkgname = (do{my $__tmp__=($pkgname);if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=("Main");no warnings "void";$__tmp__}}));
(("\'" . $pkgname) . "\'")})
}elsif((($v eq "\$\?FILE"))->Bool) {
(do{(("\'" . $self->filename) . "\'")})
}elsif((($v eq "\$\?LINE"))->Bool) {
(do{"0"})
}elsif((($v eq "\$\?PERLVER"))->Bool) {
(do{(((("\'elf\ \/\ " . GLOBAL::primitive_runtime_version()) . "\ \/\ ") . $self->WHAT) . "\'")})
}elsif((($v eq "\$¢"))->Bool) {
(do{$self->encode_varname($s, $t, "GLOBAL\:\:_cursor")})
}else {
(do{$self->encode_varname($s, $t, $dsn)})
}})};
sub cb__NumInt{my $self=CORE::shift;my($n)=@_;
(do{$self->e($n->text())})};
sub cb__Hash{my $self=CORE::shift;my($n)=@_;
(do{{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 1;
(("\{" . $self->e((do{my $__tmp__=($n->hash());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=([]);no warnings "void";$__tmp__}}))->join("\,")) . "\}")})};
sub cb__Buf{my $self=CORE::shift;my($n)=@_;
(do{my $s = $n->buf();
(("\"" . GLOBAL::quotemeta($s)) . "\"")})};
sub cb__Rx{my $self=CORE::shift;my($n)=@_;
(do{my $pat = (do{my $__tmp__=($n->pat());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=("");no warnings "void";$__tmp__}});
(("qr\/" . $pat) . "\/")})};
sub cb__Pair{my $self=CORE::shift;my($n)=@_;
(do{if(($whiteboard::emit_pairs_inline)->Bool) {
(do{{ package EmitSimpleP5; use vars '$emit_pairs_inline'};local $whiteboard::emit_pairs_inline = 0;
(((("\(" . $self->e($n->key())) . "\ \=\>\ ") . $self->e($n->value())) . "\)")})
}else {
(do{(((("Pair\-\>new\(\'key\'\," . $self->e($n->key())) . "\ \=\>\ \'value\'\,") . $self->e($n->value())) . "\)")})
}})}})
}
;
if((GLOBAL::not($GLOBAL::emitter0))->Bool) {
(do{($GLOBAL::emitter0 = EmitSimpleP5->new())})
};
($GLOBAL::emitter1 = EmitSimpleP5->new());

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;
sub header{use Math::Trig qw();};
header();

{ package Num;
use base "Any";(do{sub pi{Math::Trig::pi();}})
}
;
($GLOBAL::PID = (sub {$$})->());
($GLOBAL::OS = (sub {$^O})->());
($GLOBAL::OSVER = (sub {`/bin/uname -a`})->());
($GLOBAL::EXECUTABLE_NAME = (sub {$0})->());
sub not_used_only_once{(do{[$GLOBAL::OS, $GLOBAL::OSVER, $GLOBAL::EXECUTABLE_NAME]})};

{ package GLOBAL;
use base "Any";(do{sub primitive_runtime_version{CORE::sprintf "perl %vd", $^V}})
}
;

{ package Any;
(do{sub perl{my $self=CORE::shift;(do{($self->WHAT() . "\.new\(\!\!\!\)")})}})
}
;

{ package STRING;
use base "Any";(do{sub perl{my $self=CORE::shift;q{"} . CORE::quotemeta($self) . q{"}}})
}
;

{ package INTEGER;
use base "Any";(do{sub perl{my $self=CORE::shift;(do{("" . $self)})}})
}
;

{ package FLOAT;
use base "Any";(do{sub perl{my $self=CORE::shift;(do{("" . $self)})}})
}
;

{ package ARRAY;
use base "Any";(do{sub perl{my $self=CORE::shift;(do{(("\[" . $self->map(sub {my($e)=@_;
(do{$e->perl()})})->join("\,")) . "\]")})}})
}
;

{ package HASH;
use base "Any";(do{sub perl{my $self=CORE::shift;(do{(("\{" . $self->keys()->map(sub {my($k)=@_;
(do{(($k->perl() . "\ \=\>\ ") . $self->postcircumfix__123_32_125($k)->perl())})})->join("\,\ ")) . "\}")})}})
}
;

{ package UNDEF;
use base "Any";(do{sub Str{my $self=CORE::shift;(do{""})}})
}
;

{ package Regexp;
use base "Any";(do{sub Str{my $self=CORE::shift;(do{("" . $self)})}})
}
;

{ package Math;
use base "Any";(do{sub rand{my $self=CORE::shift;my($max)=@_;
CORE::rand($max||1)};
sub srand{my $self=CORE::shift;my($seed)=@_;
CORE::srand($seed)}})
}
;

{ package IO;
use base "Any";(do{sub mkdir{my $self=CORE::shift;my($dirname)=@_;
CORE::mkdir($dirname)};
sub rmdir{my $self=CORE::shift;my($dirname)=@_;
CORE::rmdir($dirname)}})
}
;

{ package GLOBAL;
use base "Any";(do{sub rmdir{my($dirname)=@_;
CORE::rmdir($dirname)}})
}
;

{ package GLOBAL;
use base "Any";(do{Class::Multimethods::multimethod prefix__63 => split(/\s+/,'*') => sub {my($a)=@_;
(do{$a->Bool()})};;
Class::Multimethods::multimethod prefix__33 => split(/\s+/,'*') => sub {my($a)=@_;
(do{GLOBAL::not($a)})};;
Class::Multimethods::multimethod prefix__43 => split(/\s+/,'*') => sub {my($a)=@_;
(do{$a->Num()})};;
Class::Multimethods::multimethod prefix__43 => split(/\s+/,'#') => sub {my($a)=@_;
(do{$a})};;
Class::Multimethods::multimethod prefix__43 => split(/\s+/,'Array') => sub {my($a)=@_;
(do{$a->elems()})};;
Class::Multimethods::multimethod prefix__126 => split(/\s+/,'*') => sub {my($a)=@_;
(do{$a->Str()})};;
Class::Multimethods::multimethod prefix__126 => split(/\s+/,'$') => sub {my($a)=@_;
(do{$a})};;
Class::Multimethods::multimethod prefix__45 => split(/\s+/,'#') => sub {my($a)=@_;
(0-$a)};;
Class::Multimethods::multimethod prefix__43_43 => split(/\s+/,'#') => sub {my($a)=@_;
++$_[0]};;
Class::Multimethods::multimethod prefix__45_45 => split(/\s+/,'#') => sub {my($a)=@_;
--$_[0]};;
Class::Multimethods::multimethod postfix__43_43 => split(/\s+/,'#') => sub {my($a)=@_;
$_[0]++};;
Class::Multimethods::multimethod postfix__45_45 => split(/\s+/,'#') => sub {my($a)=@_;
$_[0]--};;
Class::Multimethods::multimethod postfix_i => split(/\s+/,'#') => sub {my($a)=@_;
(do{$a})};;
Class::Multimethods::multimethod infix__43 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a + $b)};;
Class::Multimethods::multimethod infix__42 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a * $b)};;
Class::Multimethods::multimethod infix__42_42 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a ** $b)};;
Class::Multimethods::multimethod infix_and => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a and $b)};;
Class::Multimethods::multimethod infix_or => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a or $b)};;
Class::Multimethods::multimethod infix_eq => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a eq $b)};;
Class::Multimethods::multimethod infix_ne => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a ne $b)};;
Class::Multimethods::multimethod infix__33_61 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a != $b)};;
Class::Multimethods::multimethod infix__61_61 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a == $b)};;
Class::Multimethods::multimethod infix__60 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a < $b)};;
Class::Multimethods::multimethod infix__62 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a > $b)};;
Class::Multimethods::multimethod infix__60_61 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a <= $b)};;
Class::Multimethods::multimethod infix__62_61 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a >= $b)};;
Class::Multimethods::multimethod infix__60_61_62 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a <=> $b)};;
Class::Multimethods::multimethod infix_ge => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a ge $b)};;
Class::Multimethods::multimethod infix_gt => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a gt $b)};;
Class::Multimethods::multimethod infix_le => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a le $b)};;
Class::Multimethods::multimethod infix_lt => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a lt $b)};;
Class::Multimethods::multimethod infix_cmp => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a cmp $b)};;
Class::Multimethods::multimethod infix_xor => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a xor $b)};;
Class::Multimethods::multimethod infix__61_61_61 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
(do{GLOBAL::undef()})};;
Class::Multimethods::multimethod infix__61_58_61 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
(do{GLOBAL::undef()})};;
Class::Multimethods::multimethod infix__94 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a ^ $b)};;
Class::Multimethods::multimethod infix__46_46 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a .. $b)};;
Class::Multimethods::multimethod infix__94_46_46 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a .. $b)};;
Class::Multimethods::multimethod infix__46_46_94 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a .. $b)};;
Class::Multimethods::multimethod infix__94_46_46_94 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a .. $b)};;
Class::Multimethods::multimethod infix__62_62 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a >> $b)};;
Class::Multimethods::multimethod infix__60_60 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a << $b)};;
Class::Multimethods::multimethod infix__124 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a | $b)};;
Class::Multimethods::multimethod infix__124_124 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a || $b)};;
Class::Multimethods::multimethod infix__38 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a & $b)};;
Class::Multimethods::multimethod infix__38_38 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a && $b)};;
Class::Multimethods::multimethod infix_58_58_61 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a = $b)};;
Class::Multimethods::multimethod infix__33_126 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
(do{GLOBAL::undef()})};;
Class::Multimethods::multimethod infix__126_126 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
(do{GLOBAL::undef()})};;
Class::Multimethods::multimethod infix__126_126 => split(/\s+/,'$ Regexp') => sub {my($a,$b)=@_;
$a =~ $b};;
Class::Multimethods::multimethod infix_x => split(/\s+/,'* *') => sub {my($a,$b)=@_;
($a x $b)};;
Class::Multimethods::multimethod infix__47_47 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
defined($a) ? $a : $b};;
Class::Multimethods::multimethod infix__43_38 => split(/\s+/,'* *') => sub {my($a,$b)=@_;
(do{infix__43_38($a->Int(),$b->Int())})};;
Class::Multimethods::multimethod infix__43_38 => split(/\s+/,'# #') => sub {my($a,$b)=@_;
$a & $b};})
}
;

{ package GLOBAL;
use base "Any";(do{sub elf_main{(do{Program->new()->main($GLOBAL::a_ARGS)})}})
}
;

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package Parser;
use base "Any";(do{sub is_for_active_runtime { if(@_==2){$_[0]{'is_for_active_runtime'}=$_[1]}else{$_[0]{'is_for_active_runtime'}}};
sub parse{my $self=CORE::shift;my($p6_code,$claim_as_filename)=@_;
(do{my $stem = ("deleteme" . $GLOBAL::PID);
my $input = ($stem . "\.p6");
my $output = ($stem . "\.dump");
GLOBAL::unslurp($p6_code, $input);
my $parser = $self->parser_name();
my $msg = (("Parse\ error\ in\:\ " . $claim_as_filename) . "\
");
my $cmd = (((((((((($parser . "\ \-\-error\-message\=\'") . $msg) . "\'\ \-q\ ") . "\-\-format\=") . GLOBAL::parser_format()) . "\ ") . $input) . "\ \>\ ") . $output));
(do{my $__tmp__=((GLOBAL::system($cmd) == 0));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(GLOBAL::die("Parse\ failed\.\
"));no warnings "void";$__tmp__}});
my $dump5 = GLOBAL::slurp($output);
my $tree = GLOBAL::fastundump($dump5);
GLOBAL::unlink($input, $output);
$tree})};
sub parser_name{my $self=CORE::shift;(do{GLOBAL::parser_name()})}})
}
;
if((GLOBAL::not($GLOBAL::parser0))->Bool) {
(do{($GLOBAL::parser0 = Parser->new("is_for_active_runtime", 1))})
};
($GLOBAL::parser1 = Parser->new());

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package Compiler;
use base "Any";(do{sub is_for_active_runtime { if(@_==2){$_[0]{'is_for_active_runtime'}=$_[1]}else{$_[0]{'is_for_active_runtime'}}};
sub eval_perl6{my $self=CORE::shift;my($code,$env)=@_;
(do{$self->eval_fragment($code, "\-e", 0, $env)})};
sub eval_file{my $self=CORE::shift;my($file)=@_;
(do{$self->eval_fragment(GLOBAL::slurp($file), $file, 0, GLOBAL::undef())})};
sub eval_fragment{my $self=CORE::shift;my($code,$filename,$verbose,$env)=@_;
(do{my $p5 = $self->compile_fragment($code, $filename, $verbose);
GLOBAL::eval_runtime_code($p5, $env)})};
sub compile_fragment_cache_get{my $self=CORE::shift;my($code,$filename)=@_;
(do{GLOBAL::undef()})};
sub compile_fragment_cache_set{my $self=CORE::shift;my($code,$filename,$value)=@_;
(do{})};
sub dump_IRx1{my($ast)=@_;
(do{if(($ast->isa("IRx1\:\:Base"))->Bool) {
(do{my $field_names = $ast->field_names();
my $field_values = $ast->field_values();
my $i = 0;
my $str = ($ast->node_name() . "\(");
while((($i < $field_names->elems()))->Bool) {
(do{if((($i != 0))->Bool) {
(do{($str = ($str . "\,"))})
};
($str = ((($str . $field_names->postcircumfix__91_32_93($i)) . "\=\>") . dump_IRx1($field_values->postcircumfix__91_32_93($i))));
($i++)})
};
($str = ($str . "\)"));
return($str)})
}elsif((($ast->WHAT() eq "Array"))->Bool) {
(do{return((("\[" . $ast->map(sub {my($e)=@_;
(do{dump_IRx1($e)})})->join("\,")) . "\]"))})
}elsif((($ast->WHAT() eq "Hash"))->Bool) {
(do{return((("\{" . $ast->kv(sub {my($e)=@_;
(do{dump_IRx1($e)})})->join("\,")) . "\}"))})
}elsif((($ast->WHAT() eq "Str"))->Bool) {
(do{return((("\'" . $ast) . "\'"))})
}elsif((($ast->WHAT() eq "Undef"))->Bool) {
(do{return("undef")})
}else {
(do{return($ast)})
}})};
sub compile_fragment{my $self=CORE::shift;my($code,$filename,$verbose)=@_;
(do{my $tree;
my $cached = $self->compile_fragment_cache_get($code, $filename);
if(($cached)->Bool) {
(do{$cached})
}else {
(do{{ package Compiler; use vars '$irbuilder'};local $main::irbuilder;
if(($self->is_for_active_runtime)->Bool) {
(do{($tree = $GLOBAL::parser0->parse($code, $filename));
($main::irbuilder = $GLOBAL::ast2ir_0)})
}else {
(do{($tree = $GLOBAL::parser1->parse($code, $filename));
($main::irbuilder = $GLOBAL::ast2ir_1)})
};
if(($verbose)->Bool) {
(do{GLOBAL::say($tree->match_describe())})
};
my $ir = $tree->make_ir_from_Match_tree();
if(($verbose)->Bool) {
(do{GLOBAL::say($GLOBAL::emitter1->tidy(dump_IRx1($ir)))})
};
my $p5;
if(($self->is_for_active_runtime)->Bool) {
(do{($p5 = (($GLOBAL::emitter0->prelude_lexical() . $ir->callback($GLOBAL::emitter0->new_emitter("compiler", $self, "filename", $filename)))))})
}else {
(do{($p5 = (($GLOBAL::emitter1->prelude_lexical() . $ir->callback($GLOBAL::emitter1->new_emitter("compiler", $self, "filename", $filename)))))})
};
if(($verbose)->Bool) {
(do{if(($self->is_for_active_runtime)->Bool) {
(do{GLOBAL::say($GLOBAL::emitter0->tidy($p5))})
}else {
(do{GLOBAL::say($GLOBAL::emitter1->tidy($p5))})
}})
};
$self->compile_fragment_cache_set($code, $filename, $p5);
$p5})
}})};
sub todo { if(@_==2){$_[0]{'todo'}=$_[1]}else{$_[0]{'todo'}}};
$Object::DEFAULTS{Compiler}{'todo'} = sub {[]};;
sub compile_executable{my $self=CORE::shift;my($sources,$output_file)=@_;
(do{$self->todo([]);
my $p5 = ($self->prelude() . "\
");
for(($sources)->flatten){
(do{my $code = $_->postcircumfix__91_32_93(0);
my $file = $_->postcircumfix__91_32_93(1);
my $verbose = $_->postcircumfix__91_32_93(2);
my $more_p5 = $self->compile_fragment($code, $file, $verbose);
while((($self->todo->elems() > 0))->Bool) {
(do{my $filename = $self->todo->shift();
my $module_p5 = $self->compile_fragment(GLOBAL::slurp($filename), $filename, $verbose);
($p5 = (($p5 . $module_p5) . "\
\;\
"))})
};
($p5 = (($p5 . $more_p5) . "\
\;\
"))})
};
if((($output_file eq "\-"))->Bool) {
(do{GLOBAL::say($p5)})
}else {
(do{GLOBAL::unslurp($p5, $output_file);
GLOBAL::chmod_exe($output_file)})
};
[$output_file]})};
sub prelude{my $self=CORE::shift;(do{if(($self->is_for_active_runtime)->Bool) {
(do{$GLOBAL::emitter0->prelude()})
}else {
(do{$GLOBAL::emitter1->prelude()})
}})};
sub hook_for_use_lib{my $self=CORE::shift;my($expr)=@_;
(do{$GLOBAL::a_INC->unshift($expr);
if(($self->is_for_active_runtime)->Bool) {
(do{1})
}else {
(do{0})
}})};
sub hook_for_use{my $self=CORE::shift;my($module,$expr)=@_;
(do{if(($self->is_for_active_runtime)->Bool) {
(do{GLOBAL::module_require($module);
GLOBAL::import($module, $expr)})
}else {
(do{my $filename = (do{my $__tmp__=(GLOBAL::find_required_module($module));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(GLOBAL::die((((("Didnt\ find\ " . $module) . "\ in\ \(\ ") . $GLOBAL::a_INC->join("\ ")) . "\ \)\.\
")));no warnings "void";$__tmp__}});
$self->todo->push($filename)})
};
1})}})
}
;
if((GLOBAL::not($GLOBAL::compiler0))->Bool) {
(do{($GLOBAL::compiler0 = Compiler->new("is_for_active_runtime", 1))})
};
($GLOBAL::compiler1 = Compiler->new());

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;

{ package Program;
use base "Any";(do{sub print_usage_and_die{my $self=CORE::shift;(do{GLOBAL::say("\
Usage\:\ \[\-v\]\ \[\-s0\|\-s\|\-x\|\-xr\]\ \[\-o\ OUTPUT_FILE\]\ \[\-I\ dir\]\
\ \ \ \ \ \ \ \ \ \[\ P6_FILE\ \|\ \-e\ P6_CODE\ \]\+\ \[\ \-\-\ ARGS\*\ \]\
\
Unlike\ p5\,\ multiple\ P6_FILE\'s\ and\ \-e\ P6_CODE\'s\ and\ can\ be\ mixed\.\
Use\ \-\-\ to\ stop\.\
\
\ \-v\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ verbose\.\
\
\ default\ \ Compile0\ and\ eval\.\
\ \-r1\ \ \ \ \ \ Compile1\ and\ eval\.\
\ \-s0\ \ \ \ \ \ Compile0\ and\ show\ the\ resulting\ framgent\.\
\ \-s\ \ \ \ \ \ \ Compile1\ and\ show\ the\ resulting\ fragment\.\
\ \-x\ \ \ \ \ \ \ Compile1\ to\ an\ executable\ form\.\
\ \-xr\ \ \ \ \ \ Compile1\ to\ an\ executable\ form\,\ and\ run\.\
\
One\ can\ also\ do\
\ \[\ P6_FILE\ \|\ \-e\ P6_CODE\ \]\+\ \ these\ are\ evaled\,\
\ \-x\
\ \[\ P6_FILE\ \|\ \-e\ P6_CODE\ \]\+\ \ these\ are\ compiled\.\
\
");
GLOBAL::exit(2)})};
sub main{my $self=CORE::shift;my($args)=@_;
(do{if((($args->elems() == 0))->Bool) {
(do{$self->print_usage_and_die()})
};
my $verbose;
my $mode = "r";
my $output_file;
my $incs = [];
my $output = sub {my($text)=@_;
(do{if(($output_file)->Bool) {
(do{GLOBAL::unslurp($text, $output_file)})
}else {
(do{GLOBAL::say($text)})
}})};
my $sources = [];
my $handle = sub {my($filename,$code)=@_;
(do{if((($mode eq "r"))->Bool) {
(do{$GLOBAL::compiler0->eval_fragment($code, $filename, $verbose, GLOBAL::undef())})
}elsif((($mode eq "r1"))->Bool) {
(do{$GLOBAL::compiler1->eval_fragment($code, $filename, $verbose, GLOBAL::undef())})
}elsif(((do{my $__tmp__=(($mode eq "s0"));if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($mode eq "s1"));no warnings "void";$__tmp__}}))->Bool) {
(do{my $comp;
if((($mode eq "s0"))->Bool) {
(do{($comp = $GLOBAL::compiler0)})
}else {
(do{($comp = $GLOBAL::compiler1)})
};
$output->($comp->compile_fragment($code, $filename, $verbose))})
}else {
(do{$sources->push([$code, $filename, $verbose])})
}})};
my $at_end = sub {(do{if(((do{my $__tmp__=(($mode eq "x"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($sources->elems() != 0));no warnings "void";$__tmp__}}))->Bool) {
(do{if((GLOBAL::not($output_file))->Bool) {
(do{($output_file = "\-")})
};
my $exec_args = $GLOBAL::compiler1->compile_executable($sources, $output_file)})
}elsif(((do{my $__tmp__=(($mode eq "xr"));if(!$__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=(($sources->elems() != 0));no warnings "void";$__tmp__}}))->Bool) {
(do{if((GLOBAL::not($output_file))->Bool) {
(do{($output_file = "\.\/deleteme_exe")})
};
my $exec_args = $GLOBAL::compiler1->compile_executable($sources, $output_file);
GLOBAL::say(((("\#\ " . $exec_args->join("\ ")) . "\ ") . $args->join("\ ")));
GLOBAL::exec($exec_args->flatten(), $args->flatten())})
}})};
while(($args->elems())->Bool) {
(do{my $arg = $args->shift();
if((($arg eq "\-v"))->Bool) {
(do{($verbose = 1)})
}elsif((($arg eq "\-r1"))->Bool) {
(do{($mode = "r1")})
}elsif((($arg eq "\-s0"))->Bool) {
(do{($mode = "s0")})
}elsif((($arg eq "\-s"))->Bool) {
(do{($mode = "s1")})
}elsif((($arg eq "\-x"))->Bool) {
(do{($mode = "x")})
}elsif((($arg eq "\-xr"))->Bool) {
(do{($mode = "xr")})
}elsif((($arg eq "\-o"))->Bool) {
(do{($output_file = (do{my $__tmp__=($args->shift());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($self->print_usage_and_die());no warnings "void";$__tmp__}}))})
}elsif((($arg eq "\-e"))->Bool) {
(do{$GLOBAL::a_INC->unshift($incs->flatten());
($incs = []);
my $p6_code = (do{my $__tmp__=($args->shift());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($self->print_usage_and_die());no warnings "void";$__tmp__}});
$handle->("\-e", $p6_code)})
}elsif((GLOBAL::file_exists($arg))->Bool) {
(do{$GLOBAL::a_INC->unshift($incs->flatten());
($incs = []);
$handle->($arg, GLOBAL::slurp($arg))})
}elsif((($arg eq "\-I"))->Bool) {
(do{my $dir = (do{my $__tmp__=($args->shift());if($__tmp__->Bool){no warnings "void";$__tmp__}else{$__tmp__=($self->print_usage_and_die());no warnings "void";$__tmp__}});
$incs->push($dir)})
}elsif((($arg eq "\-\-"))->Bool) {
(do{last})
}else {
(do{GLOBAL::say((("ERROR\:\ Not\ a\ file\ or\ command\-line\ option\:\ " . $arg) . "\
"));
$self->print_usage_and_die()})
}})
};
$at_end->()})}})
}
;

;
use autobox ARRAY => 'ARRAY', HASH => 'HASH', CODE => 'CODE', INTEGER => 'INTEGER', FLOAT => 'FLOAT', STRING => 'STRING', UNDEF => 'UNDEF';  use encoding 'utf8';
      package Main;
;
GLOBAL::elf_main();

;
