This file contains miscellaneous questions about design+spec
that Pm has come up with that are awaiting answers from TimToady
and/or others.  We'll likely record the answers here as well.

Unanswered questions:

==========

Answered questions:


Pm-1:  In STD.pm, what is the semantic or key difference between <noun>
    and <term>?

None, they are now unified under <term>

Pm-2:  Are calls to subrules in other grammars still valid as
    C<<  / abc <OtherGrammar::xyz> def / >> ?  If so, then 
    for the invocation of the subrule, do we construct a new
    cursor of type OtherGrammar and invoke the 'xyz' method on it?
    (Pm's preference is "yes" and "yes", but want confirmation.)

Yes, and yes.  That's essentially what STD is already doing for
Regexen and such.

Pm-3:  When we generate a metaop, where does it live?  Lexical?
    Package?  If package, then what package?

Good question, if CORE is immutable, we can't add to it.  Probably
UNIT, though that might prevent sharing of common definitions
among different compilation units.  On the other hand, being sure
you're based on the same underlying semantics is difficult anyway
without a lot of lifting, so maybe UNIT is good enough for now.

Pm-4:  The C<.ast> method on a Match object returns the matched
    text if no abstract object has been set.  Is there (or should
    there be) a method to determine if an abstract object has been
    set?  (Currently I'm using C<.peek_ast> in nqp-rx for this.)

Uh, surely .ast is false if there isn't one.

[S05:2434 r28936 currently says that .ast returns the matched text,
I expect this to change shortly.  --Pm]

Pm-5:  How "read-only" are subroutine parameters?  For example, given
    a subroutine like  C<<  sub abc($x) { ... }  >>, I know we can't
    assign to C<$x>, but can it be rebound using &infix:<:=> in the 
    body of the sub?

That seems okay to me, since the intent is to not modify the
passed in object, and the rebinding effectively anonymizes the
argument that was bound.

Pm-6:  Is there a syntax that allows a (trusted) routine to access
    the private attributes of another object without going through
    an accessor?  For example, if object $b has a private attribute 
    of "$!xyz", is there a syntax for me to get to that attribute?

See r28932.

[Answer:  as of r28932, C<< $b!SomeClass::xyz >>.  --Pm]

Pm-7:  S05 says that a match's reduction object is given by the
    C<:action> parameter, STD.pm's initparse has C<:actions> and
    $*ACTIONS.  Should we pick one and stick with it?  PGE and 
    Rakudo have traditionally used C<:action> -- if there's to 
    be a change, now would be a good time for it.  :-)
    (After looking at the way I typically use it, I'm leaning
    towards the plural form. --Pm)

Now pluralized in specland.

Pm-8: Are closures embedded in regexes creating a new lexical scope,
    or do they share the same scope as the regex block itself?
    (Currently I'm assuming they create a new scope, to be consistent
    with other uses of curlies. --Pm

Yes.

Pm-9: Inside of a regex, what happens with C<< <[z..a]> >> ?  Is it
    a compile-time error, an empty range, or ... ?

Let's make it a compile-time error for direct code, and a failure
with warning for code compiled indirectly via <$code>.

Pm-10:  Subs are canonically considered to be stored in symbol
    tables (lexpads, namespaces) with the & sigil.  Is the same
    true for methods?  If we ask a method for its name or otherwise
    obtain a list of method names from an object, would we expect
    those names to have a & sigil as well?  (For HLL interop reasons
    Pm tends to want methods to not include a & sigil, but it's not
    a strong tendency.)

Whether there's the & sigil or not depends on where you're storing
the name.  The MOP doesn't keep the sigil, but if a method is declared
"my" or "our", the alias in the symbol table does have the &, since as
far as the symbol table is concerned, the method is just a subroutine.
(Also note that, while the MOP doesn't track the sigil on methods,
it probably does track the sigil on attributes, such as $!foo, &!foo.)
One could view exportation of methods as multi as a two-step process; first,
declare my or our to make the & alias in the current lexpad, then
"is export" does no more magic than it ordinarily does.  I suppose
method aliases are always considered multi when they show up in a
symbol table.

Kh-1: Is it true that Bool::True.name should work?  Should it return
    the string 'True'?
    I ask because of http://rt.perl.org/rt3/Public/Bug/Display.html?id=66576

Yes, because Bool is an object type, so it knows its .name.  (A native
bool would not know its name, according to S12:1649.)

Jw-1: What is the difference between :(\$x) and :($x is ref)? Both
would need to leave the original argument untouched. Since C<is ref>
is meant to be used for e.g. map, which needs to work on lists like
(1,2,3), it can't cut constants out, so it seems no more constraining
than :(\$x) too. Should one of them go away?

No difference that I can see offhand.  I'm inclined to make 'is ref' go away
and keep the backslashed form.

Pm-11: S11:257 says "Without an import list, C<import> imports
    the C<:DEFAULT> imports."  How does one import one of the
    other tagsets?  (I think I'm missing something obvious here.)

I believe the idea is simply to use the tagset pair directly as an argument.
And since lexical importation is assumed, there's an implicit :MY() around it.
So 'use Foo :tag' is probably short for 'use Foo :MY(:tag)'.
