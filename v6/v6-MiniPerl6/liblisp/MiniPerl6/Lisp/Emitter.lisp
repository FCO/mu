;; Do not edit this file - Generated by MiniPerl6
;; class MiniPerl6::Lisp::LexicalBlock
(defpackage mp-MiniPerl6-Lisp-LexicalBlock
  (:use common-lisp))
;; (in-package mp-MiniPerl6-Lisp-LexicalBlock)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Lisp-LexicalBlock)))
  (defclass mp-MiniPerl6-Lisp-LexicalBlock () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Lisp-LexicalBlock))
  (defun proto-mp-MiniPerl6-Lisp-LexicalBlock () x))
;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-MiniPerl6-Lisp-LexicalBlock)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-MiniPerl6-Lisp-LexicalBlock :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-MiniPerl6-Lisp-LexicalBlock))
  (block mp6-function
    (let ((sv-str nil)(sv-has_my_decl nil)(sv-my_decl nil)) (setf sv-str "")(setf sv-has_my_decl 0)(setf sv-my_decl "")(dolist (sv-decl (sv-block sv-self)) (progn (if (sv-bool (sv-and (isa sv-decl "Decl") (sv-eq (sv-decl sv-decl ) "my"))) (progn (setf sv-has_my_decl 1)(setf sv-my_decl (format nil "~{~a~}" (list sv-my_decl (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (sv-emit (sv-var sv-decl ) ) " nil)")))))))) (progn ))(if (sv-bool (sv-and (isa sv-decl "Bind") (sv-and (isa (sv-parameters sv-decl ) "Decl") (sv-eq (sv-decl (sv-parameters sv-decl ) ) "my")))) (progn (setf sv-has_my_decl 1)(setf sv-my_decl (format nil "~{~a~}" (list sv-my_decl (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (sv-emit (sv-var (sv-parameters sv-decl ) ) ) " nil)")))))))) (progn ))))(if (sv-bool sv-has_my_decl) (progn (setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list "(let (" (format nil "~{~a~}" (list sv-my_decl ") ")))))))) (progn (setf sv-str (format nil "~{~a~}" (list sv-str "(progn ")))))(dolist (sv-decl (sv-block sv-self)) (progn (if (sv-bool (not (sv-bool (sv-and (isa sv-decl "Decl") (sv-eq (sv-decl sv-decl ) "my")) ))) (progn (setf sv-str (format nil "~{~a~}" (list sv-str (sv-emit sv-decl ))))) (progn ))))(return-from mp6-function (format nil "~{~a~}" (list sv-str ")"))))))




;; class CompUnit
(defpackage mp-CompUnit
  (:use common-lisp))
;; (in-package mp-CompUnit)
(if (not (ignore-errors (find-class 'mp-CompUnit)))
  (defclass mp-CompUnit () ()))

(let (x) 
  (setq x (make-instance 'mp-CompUnit))
  (defun proto-mp-CompUnit () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.attributes
(let ((new-slots (list (list :name 'sv-attributes
  :readers '(sv-attributes)
  :writers '((setf sv-attributes))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.methods
(let ((new-slots (list (list :name 'sv-methods
  :readers '(sv-methods)
  :writers '((setf sv-methods))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-CompUnit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-CompUnit :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-CompUnit))
  (block mp6-function
    (let ((sv-class_name nil)(sv-str nil)(sv-has_my_decl nil)(sv-my_decl nil)) (setf sv-class_name (mp-Main::sv-to_lisp_namespace (sv-name sv-self)))(setf sv-str (format nil "~{~a~}" (list ";; class " (format nil "~{~a~}" (list (sv-name sv-self) (sv-newline (proto-mp-Main) ))))))(setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list "(defpackage " (format nil "~{~a~}" (list sv-class_name (format nil "~{~a~}" (list (sv-newline (proto-mp-Main) ) (format nil "~{~a~}" (list "  (:use common-lisp))" (format nil "~{~a~}" (list (sv-newline (proto-mp-Main) ) (format nil "~{~a~}" (list ";; (in-package " (format nil "~{~a~}" (list sv-class_name (format nil "~{~a~}" (list ")" (sv-newline (proto-mp-Main) ))))))))))))))))))))(setf sv-has_my_decl 0)(setf sv-my_decl "")(dolist (sv-decl (sv-body sv-self)) (progn (if (sv-bool (sv-and (isa sv-decl "Decl") (sv-eq (sv-decl sv-decl ) "my"))) (progn (setf sv-has_my_decl 1)(setf sv-my_decl (format nil "~{~a~}" (list sv-my_decl (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (sv-emit (sv-var sv-decl ) ) " nil)")))))))) (progn ))(if (sv-bool (sv-and (isa sv-decl "Bind") (sv-and (isa (sv-parameters sv-decl ) "Decl") (sv-eq (sv-decl (sv-parameters sv-decl ) ) "my")))) (progn (setf sv-has_my_decl 1)(setf sv-my_decl (format nil "~{~a~}" (list sv-my_decl (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (sv-emit (sv-var (sv-parameters sv-decl ) ) ) " nil)")))))))) (progn ))))(if (sv-bool sv-has_my_decl) (progn (setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list "(let (" (format nil "~{~a~}" (list sv-my_decl (format nil "~{~a~}" (list ")" (sv-newline (proto-mp-Main) ))))))))))) (progn ))(setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list "(if (not (ignore-errors (find-class \\'" (format nil "~{~a~}" (list sv-class_name (format nil "~{~a~}" (list ")))
  (defclass " (format nil "~{~a~}" (list sv-class_name (format nil "~{~a~}" (list " () ()))

(let (x) 
  (setq x (make-instance \\'" (format nil "~{~a~}" (list sv-class_name (format nil "~{~a~}" (list "))
  (defun proto-" (format nil "~{~a~}" (list sv-class_name " () x))
")))))))))))))))))))(dolist (sv-decl (sv-body sv-self)) (progn (if (sv-bool (sv-and (isa sv-decl "Decl") (sv-eq (sv-decl sv-decl ) "has"))) (let ((sv-accessor_name nil)) (setf sv-accessor_name (sv-name (sv-var sv-decl ) ))(setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list ";; has $." (format nil "~{~a~}" (list sv-accessor_name (format nil "~{~a~}" (list "
(let ((new-slots (list (list :name \\'" (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier sv-accessor_name) (format nil "~{~a~}" (list "
  :readers \\'(" (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier sv-accessor_name) (format nil "~{~a~}" (list ")
  :writers \\'((setf " (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier sv-accessor_name) (format nil "~{~a~}" (list "))
  :initform \\'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class \\'" (format nil "~{~a~}" (list sv-class_name (format nil "~{~a~}" (list ")))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class \\'" (format nil "~{~a~}" (list sv-class_name " :direct-slots new-slots))

")))))))))))))))))))))))))))) (progn ))(if (sv-bool (isa sv-decl "Method")) (let ((sv-sig nil)(sv-invocant nil)(sv-pos nil)(sv-str_specific nil)(sv-str_generic nil)(sv-str_optionals nil)(sv-block nil)) (setf sv-sig (sv-sig sv-decl ))(setf sv-invocant (sv-invocant sv-sig ))(setf sv-pos (sv-positional sv-sig ))(setf sv-str_specific (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (sv-emit sv-invocant ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list sv-class_name ")")))))))))(setf sv-str_generic (sv-emit sv-invocant ))(setf sv-str_optionals "")(dolist (sv-field sv-pos) (progn (setf sv-str_optionals (format nil "~{~a~}" (list sv-str_optionals (format nil "~{~a~}" (list " " (sv-emit sv-field ))))))))(if (sv-bool sv-str_optionals) (progn (setf sv-str_specific (format nil "~{~a~}" (list sv-str_specific (format nil "~{~a~}" (list " &optional" sv-str_optionals)))))(setf sv-str_generic (format nil "~{~a~}" (list sv-str_generic (format nil "~{~a~}" (list " &optional" sv-str_optionals)))))) (progn ))(setf sv-block (let ((m (make-instance 'mp-MiniPerl6-Lisp-LexicalBlock))) (setf (sv-block m) (sv-block sv-decl )) m))(setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list ";; method " (format nil "~{~a~}" (list (sv-name sv-decl ) (format nil "~{~a~}" (list "
(if (not (ignore-errors (find-method \\'" (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier (sv-name sv-decl )) (format nil "~{~a~}" (list " () ())))
  (defgeneric " (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier (sv-name sv-decl )) (format nil "~{~a~}" (list " (" (format nil "~{~a~}" (list sv-str_generic (format nil "~{~a~}" (list ")
      (:documentation " (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list "a method" (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list ")))
(defmethod " (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier (sv-name sv-decl )) (format nil "~{~a~}" (list " (" (format nil "~{~a~}" (list sv-str_specific (format nil "~{~a~}" (list ")
  (block mp6-function
    " (format nil "~{~a~}" (list (sv-emit sv-block ) "))

")))))))))))))))))))))))))))))))))))))))) (progn ))(if (sv-bool (isa sv-decl "Sub")) (progn (setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list "(in-package " (format nil "~{~a~}" (list sv-class_name (format nil "~{~a~}" (list ")" (format nil "~{~a~}" (list (sv-newline (proto-mp-Main) ) (format nil "~{~a~}" (list "  " (format nil "~{~a~}" (list (sv-emit sv-decl ) (format nil "~{~a~}" (list (sv-newline (proto-mp-Main) ) (format nil "~{~a~}" (list "(in-package mp-Main)" (sv-newline (proto-mp-Main) ))))))))))))))))))))) (progn ))))(dolist (sv-decl (sv-body sv-self)) (progn (if (sv-bool (sv-and (not (sv-bool (sv-and (isa sv-decl "Decl") (sv-or (sv-eq (sv-decl sv-decl ) "has") (sv-eq (sv-decl sv-decl ) "my"))) )) (sv-and (not (sv-bool (isa sv-decl "Method") )) (not (sv-bool (isa sv-decl "Sub") ))))) (progn (setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list (sv-emit sv-decl ) (sv-newline (proto-mp-Main) ))))))) (progn ))))(if (sv-bool sv-has_my_decl) (progn (setf sv-str (format nil "~{~a~}" (list sv-str ")")))) (progn ))(setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list (sv-newline (proto-mp-Main) ) (sv-newline (proto-mp-Main) )))))))))




;; class Val::Int
(defpackage mp-Val-Int
  (:use common-lisp))
;; (in-package mp-Val-Int)
(if (not (ignore-errors (find-class 'mp-Val-Int)))
  (defclass mp-Val-Int () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Int))
  (defun proto-mp-Val-Int () x))
;; has $.int
(let ((new-slots (list (list :name 'sv-int
  :readers '(sv-int)
  :writers '((setf sv-int))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Int)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Int :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Val-Int))
  (block mp6-function
    (progn (sv-int sv-self))))




;; class Val::Bit
(defpackage mp-Val-Bit
  (:use common-lisp))
;; (in-package mp-Val-Bit)
(if (not (ignore-errors (find-class 'mp-Val-Bit)))
  (defclass mp-Val-Bit () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Bit))
  (defun proto-mp-Val-Bit () x))
;; has $.bit
(let ((new-slots (list (list :name 'sv-bit
  :readers '(sv-bit)
  :writers '((setf sv-bit))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Bit)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Bit :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Val-Bit))
  (block mp6-function
    (progn (sv-bit sv-self))))




;; class Val::Num
(defpackage mp-Val-Num
  (:use common-lisp))
;; (in-package mp-Val-Num)
(if (not (ignore-errors (find-class 'mp-Val-Num)))
  (defclass mp-Val-Num () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Num))
  (defun proto-mp-Val-Num () x))
;; has $.num
(let ((new-slots (list (list :name 'sv-num
  :readers '(sv-num)
  :writers '((setf sv-num))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Num)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Num :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Val-Num))
  (block mp6-function
    (progn (sv-num sv-self))))




;; class Val::Buf
(defpackage mp-Val-Buf
  (:use common-lisp))
;; (in-package mp-Val-Buf)
(if (not (ignore-errors (find-class 'mp-Val-Buf)))
  (defclass mp-Val-Buf () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Buf))
  (defun proto-mp-Val-Buf () x))
;; has $.buf
(let ((new-slots (list (list :name 'sv-buf
  :readers '(sv-buf)
  :writers '((setf sv-buf))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Buf)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Buf :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Val-Buf))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list (mp-Main::sv-lisp_escape_string (sv-buf sv-self)) "\"")))))))




;; class Val::Undef
(defpackage mp-Val-Undef
  (:use common-lisp))
;; (in-package mp-Val-Undef)
(if (not (ignore-errors (find-class 'mp-Val-Undef)))
  (defclass mp-Val-Undef () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Undef))
  (defun proto-mp-Val-Undef () x))
;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Val-Undef))
  (block mp6-function
    (progn "nil")))




;; class Val::Object
(defpackage mp-Val-Object
  (:use common-lisp))
;; (in-package mp-Val-Object)
(if (not (ignore-errors (find-class 'mp-Val-Object)))
  (defclass mp-Val-Object () ()))

(let (x) 
  (setq x (make-instance 'mp-Val-Object))
  (defun proto-mp-Val-Object () x))
;; has $.class
(let ((new-slots (list (list :name 'sv-class
  :readers '(sv-class)
  :writers '((setf sv-class))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Object :direct-slots new-slots))

;; has $.fields
(let ((new-slots (list (list :name 'sv-fields
  :readers '(sv-fields)
  :writers '((setf sv-fields))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Val-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Val-Object :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Val-Object))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "bless(" (format nil "~{~a~}" (list (prin1-to-string (sv-fields sv-self)) (format nil "~{~a~}" (list ", " (format nil "~{~a~}" (list (prin1-to-string (sv-class sv-self)) ")")))))))))))




;; class Lit::Seq
(defpackage mp-Lit-Seq
  (:use common-lisp))
;; (in-package mp-Lit-Seq)
(if (not (ignore-errors (find-class 'mp-Lit-Seq)))
  (defclass mp-Lit-Seq () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Seq))
  (defun proto-mp-Lit-Seq () x))
;; has $.seq
(let ((new-slots (list (list :name 'sv-seq
  :readers '(sv-seq)
  :writers '((setf sv-seq))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Seq)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Seq :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Lit-Seq))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-seq sv-self)) " ") ")")))))))




;; class Lit::Array
(defpackage mp-Lit-Array
  (:use common-lisp))
;; (in-package mp-Lit-Array)
(if (not (ignore-errors (find-class 'mp-Lit-Array)))
  (defclass mp-Lit-Array () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Array))
  (defun proto-mp-Lit-Array () x))
;; has $.array
(let ((new-slots (list (list :name 'sv-array
  :readers '(sv-array)
  :writers '((setf sv-array))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Array)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Array :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Lit-Array))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "(list " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-array sv-self)) " ") ")")))))))




;; class Lit::Hash
(defpackage mp-Lit-Hash
  (:use common-lisp))
;; (in-package mp-Lit-Hash)
(if (not (ignore-errors (find-class 'mp-Lit-Hash)))
  (defclass mp-Lit-Hash () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Hash))
  (defun proto-mp-Lit-Hash () x))
;; has $.hash
(let ((new-slots (list (list :name 'sv-hash
  :readers '(sv-hash)
  :writers '((setf sv-hash))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Hash)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Hash :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Lit-Hash))
  (block mp6-function
    (let ((sv-fields nil)(sv-str nil)) (setf sv-fields (sv-hash sv-self))(setf sv-str "")(dolist (sv-field sv-fields) (progn (setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list "(setf (gethash " (format nil "~{~a~}" (list (sv-emit (elt field 0) ) (format nil "~{~a~}" (list " h) " (format nil "~{~a~}" (list (sv-emit (elt field 1) ) ")")))))))))))))(format nil "~{~a~}" (list "(let ((h (make-hash-table :test \\'equal))) " (format nil "~{~a~}" (list sv-str " h)")))))))




;; class Lit::Code
(defpackage mp-Lit-Code
  (:use common-lisp))
;; (in-package mp-Lit-Code)
(if (not (ignore-errors (find-class 'mp-Lit-Code)))
  (defclass mp-Lit-Code () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Code))
  (defun proto-mp-Lit-Code () x))
1



;; class Lit::Object
(defpackage mp-Lit-Object
  (:use common-lisp))
;; (in-package mp-Lit-Object)
(if (not (ignore-errors (find-class 'mp-Lit-Object)))
  (defclass mp-Lit-Object () ()))

(let (x) 
  (setq x (make-instance 'mp-Lit-Object))
  (defun proto-mp-Lit-Object () x))
;; has $.class
(let ((new-slots (list (list :name 'sv-class
  :readers '(sv-class)
  :writers '((setf sv-class))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Object :direct-slots new-slots))

;; has $.fields
(let ((new-slots (list (list :name 'sv-fields
  :readers '(sv-fields)
  :writers '((setf sv-fields))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lit-Object)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lit-Object :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Lit-Object))
  (block mp6-function
    (let ((sv-fields nil)(sv-str nil)) (setf sv-fields (sv-fields sv-self))(setf sv-str "")(dolist (sv-field sv-fields) (progn (setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list "(setf (" (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier (sv-buf (elt field 0) )) (format nil "~{~a~}" (list " m) " (format nil "~{~a~}" (list (sv-emit (elt field 1) ) ")")))))))))))))(format nil "~{~a~}" (list "(let ((m (make-instance \\'" (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_namespace (sv-class sv-self)) (format nil "~{~a~}" (list "))) " (format nil "~{~a~}" (list sv-str " m)")))))))))))




;; class Index
(defpackage mp-Index
  (:use common-lisp))
;; (in-package mp-Index)
(if (not (ignore-errors (find-class 'mp-Index)))
  (defclass mp-Index () ()))

(let (x) 
  (setq x (make-instance 'mp-Index))
  (defun proto-mp-Index () x))
;; has $.obj
(let ((new-slots (list (list :name 'sv-obj
  :readers '(sv-obj)
  :writers '((setf sv-obj))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Index)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Index :direct-slots new-slots))

;; has $.index
(let ((new-slots (list (list :name 'sv-index
  :readers '(sv-index)
  :writers '((setf sv-index))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Index)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Index :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Index))
  (block mp6-function
    (progn (if (sv-bool (isa (sv-obj sv-self) "Var")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(elt " (format nil "~{~a~}" (list (sv-name (sv-obj sv-self) ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit (sv-index sv-self) ) ")")))))))))) (progn ))(return-from mp6-function (format nil "~{~a~}" (list "(elt " (format nil "~{~a~}" (list (sv-emit (sv-obj sv-self) ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit (sv-index sv-self) ) ")"))))))))))))




;; class Lookup
(defpackage mp-Lookup
  (:use common-lisp))
;; (in-package mp-Lookup)
(if (not (ignore-errors (find-class 'mp-Lookup)))
  (defclass mp-Lookup () ()))

(let (x) 
  (setq x (make-instance 'mp-Lookup))
  (defun proto-mp-Lookup () x))
;; has $.obj
(let ((new-slots (list (list :name 'sv-obj
  :readers '(sv-obj)
  :writers '((setf sv-obj))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lookup)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lookup :direct-slots new-slots))

;; has $.index
(let ((new-slots (list (list :name 'sv-index
  :readers '(sv-index)
  :writers '((setf sv-index))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Lookup)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Lookup :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Lookup))
  (block mp6-function
    (progn (if (sv-bool (isa (sv-obj sv-self) "Var")) (progn (if (sv-bool (sv-or (sv-eq (sv-name (sv-obj sv-self) ) "MATCH") (sv-eq (sv-name (sv-obj sv-self) ) "/"))) (progn (return-from mp6-function (format nil "~{~a~}" (list "(gethash " (format nil "~{~a~}" (list (sv-emit (sv-index sv-self) ) (format nil "~{~a~}" (list " (sv-hash " (format nil "~{~a~}" (list (sv-emit (sv-obj sv-self) ) "))")))))))))) (progn ))) (progn ))(return-from mp6-function (format nil "~{~a~}" (list "(gethash " (format nil "~{~a~}" (list (sv-emit (sv-index sv-self) ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit (sv-obj sv-self) ) ")"))))))))))))




;; class Var
(defpackage mp-Var
  (:use common-lisp))
;; (in-package mp-Var)
(if (not (ignore-errors (find-class 'mp-Var)))
  (defclass mp-Var () ()))

(let (x) 
  (setq x (make-instance 'mp-Var))
  (defun proto-mp-Var () x))
;; has $.sigil
(let ((new-slots (list (list :name 'sv-sigil
  :readers '(sv-sigil)
  :writers '((setf sv-sigil))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.twigil
(let ((new-slots (list (list :name 'sv-twigil
  :readers '(sv-twigil)
  :writers '((setf sv-twigil))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Var :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Var))
  (block mp6-function
    (progn (if (sv-bool (sv-eq (sv-twigil sv-self) ".")) (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier (sv-name sv-self)) " sv-self)")))) (if (sv-bool (sv-eq (sv-name sv-self) "/")) (mp-Main::sv-to_lisp_identifier "MATCH") (mp-Main::sv-to_lisp_identifier (sv-name sv-self)))))))




;; class Bind
(defpackage mp-Bind
  (:use common-lisp))
;; (in-package mp-Bind)
(if (not (ignore-errors (find-class 'mp-Bind)))
  (defclass mp-Bind () ()))

(let (x) 
  (setq x (make-instance 'mp-Bind))
  (defun proto-mp-Bind () x))
;; has $.parameters
(let ((new-slots (list (list :name 'sv-parameters
  :readers '(sv-parameters)
  :writers '((setf sv-parameters))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Bind)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Bind :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Bind)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Bind :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Bind))
  (block mp6-function
    (progn (if (sv-bool (isa (sv-parameters sv-self) "Lit::Object")) (let ((sv-class nil)(sv-a nil)(sv-b nil)(sv-str nil)(sv-i nil)(sv-arg nil)) (setf sv-class (sv-class (sv-parameters sv-self) ))(setf sv-a (sv-fields (sv-parameters sv-self) ))(setf sv-b (sv-arguments sv-self))(setf sv-str "do { ")(setf sv-i 0)(dolist (sv-var sv-a) (let ((sv-bind nil)) (setf sv-bind (let ((m (make-instance 'mp-Bind))) (setf (sv-parameters m) (elt var 1))(setf (sv-arguments m) (let ((m (make-instance 'mp-Call))) (setf (sv-invocant m) sv-b)(setf (sv-method m) (sv-buf (elt var 0) ))(setf (sv-arguments m) (list ))(setf (sv-hyper m) 0) m)) m))(setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit sv-bind ) " ")))))))(setf sv-i (+ sv-i 1))))(return-from mp6-function (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list (sv-emit (sv-parameters sv-self) ) " }")))))) (progn ))(if (sv-bool (sv-and (isa (sv-parameters sv-self) "Decl") (sv-eq (sv-decl (sv-parameters sv-self) ) "my"))) (progn (return-from mp6-function (format nil "~{~a~}" (list "(setf " (format nil "~{~a~}" (list (sv-emit (sv-var (sv-parameters sv-self) ) ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit (sv-arguments sv-self) ) ")")))))))))) (progn ))(format nil "~{~a~}" (list "(setf " (format nil "~{~a~}" (list (sv-emit (sv-parameters sv-self) ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit (sv-arguments sv-self) ) ")")))))))))))




;; class Proto
(defpackage mp-Proto
  (:use common-lisp))
;; (in-package mp-Proto)
(if (not (ignore-errors (find-class 'mp-Proto)))
  (defclass mp-Proto () ()))

(let (x) 
  (setq x (make-instance 'mp-Proto))
  (defun proto-mp-Proto () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Proto)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Proto :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Proto))
  (block mp6-function
    (progn (format nil "~{~a~}" (list "(proto-" (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_namespace (sv-name sv-self)) ")")))))))




;; class Call
(defpackage mp-Call
  (:use common-lisp))
;; (in-package mp-Call)
(if (not (ignore-errors (find-class 'mp-Call)))
  (defclass mp-Call () ()))

(let (x) 
  (setq x (make-instance 'mp-Call))
  (defun proto-mp-Call () x))
;; has $.invocant
(let ((new-slots (list (list :name 'sv-invocant
  :readers '(sv-invocant)
  :writers '((setf sv-invocant))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.hyper
(let ((new-slots (list (list :name 'sv-hyper
  :readers '(sv-hyper)
  :writers '((setf sv-hyper))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.method
(let ((new-slots (list (list :name 'sv-method
  :readers '(sv-method)
  :writers '((setf sv-method))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Call)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Call :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Call))
  (block mp6-function
    (let ((sv-invocant nil)(sv-meth nil)) (setf sv-invocant (sv-emit (sv-invocant sv-self) ))(if (sv-bool (sv-eq sv-invocant "self")) (progn (setf sv-invocant "sv-self")) (progn ))(if (sv-bool (sv-eq (sv-method sv-self) "values")) (progn (if (sv-bool (sv-hyper sv-self)) (progn (progn (write-line (format nil "~{~a~}" (list "not implemented")) *error-output*) (sb-ext:quit))) (progn (return-from mp6-function (format nil "~{~a~}" (list "@{" (format nil "~{~a~}" (list sv-invocant "}")))))))) (progn ))(if (sv-bool (sv-eq (sv-method sv-self) "perl")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(prin1-to-string " (format nil "~{~a~}" (list sv-invocant ")")))))) (progn ))(if (sv-bool (sv-or (sv-eq (sv-method sv-self) "yaml") (sv-or (sv-eq (sv-method sv-self) "say") (sv-or (sv-eq (sv-method sv-self) "chars") (sv-eq (sv-method sv-self) "isa"))))) (progn (if (sv-bool (sv-hyper sv-self)) (progn (return-from mp6-function (format nil "~{~a~}" (list "[ map { " (format nil "~{~a~}" (list (sv-method sv-self) (format nil "~{~a~}" (list "( $_, " (format nil "~{~a~}" (list ", " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) ", ") (format nil "~{~a~}" (list ")" (format nil "~{~a~}" (list " } @{ " (format nil "~{~a~}" (list sv-invocant " } ]")))))))))))))))))) (progn (return-from mp6-function (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (sv-method sv-self) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list sv-invocant (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))))))))))))) (progn ))(setf sv-meth (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier (sv-method sv-self)) " ")))(if (sv-bool (sv-eq (sv-method sv-self) "postcircumfix:<( )>")) (progn (setf sv-meth "")) (progn ))(if (sv-bool (sv-hyper sv-self)) (progn (format nil "~{~a~}" (list "(mapcar #\\'" (format nil "~{~a~}" (list sv-meth (format nil "~{~a~}" (list sv-invocant ")"))))))) (progn (return-from mp6-function (format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list sv-meth (format nil "~{~a~}" (list sv-invocant (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")"))))))))))))))))




;; class Apply
(defpackage mp-Apply
  (:use common-lisp))
;; (in-package mp-Apply)
(if (not (ignore-errors (find-class 'mp-Apply)))
  (defclass mp-Apply () ()))

(let (x) 
  (setq x (make-instance 'mp-Apply))
  (defun proto-mp-Apply () x))
;; has $.code
(let ((new-slots (list (list :name 'sv-code
  :readers '(sv-code)
  :writers '((setf sv-code))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; has $.arguments
(let ((new-slots (list (list :name 'sv-arguments
  :readers '(sv-arguments)
  :writers '((setf sv-arguments))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Apply)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Apply :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Apply))
  (block mp6-function
    (let ((sv-code nil)) (setf sv-code (sv-code sv-self))(if (sv-bool (sv-eq sv-code "self")) (progn (return-from mp6-function "sv-self")) (progn ))(if (sv-bool (sv-eq sv-code "make")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(return-from mp6-function " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "substr")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(sv-substr " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "say")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(format t " (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list "~{~a~}~%" (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list " (list " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") "))")))))))))))))) (progn ))(if (sv-bool (sv-eq sv-code "print")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(format t " (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list "~{~a~}" (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list " (list " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") "))")))))))))))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<~>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(format nil " (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list "~{~a~}" (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list " (list " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") "))")))))))))))))) (progn ))(if (sv-bool (sv-eq sv-code "warn")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(write-line (format nil " (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list "~{~a~}" (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list " (list " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")) *error-output*)")))))))))))))) (progn ))(if (sv-bool (sv-eq sv-code "die")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(progn (write-line (format nil " (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list "~{~a~}" (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list " (list " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")) *error-output*) (sb-ext:quit))")))))))))))))) (progn ))(if (sv-bool (sv-eq sv-code "array")) (progn (return-from mp6-function (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " "))) (progn ))(if (sv-bool (sv-eq sv-code "prefix:<~>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(format nil " (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list "~{~a~}" (format nil "~{~a~}" (list "\"" (format nil "~{~a~}" (list " (list " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") "))")))))))))))))) (progn ))(if (sv-bool (sv-eq sv-code "prefix:<!>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(not (sv-bool " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") " ))")))))) (progn ))(if (sv-bool (sv-eq sv-code "prefix:<?>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(sv-bool " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") " )")))))) (progn ))(if (sv-bool (sv-eq sv-code "prefix:<$>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(sv-scalar " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "prefix:<@>")) (progn (return-from mp6-function (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " "))) (progn ))(if (sv-bool (sv-eq sv-code "prefix:<%>")) (progn (return-from mp6-function (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " "))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<+>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(+ " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<->")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(-" (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<>>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(> " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<x>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(x " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<&&>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(sv-and " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<||>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(sv-or " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<eq>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(sv-eq " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<ne>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(not (sv-eq " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") "))")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<==>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(eql " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))) (progn ))(if (sv-bool (sv-eq sv-code "infix:<!=>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(not (eql " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") "))")))))) (progn ))(if (sv-bool (sv-eq sv-code "ternary:<?? !!>")) (progn (return-from mp6-function (format nil "~{~a~}" (list "(if (sv-bool " (format nil "~{~a~}" (list (sv-emit (elt arguments 0) ) (format nil "~{~a~}" (list ") " (format nil "~{~a~}" (list (sv-emit (elt arguments 1) ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit (elt arguments 2) ) ")")))))))))))))) (progn ))(format nil "~{~a~}" (list "(" (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier (sv-code sv-self)) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-join (mapcar #'sv-emit (sv-arguments sv-self)) " ") ")")))))))))))




;; class Return
(defpackage mp-Return
  (:use common-lisp))
;; (in-package mp-Return)
(if (not (ignore-errors (find-class 'mp-Return)))
  (defclass mp-Return () ()))

(let (x) 
  (setq x (make-instance 'mp-Return))
  (defun proto-mp-Return () x))
;; has $.result
(let ((new-slots (list (list :name 'sv-result
  :readers '(sv-result)
  :writers '((setf sv-result))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Return)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Return :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Return))
  (block mp6-function
    (progn (return-from mp6-function (format nil "~{~a~}" (list "(return-from mp6-function " (format nil "~{~a~}" (list (sv-emit (sv-result sv-self) ) ")"))))))))




;; class If
(defpackage mp-If
  (:use common-lisp))
;; (in-package mp-If)
(if (not (ignore-errors (find-class 'mp-If)))
  (defclass mp-If () ()))

(let (x) 
  (setq x (make-instance 'mp-If))
  (defun proto-mp-If () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; has $.otherwise
(let ((new-slots (list (list :name 'sv-otherwise
  :readers '(sv-otherwise)
  :writers '((setf sv-otherwise))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-If)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-If :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-If))
  (block mp6-function
    (let ((sv-block1 nil)(sv-block2 nil)) (setf sv-block1 (let ((m (make-instance 'mp-MiniPerl6-Lisp-LexicalBlock))) (setf (sv-block m) (sv-body sv-self)) m))(setf sv-block2 (let ((m (make-instance 'mp-MiniPerl6-Lisp-LexicalBlock))) (setf (sv-block m) (sv-otherwise sv-self)) m))(format nil "~{~a~}" (list "(if (sv-bool " (format nil "~{~a~}" (list (sv-emit (sv-cond sv-self) ) (format nil "~{~a~}" (list ") " (format nil "~{~a~}" (list (sv-emit sv-block1 ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit sv-block2 ) ")")))))))))))))))




;; class For
(defpackage mp-For
  (:use common-lisp))
;; (in-package mp-For)
(if (not (ignore-errors (find-class 'mp-For)))
  (defclass mp-For () ()))

(let (x) 
  (setq x (make-instance 'mp-For))
  (defun proto-mp-For () x))
;; has $.cond
(let ((new-slots (list (list :name 'sv-cond
  :readers '(sv-cond)
  :writers '((setf sv-cond))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; has $.body
(let ((new-slots (list (list :name 'sv-body
  :readers '(sv-body)
  :writers '((setf sv-body))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; has $.topic
(let ((new-slots (list (list :name 'sv-topic
  :readers '(sv-topic)
  :writers '((setf sv-topic))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-For)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-For :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-For))
  (block mp6-function
    (let ((sv-cond nil)(sv-block nil)) (setf sv-cond (sv-cond sv-self))(setf sv-block (let ((m (make-instance 'mp-MiniPerl6-Lisp-LexicalBlock))) (setf (sv-block m) (sv-body sv-self)) m))(if (sv-bool (sv-and (isa sv-cond "Var") (sv-eq (sv-sigil sv-cond ) "@"))) (progn (setf sv-cond (let ((m (make-instance 'mp-Apply))) (setf (sv-code m) "prefix:<@>")(setf (sv-arguments m) (list sv-cond)) m))) (progn ))(format nil "~{~a~}" (list "(dolist (" (format nil "~{~a~}" (list (sv-emit (sv-topic sv-self) ) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-emit sv-cond ) (format nil "~{~a~}" (list ") " (format nil "~{~a~}" (list (sv-emit sv-block ) ")")))))))))))))))




;; class Decl
(defpackage mp-Decl
  (:use common-lisp))
;; (in-package mp-Decl)
(if (not (ignore-errors (find-class 'mp-Decl)))
  (defclass mp-Decl () ()))

(let (x) 
  (setq x (make-instance 'mp-Decl))
  (defun proto-mp-Decl () x))
;; has $.decl
(let ((new-slots (list (list :name 'sv-decl
  :readers '(sv-decl)
  :writers '((setf sv-decl))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; has $.type
(let ((new-slots (list (list :name 'sv-type
  :readers '(sv-type)
  :writers '((setf sv-type))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; has $.var
(let ((new-slots (list (list :name 'sv-var
  :readers '(sv-var)
  :writers '((setf sv-var))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Decl)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Decl :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Decl))
  (block mp6-function
    (let ((sv-decl nil)(sv-name nil)) (setf sv-decl (sv-decl sv-self))(setf sv-name (sv-name (sv-var sv-self) ))(if (sv-bool (sv-eq sv-decl "has")) (format nil "~{~a~}" (list "sub " (format nil "~{~a~}" (list sv-name (format nil "~{~a~}" (list " { " (format nil "~{~a~}" (list "@_ == 1 " (format nil "~{~a~}" (list "? ( $_[0]->{" (format nil "~{~a~}" (list sv-name (format nil "~{~a~}" (list "} ) " (format nil "~{~a~}" (list ": ( $_[0]->{" (format nil "~{~a~}" (list sv-name (format nil "~{~a~}" (list "} = $_[1] ) " "}")))))))))))))))))))) (format nil "~{~a~}" (list (sv-decl sv-self) (format nil "~{~a~}" (list " " (format nil "~{~a~}" (list (sv-type sv-self) (format nil "~{~a~}" (list " " (sv-emit (sv-var sv-self) )))))))))))))




;; class Sig
(defpackage mp-Sig
  (:use common-lisp))
;; (in-package mp-Sig)
(if (not (ignore-errors (find-class 'mp-Sig)))
  (defclass mp-Sig () ()))

(let (x) 
  (setq x (make-instance 'mp-Sig))
  (defun proto-mp-Sig () x))
;; has $.invocant
(let ((new-slots (list (list :name 'sv-invocant
  :readers '(sv-invocant)
  :writers '((setf sv-invocant))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; has $.positional
(let ((new-slots (list (list :name 'sv-positional
  :readers '(sv-positional)
  :writers '((setf sv-positional))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; has $.named
(let ((new-slots (list (list :name 'sv-named
  :readers '(sv-named)
  :writers '((setf sv-named))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sig)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sig :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Sig))
  (block mp6-function
    (progn " print \\'Signature - TODO\\'; die \\'Signature - TODO\\'; ")))

;; method invocant
(if (not (ignore-errors (find-method 'sv-invocant () ())))
  (defgeneric sv-invocant (sv-self)
      (:documentation "a method")))
(defmethod sv-invocant ((sv-self mp-Sig))
  (block mp6-function
    (progn (sv-invocant sv-self))))

;; method positional
(if (not (ignore-errors (find-method 'sv-positional () ())))
  (defgeneric sv-positional (sv-self)
      (:documentation "a method")))
(defmethod sv-positional ((sv-self mp-Sig))
  (block mp6-function
    (progn (sv-positional sv-self))))




;; class Method
(defpackage mp-Method
  (:use common-lisp))
;; (in-package mp-Method)
(if (not (ignore-errors (find-class 'mp-Method)))
  (defclass mp-Method () ()))

(let (x) 
  (setq x (make-instance 'mp-Method))
  (defun proto-mp-Method () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; has $.sig
(let ((new-slots (list (list :name 'sv-sig
  :readers '(sv-sig)
  :writers '((setf sv-sig))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Method)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Method :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Method))
  (block mp6-function
    (progn )))




;; class Sub
(defpackage mp-Sub
  (:use common-lisp))
;; (in-package mp-Sub)
(if (not (ignore-errors (find-class 'mp-Sub)))
  (defclass mp-Sub () ()))

(let (x) 
  (setq x (make-instance 'mp-Sub))
  (defun proto-mp-Sub () x))
;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; has $.sig
(let ((new-slots (list (list :name 'sv-sig
  :readers '(sv-sig)
  :writers '((setf sv-sig))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Sub)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Sub :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Sub))
  (block mp6-function
    (let ((sv-sig nil)(sv-pos nil)(sv-block nil)(sv-str nil)) (setf sv-sig (sv-sig sv-self))(setf sv-pos (sv-positional sv-sig ))(setf sv-block (let ((m (make-instance 'mp-MiniPerl6-Lisp-LexicalBlock))) (setf (sv-block m) (sv-block sv-self)) m))(dolist (sv-field sv-pos) (progn (setf sv-str (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list (sv-emit sv-field ) " ")))))))(if (sv-bool sv-str) (progn (setf sv-str (format nil "~{~a~}" (list "&optional " sv-str)))) (progn ))(if (sv-bool (sv-name sv-self)) (progn (format nil "~{~a~}" (list "(defun " (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_identifier (sv-name sv-self)) (format nil "~{~a~}" (list " (" (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list ")" (format nil "~{~a~}" (list (sv-newline (proto-mp-Main) ) (format nil "~{~a~}" (list "  (block mp6-function " (format nil "~{~a~}" (list (sv-emit sv-block ) (format nil "~{~a~}" (list "))" (sv-newline (proto-mp-Main) )))))))))))))))))))) (progn (format nil "~{~a~}" (list "(lambda " (format nil "~{~a~}" (list (sv-name sv-self) (format nil "~{~a~}" (list " (" (format nil "~{~a~}" (list sv-str (format nil "~{~a~}" (list ")" (format nil "~{~a~}" (list (sv-newline (proto-mp-Main) ) (format nil "~{~a~}" (list "  (block mp6-function " (format nil "~{~a~}" (list (sv-emit sv-block ) (format nil "~{~a~}" (list "))" (sv-newline (proto-mp-Main) ))))))))))))))))))))))))




;; class Do
(defpackage mp-Do
  (:use common-lisp))
;; (in-package mp-Do)
(if (not (ignore-errors (find-class 'mp-Do)))
  (defclass mp-Do () ()))

(let (x) 
  (setq x (make-instance 'mp-Do))
  (defun proto-mp-Do () x))
;; has $.block
(let ((new-slots (list (list :name 'sv-block
  :readers '(sv-block)
  :writers '((setf sv-block))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Do)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Do :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Do))
  (block mp6-function
    (let ((sv-block nil)) (setf sv-block (let ((m (make-instance 'mp-MiniPerl6-Lisp-LexicalBlock))) (setf (sv-block m) (sv-block sv-self)) m))(return-from mp6-function (sv-emit sv-block )))))




;; class Use
(defpackage mp-Use
  (:use common-lisp))
;; (in-package mp-Use)
(if (not (ignore-errors (find-class 'mp-Use)))
  (defclass mp-Use () ()))

(let (x) 
  (setq x (make-instance 'mp-Use))
  (defun proto-mp-Use () x))
;; has $.mod
(let ((new-slots (list (list :name 'sv-mod
  :readers '(sv-mod)
  :writers '((setf sv-mod))
  :initform 'nil
  :initfunction (constantly nil)))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Use)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Use :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Use))
  (block mp6-function
    (progn (format nil "~{~a~}" (list (sv-newline (proto-mp-Main) ) (format nil "~{~a~}" (list ";; use " (format nil "~{~a~}" (list (mp-Main::sv-to_lisp_namespace (sv-mod sv-self)) (sv-newline (proto-mp-Main) ))))))))))




