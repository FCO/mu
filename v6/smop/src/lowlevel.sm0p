/* This is the lowlevel implementation of the basic object management
 * which is the default object management for the smop responder
 * interfaces. As explained in the public headers, this doesn't mean
 * that using this is mandatory, it is available so you can use it in
 * your custom responder interfaces.
 */

#include <smop.h>
#include <smop_mold.h>
#include <smop_lowlevel.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>

/* The SMOP_LOWLEVEL_MEM_TRACE define will enable a trace on the
 * allocs and frees of your objecs, and should give you a warning when
 * this objects are still left during vm shutdown.
 */
#ifdef SMOP_LOWLEVEL_MEM_TRACE

static int trace_list_alloc;
static int trace_list_size;
typedef struct memory_block {
   void* address;
   size_t size; 
   int live;
   int root;
   int object;
} memory_block;
static memory_block* trace_list;

int trace_list_find(void* address, int start, int end) {
  if (start == end) {
    return start;
  } else {
    int middle = (end + start) / 2;
    if (address < trace_list[middle].address) {
      return trace_list_find(address, start, middle);
    } else if (address > trace_list[middle].address) {
      if (start == middle) {
        return end;
      } else {
        return trace_list_find(address, middle, end);
      }
    } else {
      return middle;
    }
  }
}

void smop_mem_mark_as_live(void* address) {
  int i = trace_list_find(address,0,trace_list_size);
  if (trace_list[i].address != address) return;
  if (trace_list[i].live) return;
  printf("marking as live:%p %s\n",address,trace_list[i].object ? ((SMOP__Object*)address)->RI->id : "primitive memory chunk");
  trace_list[i].live = 1;
  void** content = (void**) address;
  while (content < (void**) (address+trace_list[i].size)) {
    //printf("%p\n",*content);
    smop_mem_mark_as_live(*content);
    content++;
  }
}
void smop_mem_mark_phase(void** roots) {
    int i;
    for (i = 0;i < trace_list_size;i++) {
      trace_list[i].live = 0;
    }
    for (i = 0;i < trace_list_size;i++) {
      if (trace_list[i].root) {
        printf("{\n");; 
        smop_mem_mark_as_live(trace_list[i].address);
        printf("}\n");; 
      }
    }
    while (*roots) {
      printf("ROOT object %p\n",*roots);
      smop_mem_mark_as_live(*roots);
      roots++;
    }
}
void smop_mem_mark_as_roots() {
    int i;
    for (i = 0;i < trace_list_size;i++) {
      trace_list[i].root = 1;
    }
}
void smop_mem_print_dead_objects(void) {
  int i;
  for (i = 0; i < trace_list_size; i++) {
    if (!trace_list[i].live && trace_list[i].object) fprintf(stderr,"SMOP_LOWLEVEL_MEM_TRACE] Dead object on trace_list: %p (%s)\n",trace_list[i].address,SMOP_RI(trace_list[i].address)->id);
  }
}

void smop_mem_trace_add(void* address,size_t size,int object) {

#ifdef SMOP_LOWLEVEL_MEM_DEBUG
  fprintf(stderr,"[SMOP_LOWLEVEL_MEM_DEBUG] Alloc: %p\n",address);
#endif
  if (trace_list_alloc <= trace_list_size + 1) {
    trace_list = realloc(trace_list, sizeof(memory_block) * (trace_list_alloc + 1024));
    assert(trace_list);
    trace_list_alloc += 1024;
    memset(&trace_list[trace_list_size], 0, sizeof(memory_block) * (trace_list_alloc - trace_list_size));
  }

  int pos = 0;
  if (trace_list_size > 0) {
    pos = trace_list_find(address,0,trace_list_size);
    memmove(&trace_list[pos+1],&trace_list[pos], sizeof(memory_block)*(trace_list_size - pos));
  }
  trace_list[pos].address = address;
  trace_list[pos].size    = size;
  trace_list[pos].root    = 0;
  trace_list[pos].object  = object;


  trace_list_size++;
}

void smop_mem_trace_del(void* address) {
#ifdef SMOP_LOWLEVEL_MEM_DEBUG
  fprintf(stderr,"[SMOP_LOWLEVEL_MEM_DEBUG] Free: %p\n",address);
#endif
  int pos = trace_list_find(address,0,trace_list_size);
  memmove(&trace_list[pos],&trace_list[pos+1], sizeof(memory_block)*(trace_list_size - pos));
  trace_list[trace_list_size - 1].address = 0;
  trace_list_size--;

}

#endif



SMOP__Object* smop_lowlevel_alloc(size_t size) {
  SMOP__Object* y = calloc(1,size);
  assert(y);
  SMOP_LOWLEVEL_INTERNAL* internal = calloc(1,sizeof(SMOP_LOWLEVEL_INTERNAL));
  assert(internal);
  y->data = internal;
  internal->ref_cnt = 1;
  internal->rwlock = calloc(1,sizeof(pthread_rwlock_t));
  assert(internal->rwlock);
  assert(pthread_rwlock_init(internal->rwlock, NULL) == 0);
#ifdef SMOP_LOWLEVEL_MEM_TRACE
  smop_mem_trace_add(y,size,1);
#endif
  return y;
}

void smop_lowlevel_free(SMOP__Object* value) {
  pthread_rwlock_destroy(((SMOP_LOWLEVEL_INTERNAL*)value->data)->rwlock);
  free(((SMOP_LOWLEVEL_INTERNAL*)value->data)->rwlock);
  free(value->data);
  free(value);
}

void* smop_calloc(size_t nmemb, size_t size) {
  void* block = calloc(nmemb,size); 
#ifdef SMOP_LOWLEVEL_MEM_TRACE
   smop_mem_trace_add(block,nmemb*size,0);
#endif
  return block;
}

void* smop_malloc(size_t size) {
  void* block = malloc(size); 
#ifdef SMOP_LOWLEVEL_MEM_TRACE
   smop_mem_trace_add(block,size,0);
#endif
  return block;
}

void* smop_realloc(void *ptr, size_t size) {
  void* block = realloc(ptr,size);
#ifdef SMOP_LOWLEVEL_MEM_TRACE
  smop_mem_trace_del(ptr);
  smop_mem_trace_add(block,size,0);
#endif
  return block;
}

void smop_free(void *ptr) {
#ifdef SMOP_LOWLEVEL_MEM_TRACE
  smop_mem_trace_del(ptr);
#endif
  free(ptr);
}





static SMOP__Object* lowlevelop_reference(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  return obj;
}

static SMOP__Object* lowlevelop_release(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  return obj;
}

void smop_lowlevel_init() {
#ifdef SMOP_LOWLEVEL_MEM_TRACE
  trace_list_alloc = 1024;
  trace_list = calloc(trace_list_alloc, sizeof(memory_block));
  trace_list_size = 0;
  assert(trace_list);
#endif
}

void smop_lowlevel_destr() {
#ifdef SMOP_LOWLEVEL_MEM_TRACE
  int i;
  for (i = 0; i < trace_list_size; i++) {
    if (trace_list[i].object) fprintf(stderr,"[SMOP_LOWLEVEL_MEM_TRACE] Leaking variable in global destruction: %p (%s)\n",trace_list[i].address,SMOP_RI(trace_list[i].address)->id);
  }
  free(trace_list);
#endif
}

SMOP__Object* smop_lowlevel_refcnt_inc(SMOP__Object* interpreter, SMOP__ResponderInterface* ri, SMOP__Object* value) {
  smop_lowlevel_wrlock(value);
  ((SMOP_LOWLEVEL_INTERNAL*)value->data)->ref_cnt++;
  smop_lowlevel_unlock(value);
  return value;
}

SMOP__Object* smop_lowlevel_refcnt_dec(SMOP__Object* interpreter, SMOP__ResponderInterface* ri, SMOP__Object* value) {
  smop_lowlevel_wrlock(value);
  ((SMOP_LOWLEVEL_INTERNAL*)value->data)->ref_cnt--;
  if (((SMOP_LOWLEVEL_INTERNAL*)value->data)->ref_cnt <= 0) {
#ifdef SMOP_LOWLEVEL_MEM_DEBUG
    fprintf(stderr,"[SMOP_LOWLEVEL_MEM_DEBUG] will destroy: %p, %s\n",value,SMOP_RI(value)->id);
#endif
    ((SMOP_LOWLEVEL_INTERNAL*)value->data)->ref_cnt = 999; // force it as to not getting here again...
    smop_lowlevel_unlock(value);

    if (interpreter == SMOP__INTPTR__InterpreterInstance) {

      if ((SMOP__Object*)SMOP_RI(value) == SMOP__INTPTR__InterpreterInstance ||
          (SMOP__Object*)SMOP_RI(value) == SMOP__NATIVE__capture) {

        SMOP_DISPATCH(interpreter, SMOP_RI(value), SMOP__ID__DESTROYALL, value);

      } else {
        SMOP_DISPATCH(interpreter, SMOP_RI(value), SMOP__ID__DESTROYALL, SMOP__NATIVE__capture_create(interpreter,value,NULL,NULL));

      }
#ifdef SMOP_LOWLEVEL_MEM_TRACE
      smop_mem_trace_del(value);
#endif

      smop_lowlevel_free(value);
    } else if ((SMOP__Object*)SMOP_RI(value) == SMOP__Mold ||
               (SMOP__Object*)SMOP_RI(value) == SMOP__Mold__Frame) {
        SMOP_DISPATCH(interpreter, SMOP_RI(value), SMOP__ID__DESTROYALL, SMOP__NATIVE__capture_create(interpreter,value,NULL,NULL));
#ifdef SMOP_LOWLEVEL_MEM_TRACE
      smop_mem_trace_del(value);
#endif
      smop_lowlevel_free(value);
    } else if ((SMOP__Object*)SMOP_RI(value) == SMOP__INTPTR__InterpreterInstance ||
               (SMOP__Object*)SMOP_RI(value) == SMOP__NATIVE__capture) {

      SMOP_DISPATCH(interpreter, SMOP_RI(value), SMOP__ID__DESTROYALL, value);
#ifdef SMOP_LOWLEVEL_MEM_TRACE
      smop_mem_trace_del(value);
#endif

      smop_lowlevel_free(value);

    } else {
      SMOP__Object* current = SMOP_DISPATCH(interpreter, SMOP_RI(interpreter), SMOP__ID__continuation,
                                             SMOP__NATIVE__capture_create(interpreter,SMOP_REFERENCE(interpreter,interpreter),NULL,NULL));
      SMOP__Object* free_obj = q:m0ld {
        my $interpreter;
        my $current;
        my $value;
        my $void = $value."DESTROYALL"($value);
        $void = $interpreter."goto"($current);
      };
      SMOP__Object* frame = SMOP__Mold__Frame_create(interpreter,SMOP_REFERENCE(interpreter,free_obj));
      mold_reg_set(interpreter,frame,0,SMOP_REFERENCE(interpreter,interpreter));
      mold_reg_set(interpreter,frame,1,current);
      mold_reg_set(interpreter,frame,2,value);
      SMOP_DISPATCH(interpreter, SMOP_RI(interpreter), SMOP__ID__goto,  frame);
#ifdef SMOP_LOWLEVEL_MEM_TRACE
      smop_mem_trace_del(value);
#endif
      //smop_lowlevel_free(value);
      SMOP_RELEASE(interpreter,free_obj);
    }
    return NULL;
  } else {
    smop_lowlevel_unlock(value);
    return value;
  }
}

SMOP__Object* smop_lowlevel_generic_reference(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  if ((SMOP__Object*)responder != obj) {
    smop_lowlevel_refcnt_inc(interpreter, responder, obj);
  }
  return obj;
}

SMOP__Object* smop_lowlevel_generic_release(SMOP__Object* interpreter, SMOP__ResponderInterface* responder, SMOP__Object* obj) {
  if ((SMOP__Object*)responder != obj) {
    smop_lowlevel_refcnt_dec(interpreter, responder, obj);
  }
  return obj;
}

void smop_lowlevel_rdlock(SMOP__Object* value) {
  assert(pthread_rwlock_rdlock(((SMOP_LOWLEVEL_INTERNAL*)value->data)->rwlock) == 0);
}
void smop_lowlevel_wrlock(SMOP__Object* value) {
  assert(pthread_rwlock_wrlock(((SMOP_LOWLEVEL_INTERNAL*)value->data)->rwlock) == 0);
}
void smop_lowlevel_unlock(SMOP__Object* value) {
  assert(pthread_rwlock_unlock(((SMOP_LOWLEVEL_INTERNAL*)value->data)->rwlock) == 0);
}
