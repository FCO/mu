%include <smop_p5.h>
%attr PerlInterpreter* interpreter
%RI.id p5 interpreter
%prefix smop_p5interpreter
%prototype SMOP__P5Interpreter

%method eval
  PerlInterpreter* my_perl = ((smop_p5interpreter_struct*)invocant)->interpreter;
  SMOP__Object* obj = SMOP__NATIVE__capture_positional(interpreter,capture,0);
  if (SMOP_RI(obj) == SMOP_RI(SMOP__ID__new)) {
    int len;
    char* str = SMOP__NATIVE__idconst_fetch(obj,&len);
    char* str_with_null = malloc(sizeof(char) * (len+1));
    strncpy(str_with_null,str,len);
    str_with_null[len] = '\0';

    ret = SMOP__P5__SV_create(interpreter,invocant,eval_pv(str_with_null, TRUE));
    free(str_with_null);
  } else {
    printf("only constant identifiers can be passed to eval :(\n");
  }
  SMOP_RELEASE(interpreter,obj);
%method DESTROYALL
  printf("DESTROY ALL HUMANS!!!\n");
  PerlInterpreter* my_perl = ((smop_p5interpreter_struct*)invocant)->interpreter;
  printf("[%p]\n",my_perl);
  perl_destruct(my_perl);
  perl_free(my_perl);
  PERL_SYS_TERM();
%method FETCH
  ___VALUE_FETCH___
%method STORE
  ___VALUE_STORE___

%method new

  ret =  smop_lowlevel_alloc(sizeof(smop_p5interpreter_struct));
  ret->RI = RI;
  PERL_SYS_INIT3(0,NULL,NULL);
  PerlInterpreter* my_perl = perl_alloc();
  PERL_SET_CONTEXT(my_perl);
  perl_construct(my_perl);
  char *embedding[] = { "", "-e", "0" };
  perl_parse(my_perl, NULL, 3, embedding, NULL);
  PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
  perl_run(my_perl);
  ((smop_p5interpreter_struct*)ret)->interpreter = my_perl;
%{
  PerlInterpreter* SMOP__P5__p5interpreter_unbox(SMOP__Object* interpreter,SMOP__Object* p5interpreter) {
   assert(p5interpreter->RI == RI);
   return ((smop_p5interpreter_struct*)p5interpreter)->interpreter; 
  }
%}
