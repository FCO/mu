#!/usr/local/bin/perl -Ilib

# Core modules
use strict;
use warnings;
use utf8;
use feature qw(say switch);
use English;
use Getopt::Long;

# CPAN modules
use File::Slurp;
use Term::ANSIColor;
use YAML::Dumper;

# And finally our modules
use STD;
use Syntax::Highlight::Perl6;

=head1 NAME

STD_syntax_highlight - Highlights Perl 6 source code using STD.pm

=head1 SYNOPSIS

    # read from standard input
    STD_syntax_highlight

    # print ansi-escaped text for 'comp_unit'
    STD_syntax_highlight foo.pl

    # print separate html, css and javascript files
    STD_syntax_highlight --full-html=foo.full.html --clean-html foo.pl

    # print ansi-escaped text for with 'statementlist' as the top-level rule
    STD_syntax_highlight foo.pl statementlist

    # write simple html output to foo.pl.html
    STD_syntax_highlight --simple-html=foo.pl.html foo.pl

    # write simple snippet html output to foo.pl.html
    STD_syntax_highlight --snippet-html=foo.pl.html foo.pl

    # write simple ansi-colored output to STDOUT
    STD_syntax_highlight --ansi-text=- foo.pl

    # write yaml output to STDOUT (can be useful to build filters)
    STD_syntax_highlight --yaml=- foo.pl
=head1 SUBROUTINES

=over

=cut

my ($clean_html,$help) = (0,0);
my ($full_html,$simple_html,$snippet_html,$ansi_text,$yaml) = (0,0,0,0,0);
my $file; 

=item main
Your standard main method
=cut
sub main {
    #process the command line
    GetOptions(
        "clean-html"=>\$clean_html,
        "full-html=s"=>\$full_html,
        "simple-html=s"=>\$simple_html,
        "snippet-html=s"=>\$snippet_html,
        "ansi-text=s"=>\$ansi_text,
        "yaml=s"=>\$yaml,
        "help"=>\$help
    );

    if ($help) {
        die <<"HELP";
USAGE: 
    $PROGRAM_NAME [options] [file] [rule]

    where 'file' is optional; if omitted or is '-' then 
    STDIN will be used. And 'options' can be one of the following:

    --clean-html    
        generates separate html,css and javascript

    --full-html=filename   
        write full-mode html to filename (- for STDOUT)

    --simple-html=filename   
        write simple-mode html to filename (- for STDOUT)

    --snippet-html=filename
        This is typically ideal for inline html code. (- for STDOUT)

    --ansi-text=filename   
        write simple-mode ansi color text to filename (- for STDOUT)

    --yaml=filename
        writes a dump of redspans to filename (- for STDOUT)
HELP
    }

    #default is --simple-html=- if no option is selected
    if(!($simple_html || $full_html || $snippet_html || $yaml) && !$ansi_text) {
        $ansi_text = '-';    
    }

    #start parsing...
    $file = shift @ARGV;
    my $what = shift @ARGV // 'comp_unit';

    #what is the meaning of your input file?
    if(!$file || $file eq '-') {
        # i think you mean standard input
        $file = \*STDIN;        
    } else {
        # no it is should be a file, let me check
        unless(-r $file) {
            die "Could not open '$file' for reading\n";
        }
    }

    # and finally print out the html code
    highlight_match($file);
}

=item write_output

Writes the output to a file or STDOUT
=cut
sub write_output {
    my ($file, $output) = @ARG;
    if($file eq '-') {
        say $output;
    } else {
        use open OUT => ':utf8';
        open FILE, ">$file" or
            die "Cannot open $file for writing: $OS_ERROR\n";
        say FILE $output;
        close FILE;
    }
}

=item highlight_match

Returns the generated Perl6 highlighted HTML.
=cut
sub highlight_match {
    my $filename = shift;

    my $p = new Syntax::Highlight::Perl6(
        text => read_file($filename)
    );
    if($full_html) {
        write_output $full_html, $p->full_html;
    }
    if($simple_html) {
        write_output $simple_html, $p->simple_html;
    }
    if($snippet_html) {
        write_output $snippet_html, $p->snippet_html;
    }
    if($ansi_text) {
        write_output $ansi_text, $p->ansi_text;
    }
    if($yaml) {
        my $dumper = YAML::Dumper->new;
        $dumper->indent_width(4);
        write_output $yaml, $dumper->dump($p->parse_trees);
    }
}

=back

=head1 AUTHOR

Written by Ahmad M. Zawawi (azawawi), Moritz Lenz and Paweł Murias (pmurias)

The project idea was inspired by Moritz Lenz (moritz)
See http://www.nntp.perl.org/group/perl.perl6.users/2008/07/msg788.html

The initial STD tree traversal code was written by Paweł Murias (pmurias).

The redspans traversal code was written by Larry Wall (TimToady).
redspans stands for "...'red' for "reductions", and 'spans' from the 
from/to span calculations"

The browser code was written by Ahmad M. Zawawi (azawawi)
=cut

main @ARGV;
