
=encoding utf8

=head1 标题
  
大纲 十二：对象

=head1 作者

    Larry Wall <larry@wall.org>

=head1 译者

    尹茂荣(ariimood@gmail.com)

=head1 版本 

    创建日期：2004年 10 月 27 号
    最后修改: 2009年 7 月

    版本：87
    SVN ：28440

=head1 Overview

=head1 概述

This synopsis summarizes Apocalypse 12, which discusses object-oriented
programming.

本文档概括了启示录十二，它讨论了面向对象编程。

=head1 Classes

=head1 类

A class is a module declared with the C<class> keyword.  As with
modules, the public storage, interface, and name of the class is
represented by a package and its name, which is usually (but not
necessarily) a global name.

类是一个模块，它声明了C<class>关键字。和模块一样，公共存储、接口
和类名是由包和它的名字表示的，它通常（但不一定）是全局名。

Taken as an object, a class represents all of the possible values of
its type, and the class object can thus be used as a proxy for any
"real" object of that type in calculating what a generic object of
that type can do.  The class object is an Object, but it is not a
Class, because there is no mandatory Class class in Perl 6.  We wish
to support both class-based and prototype-based OO programming.
So all metaprogramming is done through the current object's C<HOW>
object, which can delegate metaprogramming to any metamodel it likes.
However, by default, objects derived from Object support a fairly
standard class-based model.

作为一个对象，类代表全部可能的类型值，正因如此类对象在计算一个真正的类
对象能做什么时被用做任何真正类型对象的代表。类对象是一个对象，但不是一
个类，因为在perl6中没有强制用户类。我们希望同时支持基于类和原型为基础的
面向对象编程。因为，所有的元编程是通过当前对象的C<HOW>对象编写的，对于它
喜欢的任何元模型可以委托元编程。但是，在默认情况下，对象来源于支持完全
标准的基于类模型的类。

There are two basic class declaration syntaxes:
有两个基本的类声明的语法：

    class Foo;          # rest of file is class definition
    has $.foo;

    class Bar { has $.bar }     # block is class definition

The first form is allowed only as the first declaration in a compilation
unit (that is, file or eval string).

第一种形式只允许作为第一个声明的汇编单位（即文件或eval字符串）

If the class body consists of a single statement consisting of a
single C<< prefix:<...> >> (yada) listop, the class name is introduced
without a definition, and a second declaration of that class in the
same scope does not complain about redefinition.  Thus you may
forward-declare your classes:

如果类主体由单C<<前缀：<...> >>（yada）listop组成的单一声明组成，类名就
会没有定义的加以引用，以及在同一范围内对类的第二次声明就不会介意有重定义。
因此你可能前置声明类：

    class A {...}     # introduce A as a class name without definition
    class B {...}     # introduce B as a class name without definition

    my A $root .= new(:a(B));

    class A { 
        has B $.a;
    }

    class B { 
        has A $.b;
    }

As this example demonstrates, this allows for mutually recursive class
definitions (though, of course, it can't allow recursive inheritance).

正如这个例子演示的一样，这个类允许相互递归的定义（不过，不允许递归继承）。

It is also possible to extend classes via the C<augment> declarator,
but that is considered somewhat antisocial and should not be used
for forward declarations.

也可以通过C<augment>声明符扩展类，但是这样被认为是反社会，也不能用于之前
的声明。

[Conjecture: we may also allow the C<proto> and C<multi> modifiers
to explicitly declare classes with multiple bodies participating in
a single definition intentionally.]

[猜想：我们也可以让C<proto>和C<multi>修饰符来明确声明带有多种类体的类，这
些类体有意参与单一声明]

A named class declaration can occur as part of an expression, just like
named subroutine declarations.

已命名的类声明作为表达的一部分存在，就像已命名的子程序声明。

Classes are primarily for instance management, not code reuse.
Consider using C<roles> when you simply want to factor out
common code.

类主要用于实例管理，不是代码的重用。当你只是想要提取出通用代码是考虑使用
C<roles>。

Perl 6 supports multiple inheritance, anonymous classes, and autoboxing.

Perl 6支持多重继承，匿名类和自动打包。

All public method calls are "virtual" in the C++ sense.  More
surprisingly, any class name mentioned in a method is also considered
virtual, that is, polymorphic on the actual type of the object.

在C++语言中，所有公共方法的调用都是“虚拟”的。更奇怪的是，在方法中提到的
任何类名也都视为虚拟，即实际对象类型的多态。

You may derive from any built-in type, but the derivation of a low-level
type like C<int> may only add behaviors, not change the representation.
Use composition and/or delegation to change the representation.

有可能来自任何内置样式，但低层次的推导，如C<int>，可能只需增加行为，而不是
改变其表示的意思。使用成分和/或来改变其代表意。

Since there are no barewords in Perl 6, bare class names must be
predeclared.  You can predeclare a stub class and fill it in later
just as you would a subroutine.

由于在Perl6中没有重述，裸类名必须提前声明。你可以先提前声明一个stub类，在后来
的子程序中再填写它。

You can force interpretation of a name as a class or type name using
the C<::> prefix.  In an rvalue context the C<::> prefix is a no-op,
but in a declarational context, it binds a new type name within the
declaration's scope along with anything else being declared by the declaration.

在使用C<..>前缀时，可以把名称解释为类名或类型名。在一个右值范围内的C<..>是没有
操作的，但在声明背景下，它把在声明范围之内的新类型名和其他已经宣布的生命一同绑
定。

Without a C<my> or other scoping declarator, a bare C<class>
declarator declares an C<our> declarator, that is, a name within
the current package.  Since class files begin parsing in the
C<GLOBAL> package, the first class declaration in the file installs
itself as a global name, and subsequent declarations then install
themselves into the current class rather than the global package.

如果没有C<my>或其他范围的声明符，C<class>的裸声明符声明了C<our>声明符，
即在当前包中的一个名字。由于类文件解析C<GLOBAL>包，在文件中的第一个类
声明把它自己设为一个全局名，随后的声明把它们本身放回当前包而不是全局包。


Hence, to declare an inner class in the current package (or module, or
class), use C<our class> or just C<class>.  To declare a lexically
scoped class, use C<my class>.  Class names are always searched
for from innermost scopes to outermost.  As with an initial C<::>,
the presence of a C<::> within the name does not imply globalness
(unlike in Perl 5).  So the outward search can look in children
of the searched namespaces.

因此，用C<our class>或C<class>来声明当前包（或是模型或是类）中的内部类。
用C<my class>声明词汇范围类。类名总是从最内层到最外层范围找寻。与初始的
C<..>一样，在名称内部 C<..>的出现并不意味着全局性（不像在perl5中）。因此
，向外找寻可以看看要找寻名称空间的子类。          

Class traits are set using C<is>:

类特征的设置使用C<is>：

    class MyStruct is rw {...}

An "isa" is just a trait that happens to be another class:

“isa”仅仅是另一个类的特征：

    class Dog is Mammal {...}

MI is specified with multiple C<is> modifiers:

MI是指定的多个C<is>的修饰语：

    class Dog is Mammal is Pet {...}

Roles use C<does> instead of C<is>:

Roles用C<does>代替C<is>：

    class Dog is Mammal does Pet {...}

You may put these inside as well:

也可以把这些代码放在里面：

    class Dog {
        is Mammal;
        does Pet;
        ...
    }

Every object (including any class-based object) delegates to an instance of
its metaclass.  You can get at the metaclass of any object via the
C<HOW> method, which returns an instance of the metaclass.  A "class" object is just considered an "empty"
instance in Perl 6, more properly called a "prototype" or "generic" object, or just
"type object".  Perl 6 doesn't really have any classes named C<Class>.
Types of all kinds are instead named via these undefined type objects,
which are considered to have exactly the same type as an instantiated
version of themsleves.  But such type objects are inert, and do not
manage the state of class instances.

每个对象（包括基于类的对象）代表元类的一个实例。通过C<HOW>方法可以得到任何对象的
元类，该方法返回元类的一个实例。“类”对象在Perl6中仅被认为一个“空”实例，称其
“原型”或“通用”对象，或者“类型的对象”可能更合适。Perl6中没有一个类是以C<Class>命名的。各种类型的命名是由未定义的类型对象替代的，这些类型对象被认为和它们自己的实例版本有相同的类型。但是这种类型对象有惰性，不能控制类实例的状态。

The actual object that manages instances is the metaclass object pointed to by the
C<HOW> syntax.  So when you say "C<Dog>", you're referring to both a
package and a type object, the latter of which points to the
object representing the class via C<HOW>.  The type object
differs from an instance object not by having a different
type but rather in the extent to which it is defined.  Some objects
may tell you that they are defined, while others may tell you that
they are undefined.  That's up to the object, and depends on how the
metaclass chooses to dispatch the C<.defined> method.

控制实例的真实对象是由C<HOW>语法指定的元类对象。因为，当你说"C<Dog>"时，你指的是
包和类型对象，后者指通过C<HOW>语法指定的代表类的对象。类型对象不同于实例对象不是因为具有不同的类型而是它被定义的程度不同。某些对象可能告诉你它们已经定义了，然而其他对象可能告诉你它们还没有被定义。这取决于对象，取决于元类如何选择派遣C<.defined>的方法。

The notation C<^Dog> is syntactic sugar for C<Dog.HOW()>, so C<^> can be
considered the "class" sigil when you want to talk about the current
metaclass instance.

记号C<Dog>是C<Dog.HOW()>句法块，所以当你想要讨论当前元类实例时C<^>可以被认为是"类"的印记。

Classes are open and non-final by default, but may easily be closed
or finalized not by themselves but by the entire application, provided
nobody issued an explicit compile-time request that the class stay open
or non-final.  (Or a site policy could close any applications that use
the policy.)  Platforms that do dynamic loading of sub-applications
probably don't want to close or finalize classes wholesale, however.

Roles take on some of the compile-time function of closed classes,
so you should probably use those instead anyway.

类默认的是公开和非确定的，但是可能很容易被整个应用程序而不是它们本身封闭或确定下来，如果没有人提出一个明确的编译时间要求，类仍是开放和非确定的。（或者站点政策可能关闭任何使用这项政策的应用程序。）做动态加载子程序的平台可不能不想关闭或确定大批类，然而，角色承担已封闭类的某些编译时间功能，所以无论如何你应该使用他们来替代。

A private class can be declared using C<my>; most privacy issues are
handled with lexical scoping in Perl 6.  The fact that importation
is lexical by default also means that any names your class imports
are also private by default.
私有类可以使用C<my>声明；最隐蔽的问题的通过在Perl6中的词法作用域解决。输入词法是默认的也意味着任何类输入的名字默认也是私有的。

In an anonymous class declaration, C<::> by itself may represent the
anonymous class name if desired:

在匿名类声明中，如果需要的话C<..>本身就代表匿名类名。

    class {...}                # ok
    class is Mammal {...}      # WRONG
    class :: is Mammal {...}   # ok
    class { is Mammal; ...}    # also ok

=head1 Methods

=head1 方法

Methods are routines declared in a class with the C<method> keyword:

方法是惯常的程序，并在一个有C<method>关键字的类中声明的：

    method doit ($a, $b, $c) { ... }
    method doit ($self: $a, $b, $c) { ... }
    method doit (MyName $self: $a, $b, $c) { ... }
    method doit (::?CLASS $self: $a, $b, $c) { ... }

Declaration of the invocant is optional.  You may always access the
current invocant using the keyword C<self>.  You need not declare the
invocant's type, since the lexical class of the invocant is known in any
event because methods must be declared in the class of the invocant,
though of course the actual (virtual) type may be a derived type of
the lexical type.  You could declare a more restrictive type, but
that would probably be a bad thing for proper polymorphism.  You may
explicitly type the invocant with the lexical type, but any check for
that will be optimized away.  (The current lexically-determined class
may always be named as C<::?CLASS> even in anonymous classes or roles.)

隐语的声明是有选择的。你可能总是用C<self>关键字访问当前的隐语。你不必声明隐语的类型，因为隐语的词法类在任何情况下都是已知的，这是因为在隐语类中方法必须是声明的，当然，尽管实际的（虚拟的）类型可能是词法类型的派生类型。你可能声明了更严格的类型，但是这对于固有的多态性来说可能是不利的。你可以用词汇类型明确隐语类型，但对它的任何检查都将被优化掉。（即使在匿名类或角色中当前由词汇决定的类一直被命名为C<::?CLASS>）

To mark an explicit invocant, just put a colon after it:

标记一个明确的隐语，只需把一个冒号放在它后面：

    method doit ($x: $a, $b, $c) { ... }

This is true also for multi methods:

这对多方法也适用：

    multi method doit ($x: $a; $b; $c) { ... }

If you declare an explicit invocant for an Array type using an array variable,
you may use that directly in list context to produce its elements

如果你使用数组变量为数组类型声明了一个明确的隐语，你可以直接在列表范围内使用它来产生它的元素。

    method push3 (@x: $a, $b, $c) { ... any(@x) ... }

Note that the C<self> function is not context sensitive and thus always
returns the current object as a single item even in list context.
Hence if your current object happens to be an array but you did not
declare it with an explicit array variable, you need to explicitly
access the elements of the array somehow:

注意到C<self>函数在上下文不易受影响，因此即使在列表范围内也总是把当前对象返回作为单一条目。因此，如果当前对象正好是没有用明确的数组变量声明的数组，你需要以某种方法访问数组元素。

    any(self)     # WRONG
    any(self[])   # okay
    any(@(self))  # okay
    any(@self)    # WRONG unless you declared @self yourself

Private methods are declared using C<!>:

私有方式使用C<!>声明：

    method !think (Brain $self: $thought)

(Such methods are completely invisible to ordinary method calls, and are
in fact called with a different syntax that uses C<!> in place of the C<.>
character.  See below.)

（这种方法对于普通的方法调用是完全可视的，而且实际上是由不同的句法调用，这种句法使用C<!>替代C<.>特性。看看下边的。）

Unlike with most other declarations, C<method> declarations do not
default to C<our> semantics, or even C<my> semantics, but rather
C<has> semantics.  So instead of installing a symbol into a lexical
or package symbol table, they merely install a public or private
method in the current class or role via calls to its metaobject.
(Likewise for C<submethod> declarations--see L</Submethods> below.)

不像大多数其他的声明，C<method>的声明默认的不是C<our>语义或C<my>语义，而是C<has>语义。所以他们仅把一个公共的或是私有的方法通过调用元对象放置到当前类或是作用域中而不是把一个标记安置到词汇或是包的符号表中。（同样地，对于C<submethod>声明--看下下面的L</Submethod>）。

Use of an explicit C<has> declarator has no effect on the declaration.
You may install additional aliases to the method in the lexical scope
using C<my> or in the current package using C<our>.  These aliases
are named with C<&foo> notation and return a C<Routine> object that
may be called as a subroutine, in which case you must supply the
expected invocant as the first argument.

在声明时使用一个明确的C<has>声明符没有作用。你可以在词汇范围内使用C<my>或在当前包中使用C<our>把额外的别名加到方法中。这些别名使用C<&foo>记号命名并返回C<Routine>对象，可以称为子程序。在这种情况下，你必须提供可能的隐语作为第一个参数。

To call an ordinary method with ordinary method-dispatch semantics,
use either the dot notation or indirect object notation:

为了使用普通的方法调度语义调动一个普通方法，可以使用点表示法或是间接对象表示法：

    $obj.doit(1,2,3)
    doit $obj: 1,2,3

Indirect object notation now requires a colon after the invocant,
even if there are no arguments after the colon:

间接对象表示法要求在隐语后有一个冒号，即使在冒号后面没有参数：

    $handle.close;
    close $handle:;

To reject method call and only consider subs, simply omit the colon
from the invocation line:

要拒绝方法调用并且只考虑替代品，只需从调用线省略冒号：

    close($handle);
    close $handle;

However, here the built-in B<IO> class defines C<method close () is export>,
which puts a C<multi sub close (IO)> in scope by default.  Thus if the
C<$handle> evaluates to an IO object, then the two subroutine calls above
are still translated into method calls.


然而，这里内置的B<IO>类定义C<method close () is export>，这样使C<multi sub close (IO)>分在默认范围内。正因如此，如果C<$handle>作为一个IO对象，那么上述的两个子程序调用仍被翻译成方法调用。

Dot notation can omit the invocant if it's in C<$_>:

如果是在C<$_>中，点表示法能省略隐语：

    .doit(1,2,3)

Note that there is no corresponding notation for private methods.

请注意，对于私有方法没有相应的标记。

    !doit(1,2,3)        # WRONG, would be parsed as not(doit(1,2,3))
    self!doit(1,2,3)    # okay

There are several forms of indirection for the method name.  You can
replace the identifier with a quoted string, and it will be evaluated
as a quote and then the result of that is used as the method name.

有几种间接形式的方法名。你可以替换引号字符串的标示符，并且它将作为一个引号使用，这样做的后果是它被用作方法名。

    $obj."$methodname"(1,2,3)   # use contents of $methodname as method name
    $obj.'$methodname'(1,2,3)   # no interpolation; call method with $ in name!

    $obj!"$methodname"          # indirect call to private method name

Within an interpolation, the double-quoted form may not contain
whitespace.  This does what the user expects in the common case of
a quoted string ending with a period:

在插入时，双引号形式可能不包含空白。这就是用户在以句号结束的引号字符串的普通情况下所期望的：

    say "Foo = $foo.";

If you really want to call a method with whitespace, you may work
around this restriction with a closure interpolation:

如果你真想要调用一个空白的方法，你可以用封闭插值来取消这种限制：

    say "Foo = {$foo."a method"}";  # OK

[Note: to help catch the mistaken use of C<< infix:<.> >> as a string
concatenation operator, Perl 6 will warn you about "useless use of
quotes" at compile time if the string inside quotes is an identifier.
(It does not warn about non-identifier strings, but such strings are
likely to produce missing method errors at run time in any case.)
Also, if there is whitespace around an intended C<.> concatenation,
it cannot be parsed as a method call at all; instead it fails at
compile time because standard Perl 6 has a pseudo C<< infix:<.> >> operator
that always fails at compile time.]

[注意：为了发现C<< infix:<.> >>误用为字符连接符，在编译时如果引用的字符串是标识符，perl6会出现“引用无效”的警告。（它不警告非字符串字符，但是这种字符串在任何情况下运行时可能会产生疏忽的方法错误。）同样，如果在C<.>串联符旁有空白，它不能被解析为方法调用;因而在编译时就会出错，因为标准的Perl6有一个虚拟的C<< infix:<.> >>操作符，所以总会编译不成功。]

For situations where you already have a method located, you
can use a simple scalar variable in place of method name:

在你已经把方法定位的情况下，可以使用一个简单的标准变量代替方法名：

    $methodobj = $foo ?? &bar !! &baz;
    $obj.$methodobj(1,2,3)

or more succinctly but less readably:

或许更简洁但是不易读：

    $obj.$($foo ?? &bar !! &baz)(1,2,3)

The variable must contain a C<Callable> object (usually of type C<Code>), that is, a closure of some
sort.  Regardless of whether the closure was defined as a method or
a sub or a block, the closure is called directly without any class
dispatch; from the closure's point of view, however, it is always
called as a method, with the object as its first argument, and the
rest of the arguments second, third, and so on.   For instance, such
a closure may be used to abstract a "navigational" path through a
data structure without specifying the root of the path till later:

该变量必须包含一个C<Callable>对象（通常是C型<Code>）,即，一些种类的关闭。无论封闭被定义为一个方法或一个替代者或一个块，封闭总是被没有任何类调度的直接调用；然而，从封闭的角度看，它一直作为一个方法被调用，并且对象是其第一个参数，其他的参数第二，第三，以此类推。例如，这个闭包可能用来提取“导航”路径，并通过数据结构而不是到后来指定的根路径：

    $locator = -> $root, $x, $y { $root.<foo>[$x]<bar>{$y}[3] }
    $obj.$locator(42,"baz")  # $obj<foo>[42]<bar><baz>[3]

    $locator = { .<here> }
    $obj.$locator            # $obj<here>

As a convenient form of documentation, such a closure may also be written
in the form of an anonymous method:

作为程序说明书的简便形式，这个闭包也可能已匿名方法的形式写下来：

    $locator = method ($root: $x, $y) { $root.<foo>[$x]<bar>{$y}[3] }
    $obj.$locator(42,"baz")  # $obj<foo>[42]<bar><baz>[3]

    $locator = method { self.<here> }
    $obj.$locator            # $obj<here>

Note however that, like any anonymous closure, an anonymous method
can only be dispatched to directly, like a sub.  You may, of course,
bind an anonymous method to the name of a method in a class's public
interface, in which case it is no longer anonymous, and may be
dispatched to normally via the class.  (And in fact, when the normal
method dispatcher is calling individual candidates in its candidate
list, it calls each candidate as a sub, not as a method, or you'd
end up with recursive dispatchers.)  But fundamentally, there's
no such thing as a method closure.  The C<method> declarator on an
anonymous method has the primary effect of making the declaration
of the invocant optional.  (It also makes it an official C<Routine>
that can be returned from, just as if you'd used C<sub> to declare it.)

但是请注意，像任何匿名封装，匿名方法同sub一样只能直接调用。当然，你可以把匿名方法和在类的公共接口中的方法名绑定到一起，在这种情况下，它不在是匿名的，而且或许通过类能被正常的调用。（事实上，当普通的调度方法调用候选单中的个别待选项时，它作为sub调用每个待选项，而不是作为一种方法，或许你应该以递归调用结束。）但是从根本上讲，没有封装方法这回事。匿名方法的C<method>声明符对于非限制性隐语的声明起重要作用。（这也使正式的C<Routine>可返回，就像之前用C<sub>声明一样。）

Instead of a scalar variable, an array variable may also be used:

不像标量变量，数组变量也可以这样使用：

    $obj.@candidates(1,2,3)

As with the scalar variant, string method names are not allowed, only
C<Callable> objects, The list is treated as a list of candidates to
call.  After the first successful call the rest of the candidates are
discarded.  Failure of the current candidate is indicated by calling
C<nextwith> or C<nextsame> (see L</Calling sets of methods> below).

与标量变量一样，字符串方法名实不允许的，只能是C<Callable>对象。这个列表被视为要调用的候选名单。第一的成功调用后，其余的待选项都被丢弃。当前候选项的调用失败是通过调用C<nextwith>或C<nextsame>显示的。（看看下面的L</Calling sets of method>）.

Note also that the

请也注意

    $obj.$candidates(1,2,3)

form may dispatch to a list of candidates if C<$candidates> is either
a list or a special C<Code> object representing a partial dispatch to a
list of candidates.  If C<$candidates> (or any element of C<@candidates>)
is a List or Array object it is expanded out recursively until C<Callable>
candidates are found.  The call fails if it hits a candidate that is
neither C<Callable> nor expandable.

如果C<$candidates>是一个列表或是一个专门的C<Code>对象并该对象表示对候选列表的局部调动，那么形式可能对待选列表的调用。如果C<$candidates>（或者C<@candidates>的任一元素）是一个列表或数组对象，那么直到C<Callable>待选项出现时才可以递归地扩大。如果它遇到的待选项不是C<Callable>也不是可扩大的，调用就会失败。

Another form of indirection relies on the fact that operators are named
using a variant on hash subscript notation, which gives you these forms:

另一种间接形式取决于操作符是用哈希表中的下标变体命名的，并给你这些形式：

    $x.infix:{$op}($y)
    $x.prefix:{$op}
    $x.postfix:{$op}

Generally you see these with the literal angle bracket form of subscript:

通常你在下标的字面角度括号形式看到这些：

    $a.infix:<*>($b)      # equivalent to $a * $b
    $a.prefix:<++>        # equivalent to ++$a
    $a.postfix:<++>       # equivalent to $a++

If you omit the syntactic category, the call will be dispatched according
to the number of arguments either as "prefix" or as "infix":

如果你省略句法范畴，调用将会根据参数的数量加以调度，要么事“前缀”，要么是“缀”：

    $a.:<+>($b)           # equivalent to $a + $b
    $a.:<++>              # equivalent to ++$a
    $a.:<!>               # equivalent to !$a
    @a.:<[*]>             # equivalent to [*] @a

But it's probably better to spell out the syntactic category when
the actual operator is not obvious:

当实际操作不明显时阐明句法范畴可能会好些：

    $x.infix:{$op}($y)
    $x.prefix:{$op}

You must use a special syntax to call a private method:

你必须使用一个特殊的句法来调用一个私有方法：

    $mybrain!think($pinky)
    self!think($pinky)

For a call on your own private method, you may also use the attribute-ish form:

对于你自己私有方法的调用，你也可以使用属性杂交形式：

    $!think($pinky)     # short for $(self!think($pinky))

Parentheses (or a colon) are required on the dot/bang notations if there
are any arguments (not counting adverbial arguments).  There may be
no space between the method name and the left parenthesis unless you
make use of "unspace":

如果有任何参数（不包括状语参数），括号（或是冒号）在点或bang标记中都是必须的。方法名和左括号间没有空格除非你使用“非空”：

    .doit       # okay, no arguments
    .doit()     # okay, no arguments
    .doit ()    # ILLEGAL (two terms in a row)
    .doit\ ()   # okay, no arguments, same as .doit() (unspace form)

Note that the named method call forms are special and do not use the dot
form of postfix.  If you attempt to use the postfix operator form, it
will assume you want to call the method with no arguments and then call
the result of I<that>:

请注意命名方法调用形式是特别的，不能用点形式的后缀。如果你试图使用后缀操作符形式，它就会认为你想调用没有参数的方法，并且调用I<that>的结果：

    .doit.()    # okay, no arguments *twice*, same as .doit().()
    .doit\ .()  # okay, no arguments *twice*, same as .doit.().() (unspace form)

However, you can turn any of the named forms above into a list
operator by appending a colon:

但是 ，你可以通过附加一个冒号把上面任何命名形式转换成一个列表操作：

    .doit: 1,2,3        # okay, three arguments
    .doit(1): 2,3       # okay, one argument plus list
    .doit (): 1,2,3     # ILLEGAL (two terms in a row)

In particular, this allows us to pass a closure in addition to the
"normal" arguments:


特别是，除了“正常”参数这能使我们传递闭包：

    .doit: { $^a <=> $^b }              # okay
    .doit(): { $^a <=> $^b }            # okay
    .doit(1,2,3): { $^a <=> $^b }       # okay

In case of ambiguity between indirect object notation and dot form,
the nearest thing wins:

在间接对象标记和点形式有歧义的情况下，以最近的为准：

    dothis $obj.dothat: 1,2,3

means

    dothis ($obj.dothat(1,2,3))

and you must say

    dothis ($obj.dothat): 1,2,3

or

    $obj.dothat.dothis: 1,2,3

if you mean the other thing.

如果你指的是另一个事情。

Also note that if any term in a list is a bare closure or pointy
sub, it will be considered to be the final argument of its list
unless the closure's right curly is followed immediately by comma
or colon.  In particular, a method call does *not* extend
the list, so you can say:

还要注意，如果列表中的任何字节是裸封装或是pointy sub，它就会被认为是列表中的最后参数，除非紧随封装权限其后的是逗号或冒号。特别是，如果一个方法调用不能扩展列表，你可以说：

    @list.grep: { $_ % 2 }.map: { $_ - 1 }.say

and that will be taken as equivalent to

也可以等同于：

    @list.grep({ $_ % 2 }).map({ $_ - 1 }).say

Methods (and subs) may be declared as lvalues with C<is rw>.  You can
use an argumentless C<rw> method anywhere you can use a variable,
including in C<temp> and C<let> statements.  (In fact, you can use an
C<rw> method with arguments as a variable as long as the arguments are
used only to identify the actual value to change, and don't otherwise
have strange side effects that differ between rvalue and lvalue usage.
Setter methods that expect the new value as an argument do not fall
into the well-behaved category, however.)

方法（及subs）可能被声明为C<is rw>的左值。在可以使用变量的任何地方，你都可以使用一个参数较少的C<rw>方法，在C<temp>和C<let>的陈述有涉及。（事实上，你可以使用一个带参数的C<rw>方法作为变数，只要这些参数只是用于识别变化的实际值，否则在右值和左值用法中就不会有不同的奇怪的副作用。然而，想把新值用作参数的Setter方法不会变为well-behaved的类别。）

Method calls on mutable scalars always go to the object contained in
the scalar (autoboxing value types as necessary):

可变标量的方法调用总是载在带有标量的对象上（自动封装值类型是必要的）：

    $result = $object.doit();
    $length = "mystring".codes;

Method calls on non-scalar variables just calls the C<Array>, C<Hash>
or C<Code> object bound to the variable:

无标量变量的方法调用只是调用与变量绑在一起的C<Array>，C<Hash>或C<Code>对象：

    $elems = @array.elems;
    @keys  = %hash.keys;
    $sig   = &sub.signature;

Use the prefix C<VAR> macro on a scalar variable to get at its
underlying C<Scalar> object:

使用标量变量的前缀C<UAR>宏获取底层的C<Scalar>对象：

    if VAR($scalar).readonly {...}

C<VAR> is a no-op on a non-scalar variables and values:

C<UAR>是基于非标量变量和值的非操作符：

    VAR(1);     # 1
    VAR(@x);    # @x

There's also a corresponding C<< postfix:<.VAR> >> macro that can be used
as if it were a method:

也有一个相应的C<< postfix:<.VAR> >>宏可以用就像它是一个方法：

    if $scalar.VAR.readonly {...}

(But since it's a macro, C<VAR> is not dispatched as a real method.
To dispatch to a real C<.VAR> method, use the indirect C<$obj."VAR">
form.)

（但是，由于它是一个宏，C<VAR>不能作为一个真正的方法被调度。为了调度一个真正的C<.VAR>方法，要使用间接C<$obj."VAR">形式。）

You can also get at the container through the appropriate symbol table:

通过符号表你也可以在容器中获取：

    if MY::<$scalar>.readonly {...}

=head1 Class methods

=head1 类方法

Other OO languages give you the ability to declare "class" methods that either don't
need or actively prohibit calls on instances.  Perl 6 gives you a choice.
If you declare an ordinary method, it can function as a "class" method when you
pass it a type object such as "C<Dog>" regardless of how defined the prototype
object is, as long as the method body doesn't try to access any information that
is undefined in the current instance.

其他的面向对象语言可以给你声明“类”方法的权限，这种权限要么不需要要么就可以有效阻止对实例的调用。Perl6给你了一个选择。如果你声明一个通用方法，当你赋予它一个像“C<Dog>”的类型对象是它可以作为一个“类”方法，不管原型对象是怎么定义的，只要方法体没有获取在当前实例中没有定义的的任何形式。

Alternately, you can associate a method with the current metaclass instance, which
as a singleton object knows your package, and can function as a more traditional
"class" method:

或者，你可以把一个方法和当前的元类实例联系起来，这样作为一个单独的对象知道你的包，而且可以作为一个更加传统的“类”方法：

    our $count;
    method ^count { return $count }

Such a I<metaclass method> is always delegated to the C<HOW> object just as methods like
C<.does> are, so it's possible to call this as C<Dog.count> or C<$dog.count>.
However, best practice is probably to call such a class method as C<Dog.^count>
or C<$dog.^count> to make it clear that it's in its own namespace separate
from ordinary methods, and so that your class method cannot be accidentally
overridden by an ordinary method in a subclass--presuming you don't want to
allow for that possibility.

这样一个<声明方法>通常和C语言里面实现面向对象一样。所以称其为C<Dog.count>或C<$dog.count>是可以的。然而，为了解释它在自己的命名空间中且区别于普通方法，最优方法可能是称这样一种类方法为C<Dog.count>或C<$dog.^count>。因此，你的类方法不能由子类中的普通方法所覆盖--假设你不想允许这样一种可能性。

=head1 Submethods

=head1 子方法

Submethods are for declaring infrastructural methods that shouldn't
be inherited by subclasses, such as initializers:

子方法是声明的基础方法，不能由子类继承，就像初始化：

    submethod BUILD ($arg) {
        $.attr = $arg;
    }

Apart from the keyword, submethod declaration and call syntax is
identical to method syntax.  You may mix methods and submethods of
the same name within the class hierarchy, but only the methods are
visible to derived classes via inheritance.  A submethod is called
only when a method call is dispatched directly to the current class.

除了关键字，子方法声明和调用语法和方法语法相同。在类层次结构中，你可以混合方法和相同名字的子方法，但是仅有方法对由继承派生的类是可视的。只有当一个方法直接被当前类调用时，子方法才被调用。

Conjecture: in order to catch spelling errors it is a compile-time
warning to define a submethod in any class that does not inherit the
corresponding method name from some base class.  More importantly, this
would help safeguard Liskov substitutability. (But note that the
standard C<Object> class already supplies a default C<BUILD> and C<new>.)

试猜想：为了找到拼写错误，为了定义在任一类中的子方法，编译时的警告不能从一些基本类继承相应的方法名。更重要的是，这将有助于维护Liskow的替代性。（但是要注意标准的c<对象>已经提供了一种默认的C<BUILD>和C<new>方法。）

=head1 Attributes

=head1 属性

Attributes are stored in an opaque datatype, not in a hash.  Not even
the class has to care how they're stored, since they're declared much like
ordinary variables.  Instead of C<my>, use C<has>:

属性存储在一个不透明的数据类型中，而不是哈希表中。即使类也要顾及它们是怎样存储的，因为他们的声明很像普通变量。用C<has>代替C<my>：

    class Dog is Mammal {
        has $.name = "fido";
        has $.tail is rw;
        has @.legs;
        has $!brain;
        ...
    }

Public attributes have a secondary sigil of "dot", indicating
the automatic generation of an accessor method of the same name.
Private attributes use an exclamation to indicate that no public accessor is
generated.

公共属性具有次要的“点”印记，表明一个同名的事件的存取器方法的自动生成。私有属性使用一个感叹号来表明没有公共的事件存取器生成。

        has $!brain;

The "true name" of the private variable always has the exclamation, but
much like with C<our> variables, you may declare a lexically scoped alias
to the private variable by saying:

私有变量的“真正名称”一直有感叹号，但是更像C<our>变量，你可以通过下面的方法声明对私有变量声明一个此法作用域别名：

        has $brain;     # also declares $!brain;

As with the C<!> declaration, no accessor is generated.

和C<!>一样，没有事件存取器生成。

And any later references to the private variable within the same block
may either use or omit the exclamation, as you wish to emphasize or
ignore the privacy of the variable.  Outside the block, you must use
the C<!> form.  If you declare with the C<!> form, you must use that
form consistently everywhere.  If you declare with the C<.> form, you
also get the private C<!> form as a non-virtual name for the actual
storage location, and you may use either C<!> or C<.> form anywhere
within the class, even if the class is reopened.  Outside the class
you must use the public C<.> form, or rely on a method call (which
can be a private method call, but only for trusted classes).

并且任何后来提及的同块中的私有变量可能使用或者省略感叹号，就像你强调或者忽略变量的私有性。在块外部，你必须使用C<!>格式。如果你用C<!>声明，你必须在每个地方都一直使用这种格式。如果你用C<.>格式声明，对于实际的存储位置你也可以得到一个私用的C<!>格式作为一个非实质的名字，而且在类中的任何地方你也可以使用C<!>或C<.>格式，即使类是重新开放的。在类外部，你必须使用公共的C<.>格式，或依赖方法调用（这可能是一个私用的方法调用，但是仅仅是对于可信的类。）

For public attributes, some traits are copied to the accessor method.
The C<rw> trait causes the generated accessor to be declared C<rw>,
making it an lvalue method.  The default is a read-only accessor.

对于公共属性，一些特性被复制到事件存取器方法中。C<rw>特征导致生成的事件存取器成为声明的C<rw>，使之成为一个左值方法。默认是只读存储器。

If you declare the class as C<rw>, then all the class's attributes
default to C<rw>, much like a C struct.

如果你声明类为C<rw>，那么所有的类的属性都默认为C<rw>，更像一个C结构。

You may write your own accessors to override any or all of the
autogenerated ones.

你可以写自己的存储器来覆盖任何或所有自动生成的。

The attribute variables may be used within instance methods to refer
directly to the attribute values.  Outside the instance methods, the
only access to attributes is through the accessors since an object has
to be specified.  The dot form of attribute variables may be used in
derived classes because the dot form always implies a virtual accessor
call.  Every I<dot> declaration also declares a corresponding private
I<exclamation> storage location, and the exclamation form may be used
only in the actual class, not in derived classes.  Reference to the
internal storage location via C<$!foo> should generally be restricted
to submethods.  Ordinary methods should stick to the C<$.foo> form.

属性变量可能用于实例方法内部来直接针对属性值。在实例方法外部，获得属性的唯一方法就是通过存储器，因为对象是确定的。属性变量的点格式可以用在派生类中，因为点格式总是意味着一个虚拟的存储器调用。每个I<dot>声明也声明了一个相应的私有I<exclamation>存储位置，以及感叹号的形式只能用于是实际类中，而不是在派生类中。通过C<$!foo>涉及到得内部存储位置通常限制到子方法中。普通方法应坚持C<$.foo>格式。

In fact, within submethods, use of the C<$.foo> form on attributes
that are available as C<$!foo> (that is, that are declared directly
by this class) is illegal and produces a dire compile-time warning
(which may be suppressed).  Within a submethod the C<$.foo> form may
only be used on attributes from parent classes, because only the parent
classes' part of the object is guaranteed to be in a consistent state
(because C<BUILDALL> call's the parent classes' C<BUILD> routines
first).  If you attempt to get around this by declaring C<BUILD> as
a method rather than a submethod, that will also be flagged as a dire
(but suppressible) compile-time warning.  (It is I<possible> to define
an inheritable C<BUILD> routine if you have access to all the metadata
for the current class, but it's not easy, and it certainly doesn't
happen by accident just because you change C<submethod> to C<method>.)

事实上，在子方法内部，使用属性的C<$.foo>形式是合理的，就像C<$!foo>（即，直接由这个类声明）是非法的并产生了可怕的编译时警告（可能被禁止）。在一个子方法内部，C<$.foo>形式可能仅用于父类的属性中，因为只有对象的父类部分被认为是一致的状态（因为C<BUILDALL>调用的父类C<BUILD>程序第一）。如果你试图通过声明C<BUILD>为一个方法而不是一个子方法避开这，这也将认为一个可怕的<但可抑制>编译时警告。（如果你已经得到了当前类的所有元数据用I<possible>定义一个可继承的C<BUILD>程序，但并不简单，它当然不是偶然产生，仅仅因为你把C<子方法>变为C<方法>。）

Because C<$.foo>, C<@.foo>, C<%.foo>, C<&.foo> are just shorthands of
C<self.foo> with different contexts, the class does not need to declare
any of those as an attribute -- a C<method foo> declaration can work
just as well.

因为C<$.foo>,C<@.foo>,C<%foo>,C<&.foo>只是不同语境中C<self.foo>的速记法，类不需声明它们中的任何一个作为一种属性--C<method>声明也能起作用。

As with the normal method call forms, only dotless parentheses may contain arguments.
If you use the C<.()> form it will perform an extra level of indirection after
the method call:

和正常的方法调用形式一样，只点括号可能包含参数。如果你用C<.()>格式，在方法调用后它将执行一个额外的间接水平：

    self.foo(1,2,3);    # a regular method call
    self.foo.(1,2,3);   # self.foo().(1,2,3), call .() on closure returned by .foo
    $.foo(1,2,3);       # calls self.foo under $ context
    $.foo.(1,2,3);      # $.foo().(1,2,3), call .() on closure returned by .foo
    &.foo(1,2,3);       # calls self.foo under & context
    &.foo.(1,2,3);      # &.foo().(1,2,3), call .() on closure returned by .foo

Pseudo-assignment to an attribute declaration specifies the default
value.  The value on the right is treated as an implicit closure and
evaluated at object build time, that is, when the object is being
constructed, not when class is being composed.  To refer to a value
computed at compilation or composition time, you can either use a
temporary or a temporal block of some sort:

伪分配给一个属性声明指明了默认值。右边的值被认为是一个隐含的封装和对象的评估，即，当对象正被构建的时候，不是类被构成的时候。若要在编译或写程序时引用一个计算的值，你可以使用一个临时的或某种形式的时间块：

    has $.r = rand;     # each object gets different random value

    constant $random = rand;
    has $.r = $random;  # every object gets same value

    has $.r = BEGIN { rand };
    has $.r = INIT { rand };
    has $.r = ENTER { rand };
    has $.r = FIRST { rand };
    has $.r = constant $myrand = rand;

When it is called at C<BUILD> time, the topic of the implicit closure
will be the attribute being initialized, while "self" refers to the
entire object being initialized.  The closure will be called at the
end of the C<BUILD> only if the attribute is not otherwise initialized
in either the signature or the body of the C<BUILD>.  The closure
actually defines the body of an anonymous method, so C<self> is available
with whatever attributes are constructed by that point in time (including
all parent attributes).  The initializers are run in order of declaration
within the class, so a given initializer may refer back to an attribute
defined in a preceding C<has> declaration.

当它在C<BUILD>时间被调用时，隐含封装问题将会只被初始化的属性，然而“self”引用了已出始化得整个对象。只要属性在C<BUILD>特征或结构体内没有被初始化，封装将会在C<BUILD>结束时被调用。封装实际上定义了一个匿名的方法体，所以C<self>对于任何由那点最后构建的属性是可用的（包括所有的父属性）。在类内部初始化按序执行，所以一个指定的初始化可以重新指定在先前C<has>声明中已定义的属性。

Class attributes are declared with either C<my> or C<our>.  The only
difference from ordinary C<my> or C<our> variables is that an accessor
is generated according to the secondary sigil:

类属性用C<my>或C<our>声明。唯一不同于普通C<my>或C<our>的是存储器是根据第二个印记生成的：

    our $.count;        # generates a public read-only .count accessor
    our %!cache is rw;  # generates no public accessor
    my  $.count;        # generates a public read-only .count accessor
    my  %!cache is rw;  # generates no public accessor

=head1 Construction and Initialization

=head1 结构和初始化

All classes inherit a default C<new> constructor from C<Object>.  It
expects all arguments to be named parameters initializing attributes of
the same name.  You may write your own C<new> to override the default,
or write constructors with any other name you like.  As in Perl 5,
a constructor is any routine that calls C<bless>.  Unlike in Perl 5,
you call it as a method on the class object (though any object may be
used as a class object), passing the candidate as the first argument.
To bless a hash as in Perl 5, say:

所有的类从C<对象>继承默认的C<new>构造器。它希望所有的参数能被命名为具有初始化相同属性名的参数。你可能写你自己的C<new>来覆盖默认的，或写其他任何你喜欢的名字的构造器。就如在Perl5中，构造器是调用C<bless>的任一程序。不像在Perl5中，可以作为一个类对象的方法调用它（尽管任何一个对象都可以用做一个类对象），通过作为第一个参数的带选项。像在Perl5中bless哈希表，比如说：

    $object = $class.bless({k1 => $v1, k2 => $v2, ...});

However, the normal way to create a candidate to bless is by calling
C<CREATE> (which by default creates an opaque object):

然而，构造bless函数待选项的通常方法是调用C<CREATE>(默认的是创造一个模糊对象)：

    $object = $class.bless($class.CREATE(), k1 => $v1, k2 => $v2, ...)
    $object = $class.bless($class.CREATE(), :k1($v1), :k2($v2), ...)  # same

Alternatively, you can pass C<Whatever> and have C<bless> call CREATE
for you.

或者，你可以通过C<Whatever>和C<bless>调用CREATE.

    $object = $class.bless(*, k1 => $v1, k2 => $v2, ...)

In addition to the candidate positional argument, C<bless> also
allows one or more positional arguments representing autovivifying
type objects.  Such an object looks like a type name followed by a
hash subscript (see "Autovivifying objects" below).  These are used
to initialize superclasses.

除了待定参数的待选项外，C<bless>也允许一个或更多的待定参数代表自定义类型对象。这样一个对象看起来像一个由哈希表下标紧随的类型名（看看下面的“自定义对象”）。这些被用于初始化超级类。

Other than the candidate object and any autovivifying type objects,
all arguments to C<bless> must be named arguments, not positional.
Hence, the main purpose of custom constructors is to turn positional
arguments into named arguments for C<bless>.  The C<bless> method
allows an object to be used for its class invocant.  (Your constructor
need not allow this).  In any case, the object is not used as a prototype.
Use C<.clone> instead of C<.bless> if that's what you mean.

除了待定对象和任何自动生成化类型对象，C<bless>所有的参数必须命名为参数，不是待定的。因此，自定义构造函数的主要目的是把待定参数变为C<bless>的命名参数。C<bless>方法允许对象被用于它的类调用者。（你的构造器不允许这样）。无论在何种情况下，对象都不能用做原型，如果你的意思是那样的，用C<.clone>替代C<.bless>。

Any named arguments to C<bless> are automatically passed to the
C<CREATE> and C<BUILD> routines.  If you wish to pass special options
to the C<CREATE> routine (such as an alternate representation),
call C<CREATE> yourself and then pass the resulting candidate to C<.bless>:

C<bless>的任何已命名的参数都自动传递给C<CREATE>和C<BUILD>例程。如果你想传递特殊选项给C<CREATE>例程（如一个可替换的代表），调用C<CREATE>,然后把待选结果传递给C<.bless>：

    my $candidate = $class.CREATE(:repr<P6opaque>);
    $object = $class.bless($candidate, :k1($v1), :k2($v2))

For the built-in default C<CREATE> method, C<P6opaque> is the default
representation.  Other possibilities are C<P6hash>, C<P5hash>,
C<P5array>, C<PyDict>, C<Cstruct>, etc.

对于内置默认的C<CREATE>方法，C<P6opaque>是默认的表示方法。其他可能是C<P6hash>, C<P5hash>,
C<P5array>, C<PyDict>, C<Cstruct>, 等等.

The C<bless> function automatically calls all appropriate C<BUILD>
routines by calling the C<BUILDALL> routine for the current class,
which initializes the object in least-derived to most-derived order.
C<DESTROY> and C<DESTROYALL> work the same way, only in reverse.

C<bless>函数通过为当前类调用C<BUILD>例程自动调用所有适当的C<BUILD>例程，它以从最少派生到最多派生的顺序初始化对象。C<DESTROY> 和C<DESTROYALL> 也是用相同的方式工作，只是顺序相反。

The default C<BUILD> and C<BUILDALL> are inherited from C<Object>,
so you need to write initialization routines only if you wish to
modify the default behavior.  The C<bless> function automatically
passes the appropriate argument list to the C<BUILD> of its various
parent classes.  If the type of the parent class corresponds to one
of the type objects passed to bless, that type object's argument
list is used.  Otherwise all the arguments to bless are passed to
the parent class's C<BUILD>.  For the final C<BUILD> of the current
object, all the arguments to C<bless> are passed to the C<BUILD>, so
it can deal with any type objects that need special handling.  (It is
allowed to pass type objects that don't correspond to any parent class.)

默认的C<BUILD>和C<BUILDALL>是从C<Object>继承得到的，所以如果你想修改默认的行为你就需要写初始程序。C<bless>函数自动传递合适的参数列表给它各种父类的C<BUILD>。如果父类的类型对应于一个传递给bless的类型对象，那么类型对象参数列表时可用的。否则bless的所有参数都传递给父类的C<BUILD>。对于当前对象最后的C<BUILD>,C<bless>的所有参数都传递给C<BUILD>，所有它能够处理需要特殊操作的任一类型对象。（这允许传递类型对象和任何父类不符合。）

    class Dog is Animal {...}
    my $pet = Dog.new( :name<Fido>, Animal{ :blood<warm>, :legs(4) } );

Here we are using an autovivifying C<Animal> type object to specify what
the arguments to C<Animal>'s C<BUILD> routine should look like.  (It does
not actually autovivify an C<Animal> apart from the one being created.)

这里我们使用一个自动生成的C<Animal>类型对象来确认C<Animal>的C<BUILD>程序的参数应该看起来像什么。（实际上除了被创造不能自动生成C<Animal>。）

You can clone an object, changing some of the attributes:

你可以复制一个对象，改变某些参数：

    $newdog = $olddog.clone(:trick<RollOver>);

You can write your own C<BUILD> submethod to control initialization.
If you name an attribute as a parameter, that attribute is initialized
directly, so

你可以写你自己的C<BUILD>子方法来控制初始化。如果你把属性命名为一个参数，属性就被直接初始化，因此

    submethod BUILD ($!tail, $!legs) {}

is equivalent to

相当于

    submethod BUILD ($tail, $legs) {
        $!tail = $tail;
        $!legs = $legs;
    }

Whether you write your own C<BUILD> or not, at the end of the C<BUILD>,
any default attribute values are implicitly copied into any attributes
that haven't otherwise been initialized.

不管你是否写你自己的C<BUILD>,在C<BUILD>末端任何默认的属性值都含蓄的复制到任何还没有被初始化的属性中。

=head1 Mutating methods

=head1 变异的方法

You can call an in-place mutator method like this:

你可以像这样调用一个合适的设置方法：

    @array .= sort;

If there is a C<self:sort> operator defined, that will be used.  Otherwise
one will be autogenerated from the ordinary C<sort> operator, on the
order of:

如果有一个定义的C<self：sort>，它将被使用。否则将从普通的C<sort>操作符自动生成，与下面的相似：

    @array = @array.sort;

One handy place for an in-place mutator is to call a constructor on a
variable of a known type:

对于一个内置的方法方便的地方是在调用一个已知类型的构造器：

    my Dog $spot .= new(:tail<LONG> :legs<SHORT>);

=head1 Calling sets of methods

=head1 调用方法集

For any method name, there may be some number of candidate methods
that could handle the request: typically, inherited methods or
multi variants.  The ordinary "dot" operator dispatches
to a method in the standard fashion.  There are also "dot" variants
that call some number of methods with the same name:

对于任何一个方法名，或许有一些处理请求的待选方法：一般，继承的方法多多种变型。通常的“点”操作符以一种标准的形式调度给方法。也有“点”变体，它用相同的名字调用一些方法：

    $object.meth(@args)   # calls one method or dies
    $object.?meth(@args)  # calls method if there is one, otherwise undef
    $object.*meth(@args)  # calls all methods (0 or more)
    $object.+meth(@args)  # calls all methods (1 or more)

The method name may be quoted when disambiguation is needed:

当需要解除疑惑时，可能需要引用方法名：

    $object."+meth"(@args)
    $object.'VAR'(@args)

As with ordinary calls, the identifier supplying the literal method
name may be replaced with an interpolated quote to specify the method
name indirectly.  It may also be replaced with an array to specify
the exact list of candidates to be considered:

和普通调用一样，提供文字识别方法名可能由以内插值替换的引用替代来直接确认方法名。也可能用数组取代来确认确切的待选列表：

    my @candidates := $object.WALK(:name<foo>, :breadth, :omit($?CLASS));
    $object.*@candidates(@args);

The C<WALK> method takes these arguments:

C<WALK>需要这些参数：

    :canonical      # canonical dispatch order
    :ascendant      # most-derived first, like destruction order
    :descendant     # least-derived first, like construction order
    :preorder       # like Perl 5 dispatch
    :breadth        # like multi dispatch

    :super              # only immediate parent classes
    :name<name>         # only classes containing named method declaration
    :omit(Selector)     # only classes that don't match selector
    :include(Selector)  # only classes that match selector

Any method can defer to the next candidate method in the list by
the special functions C<callsame>, C<callwith>, C<nextsame>, and
C<nextwith>.  The "same" variants reuse the original argument list
passed to the current method, whereas the "with" variants allow a
new argument list to be substituted for the rest of the candidates.
The "call" variants dispatch to the rest of the candidates and return
their values to the current method for subsequent processing, whereas
while the "next" variants don't return, but merely defer to the rest
of the candidate list:

任何方法都能通过特殊的函数C<callsame>, C<callwith>, C<nextsame>,和
C<nextwith>延迟列表中的下一个待选方法。“同一”变体重新利用原始参数列表传递给当前方法，但是对于待选项的剩余部分“with”变体允许取代一个新的参数列表。对于接下来的处理“call”变体调度给剩下的待选项并把它们的值返回给当前方法，但是当“next”变体不能返回时，仅能延迟到剩余的待选列表中：

    callsame;           # call with the original arguments (return here)
    callwith();         # call with no arguments (return here)
    callwith(1,2,3);    # call with a new set of arguments (return here)
    nextsame;           # redispatch with the original arguments (no return)
    nextwith();         # redispatch with no arguments (no return)
    nextwith(1,2,3);    # redispatch with a new set of arguments (no return)

For dispatches using C<.> and C<.?>, the return value is the
C<Capture> returned by the first method completed without deferring.
(Such a return value may in fact be failure, but it still counts as a
successful call from the standpoint of the dispatcher.)  Likewise the
return value of C<.*> and C<.+> is a list of C<Captures> returned by
those methods that ran to completion without deferring to next method.

使用C<.>和C<.?>调度，返回值是有第一个没有延迟完成的方法返回的C<Capture>（这样一种返回值可能实际上是失败的，但是从调度者的立场看它仍然能当作一个成功的调用。）同样地，C<.*>和C<.+>的返回值是由那些方法返回的C<Captures>的一个列表，那些方法不需要延迟下一个方法也能正常运行。

It is also possible to trim the candidate list so that the current
call is considered the final candidate.  (This is implicitly the case
already for the dispatch variants that want a single successful call.)
For the multiple call variants, C<lastcall> will cause the dispatcher
to throw away the rest of the candidate list, and the subsequent
return from the current method will produce the final C<Capture>
in the returned list.

也可以消减待选列表以便当前调用成为最后的待选项。（调度变量的这个例子隐含的需要一个单独的成功调用。）对于多重调用变量，C<lastcall>将会导致调度者丢弃待选列表中剩余的部分，并且从当前方法得到的紧随的返回值也将会在放回列表中产生最终的C<Capture>。

=head1 Parallel dispatch

=head1 平行调度



Any of the method call forms may be turned into a hyperoperator by
treating the method call as a postfix:

将方法调用视为一个后缀，任何一种方法调用形式都可能变成一个超超操作符：

    @object».meth(@args)   # calls one method on each
    @object».?meth(@args)  # calls method if there is one on each
    @object».*meth(@args)  # calls all methods (0 or more) on each
    @object».+meth(@args)  # calls all methods (1 or more) on each
    @object».=meth(@args)  # calls mutator method on each
    @object»!meth(@args)   # calls private method on each

The return value is a list with exactly the same number of elements
as C<@object>.  Each such return value is a C<Capture> or C<List> of C<Captures>
as specified above for the non-hyper "dot" variants.

返回值是一个列表，其元素数和C<@object>是相同的。作为指定的上面的非超“点”变量，每个这样的返回值是C<Captures>的一个C<Capture>或C<List>。

Hyperoperators treat a junction as a scalar value, so saying:

超操作符将一个联结点视为一个变量值，所以说：

    $junction».meth(@args);

is just like:

就像：

    $junction.meth(@args);

As with other forms of method call, the "meth" above may be replaced
with a quoted string or variable to do various forms of indirection.

和方法调用的其他形式一样，上面的“meth”可能被一个引用的字符串或变量取代以便能产生各种间接形式。

Note that, as with any hyper operator, the methods may be evaluated
in any order (although the method results are always returned in the
same order as the list of invocants).  Use an explicit loop if you
want to do something with ordered side effects, such as I/O.

注意，和任何超操作符一样，这些方法都可以以任何顺序评估（尽管方法的结果总是和调用者列表相同的顺序放回）。如果你想做一些带有有序副作用的东西使用一个明确的循环，比如I/O。

=head1 Multisubs and Multimethods

=head1 Multisubs 和多重方法

The "long name" of a subroutine or method includes the type signature
of its invocant arguments.  The "short name" doesn't.  If you put
C<multi> in front of any sub (or method) declaration, it allows
multiple long names to share a short name, provided all of them are
declared C<multi>.  (Putting C<proto> on the first such declaration has
the same effect, but usually you want to put the C<multi> explicitly
anyway for documentation.)  If a sub (or method) is not marked
with C<multi> and it is not within the package or lexical scope of
a C<proto> of the same short name, it is considered unique, an I<only>
sub.  You may mark a sub explicitly as C<only> if you're worried it
might be within the scope of a C<proto>, and you want to suppress
any other declarations within this scope.  An C<only> sub (or method)
doesn't share with anything outside of it or declared prior to it.
Only one such sub (or method) can inhabit a given namespace, and it
hides any outer subs (or less-derived methods) of the same short name.

一个子程序或方法的“方法”包括它的调用参数的类型签字。如果你把C<multi>放在任何sub（或方法）的前面，它就会允许多个长名分享一个短名字，如果它们中的所有都声明C<multi>的话。（把C<proto>放在第一个就像声明有相同的效应，但是通常你想明确地安置C<multi>。）如果一个子程序（或方法）没有标记C<multi>并且它也没有在包内或者相同简称的C<proto>的词汇范围内，它就个会被看做唯一的I<only>子程序。如果你担心sub可能在C<proto>的作用域内并且你想阻止在这个作用域中的所有声明，你可能会像C<only>一样明确标记sub。一个C<only>sub（或方法）不能在它外部分享任何东西，也不能在它之前声明。只有这样一个sub（或方法）能使用已有的名称空间，并且它能隐藏有相同简称的任何外部subs（或少派生方法）。

The default C<proto> declarations provided by Perl from the global
scope are I<not> automatically propagated to the user's scope
unless explicitly imported, so a C<sub> declaration there that
happens to be the same as a global multi is considered C<only> unless
explicitly marked C<multi>.  In the absence of such an explicit C<sub>
declaration, however, the global proto is used by the compiler in
the analysis of any calls to that short name.  (Since only list
operators may be post-declared, as soon as the compiler sees a
non-listop operator it is free to apply the global C<proto> since
any user-defined C<only> version of it must of necessity be declared
earlier in the user's lexical scope or not at all.)

由Perl从全局范围提供的默认的C<proto>声明是自动传播到用户范围的I<not>，除非准确输入，所以正好与全局可用相同的C<sub>声明被认为是C<only>除非准确的标记了C<multi>。然而，在这样一个明确的C<sub>声明之前，全局原型由编译者在调用简称的分析中使用。（由于只有列表操作符是后声明的，所以编译者一看到非列表操作符就把它视为免费适用全局C<proto>，因为任何由用户定义的C<only>版本必须在用户的词汇范围内声明或者一个也不用。）

A C<proto> may share dispatch with multis declared after it in the same scope,
but in that case it functions only as the final tie-breaker if the
inner multis can't decide among themselves what to do.  (It may
then, of course, decide to redispatch outside of the current scope.)

C<proto>在同一范围声明它之后可以和multis共享调度，但是在那种情况下如果内部的multis不能在它们之间觉得做什么，它的作用是仅仅作为最后的决胜机制。（当然，过后它可能决定重新调度当前范围外部的multis。）

Within its scope,
the signature of a C<proto> also nails down the presumed order
and naming of positional parameters, so that any multi call with named
arguments in that scope can presume to rearrange those arguments into
positional parameters based on that information.  (Unrecognized names
remain named arguments.)  Any other type information or traits attached
to the C<proto> are also shared by the routines within its scope,
so a C<proto> definition can be used to factor out common traits.
This is particularly useful for establishing grammatical categories
in a grammar by declaring a C<proto> C<token> or C<proto> C<rule>.  (Perl 6's
grammar does this, for instance.)

在其范围之内，C<proto>的签名也决定了假定的顺序和命名的位置参数，因此在那个范围内任何有命名参数的多重调用能够假定把那些参数重新安置到基于那个信息上的位置参数中。（无法识别的名字仍然是已命名参数。）任何粘附在C<proto>的其他类型信息或特征也都是有在它范围之内的程序共享的，所以一个C<proto>定义能够用于分离出普通的特性。这对于一个语法中通过声明C<proto>C<token>或C<proto> C<rule>建立语法目录相当有用。（例如，Perl6的语法就是这样。）

You can have multiple C<multi> variables of the same name in the
same scope, and they all share the same storage location and type.
Usually these are declared by one C<proto> declaration at the top,
and leaving the C<multi> implicit on the rest of the declarations.
You might do this when you suspect you'll have multiple declarations
of the same variable name (such code might be produced by a macro
or by a code generator, for instance) and you wish to suppress any
possible warnings about redefinition.

在同一范围内你可以有许多同名的C<multi>变量，并且它们也都共享相同的存储位置和类型。通常在开头由C<proto>的声明值声明，且在声明的剩余部分将C<multi>设为隐含的。当你怀疑你将要有许多相同变量名的声明时你可能会这样做（比如，这样的代码可能是由宏或代码生成器产生的）而且你希望阻止有关重新定义的任何可能警告。

In contrast, C<multi> routines can have only one instance of the long
name in any namespace, and that instance hides any outer (or less-derived)
routines with the same long name.  It does not hide any routines with
the same short name but a different long name.  In other words, multis
with the same short name can come from several different namespaces
provided their long names differ and their short names aren't hidden
by an C<only> declaration in some intermediate scope.

相反，C<multi>程序在名字空间内可以只有一个全名的例子，并且那个例子隐藏了同一全名的任何外部（或少派生）程序。它没有隐藏有相同简称但是不同全名的程序。换句话说，如果题目的全称不同且简称没有被在相同中间作用域的C<only>声明隐藏，那么有相同简称的multis能够来源于几个不同的命名空间。

When you call a routine with a particular short name, if there are
multiple visible long names, they are all considered candidates.
They are sorted into an order according to how close the run-time types
of the arguments match up with the declared types of the parameters of
each candidate.  The best candidate is called, unless there's a tie,
in which case the tied candidates are redispatched using any additional
tiebreaker strategies (see below).  For the purpose of this nominal typing,
no constrained type is considered to be a type name; instead the constrained type
is unwound into its base type plus constraint.  Only the base type upon
which the constrained type is based is considered for the nominal type
match (along with the fact that it is constrained).  That is, if you have a parameter:

当你调用一个有特殊简称的程序时，如果有许多可见的全称，它们都被认为待选项。根据参数的运行时类型与每个待选项参数的声明类型有多匹配，它们被整理成一个顺序。除非有关联，否则最好的待选项会被调用，在这种情况下使用任何附加的延长赛机制，有关的待选项将会被重新调度（看下面）。对于名义上的类型的目的，无约束类型被认为是一个类型名；相反，限约束类型在其基本类型上加以约束。只有基本类型被认为是名义上的类型匹配（连同它被约束的事实），其中约束类型是基于基本类型的。即，如果你有一个参数：

    subset Odd of Int where { $_ % 2 }
    multi foo (Odd $i) {...}

it is treated as if you'd instead said:

它将会按你说的那样使用：

    multi foo (Int $i where { $_ % 2 }) {...}

Any constrained type is considered to have a base type that is "epsilon" narrower than
the corresponding unconstrained type.  The compile-time topological sort
takes into account the presence of at least one constraint, but nothing about the
number or nature of any additional constraints.  If we think of Int' as
any constrained version of Int, then Int' is always tighter nominally than Int.
(Int' is a meta-notation, not Perl 6 syntax.)

任何约束类型被认为有一个基本类型，而且比相应的非约束类型“小量”窄。编译时拓扑排序考虑到至少有一个约束的存在，但是没有提交数量或任何额外约束的性质。如果我们把Int'看做Int的任何约束版本，那么名义上Int'一直比Int紧。（Int'是一个元符号，而不是Perl6的语法。）

The order in which candidates are considered is defined by a
topological sort based on the "type narrowness" of each candidate's
long name, where that in turn depends on the narrowness of each
parameter that is participating.  Identical types are considered tied.
Parameters whose types are not comparable are also considered tied.
A candidate is considered narrower than another candidate if at least
one of its parameters is narrower and all the rest of its parameters
are either narrower or tied.  Also, if the signature has any additional
required parameters not participating in the long name, the signature
as a whole is considered epsilon tighter than any signature without
extra parameters.  In essence, the remaining arguments are added to
the longname as if the user had declared a capture parameter to bind
the rest of the arguments, and that capture parameter has a constraint
that it must bind successfully to the additional required parameters.
All such signatures within a given rank are considered equivalent,
and subject to tiebreaker A below.

考虑到待选项的顺序是由基于每个待选项全称的“类型狭小”的拓扑排序定义的，这反过来依赖于每个正在使用的每个参数的narrowness。相同的类型被认为是连着的。如果一个待选项的其中一个参数比较狭隘，且它的参数的所有剩余部分也是狭隘或连着的，那么这个待选项就会被认为比另一个待选项狭隘。此外，如果签名有不包括在全名中的任何额外需求参数，这个签名作为一个整体就会认为比任何没有额外参数的签名稍微紧些。实质上，剩余的参数被加到全名中就像使用者已声明了已有的参数来绑定剩余参数，并且已有的参数有一个限制，那就是它必须成功地绑定到附加的需求参数上。在已给行中的所有的这些签名都被认为是相等的，且适合下面的中断连接A。

This defines the partial ordering of all the candidates.  If the
topological sort detects a circularity in the partial ordering,
all candidates in the circle are considered tied.  A warning will be
issued at C<CHECK> time if this is detected and there is no suitable
tiebreaker that could break the tie.

这确定了所有待选项的部分顺序。如果拓扑排序在部分排序中检测到一个循环，在这个循环中的所有待选项被认为是连着的。在C<CHECK>时如果这被检测到就会出现警告，并且没有合适的中断连接者能够中断连接。

There are three tiebreaking modes, in increasing order of desperation:

有三种中断连接方式，

    A) run-time constraint processing
    B) use of a candidate marked with "is default"
    C) use of a candidate marked as "proto"

In the absence of any constraints, ties in the nominal typing
immediately failover to tiebreaker B or C; if not resolved by B or C,
they warn at compile time about an ambiguous dispatch.

在没有任何约束的情况下，名字类型的连接立刻转移到终端连接B或C；如果B或C没有解决，在编译时它们就会警告一个模糊调用。

If there are any tied candidates with constraints, it follows from our
definitions above that all of them are considered to be constrained.
In the presence of longname parameters with constraints, or the
implied constraint of extra required arguments, tiebreaker A is
applied.  Candidates which are tied nominally but have constraints
are considered to be a completely different situation, insofar as it
is assumed the user knows exactly why each candidate has the extra
constraints it has.  Thus, constrained signatures are considered to
be much more like a switch defined by the user.  So for tiebreaker
A the candidates are simply called in the order they were declared,
and the first one that successfully binds (and completes without
calling nextsame or nextwith) is considered the winner, and all the
other tied candidates are ignored.  If all the constrained
candidates fail, we throw out the rank of constrained variants and
proceed to the next tighter rank, which may consist of the
unconstrained variants without extra arguments.

如果有任何有约束的连接待选项，它遵从我们上面的定义，那么它们都会被认为是有限制的。在带有约束的全名参数出现时，或者附加需求参数的隐含约束，中断连接A时适用的。名义上有联系但实际有限制的待选项则被认为是一种完全不同的情况，因为它假设使用者确切知道为什么每个待选项有它具有的附加约束。因此，约束签名被认为是更像一个由使用者定义的转换。所有对于中断连接A，这些待选项都按照声明时的顺序被简单调用，且第一个成功绑定的（没有调用nextsame或nextwith就完成的）被认为是赢家，而且其他所有有联系的待选项都被忽略。如果所有的约束待选项失败，我们就会抛出约束变量的rank，进入下一个更紧的rank，它可能组成了没有附加参数的无约束变量。

For ranks that are not decided by constraint (tiebreaker A),
tiebreaker B is used: only candidates marked with the C<default>
trait are considered, and the best matching default routine is used.
If there are no default routines, or if the available defaults are
also tied, tiebreaker C is used: a final tie-breaking proto sub is
called, if there is one (see above).  Otherwise the dispatch fails.

对于那些不是由约束决定的行列（中断连接A），要用到中断连接B：只有标有C<default>特性的待选项予以考虑，也要用到最佳匹配默认程序。如果没有默认程序，或者可用的默认值也是有联系的，就要用到中断连接C：如果有，就调用最终的中断连接原型sub（看看上面）。否则调用失败。

Ordinarily all the parameters of a multi sub are considered for dispatch.
Here's a declaration for an integer range operator with two parameters
in its long name:

通常对调度来说，一个多sub的所有参数都会考虑到。对于在一个全名中有两个参数的整行操作符这里有一个声明：

    multi sub infix:<..>(Int $min, Int $max) {...}

Sometimes you want to have parameters that aren't counted as part of the
long name.  For instance, if you want to allow an optional "step" parameter
to your range operator, but not consider it for multi dispatch, then put a
double semicolon instead of a comma before it:

有时你想拥有不被当做部分全名的参数。比如，如果你想把一个可选择的“step”参数变成行列操作符，但是对多重调度没有考虑到它，那么在它前面用一个双分号取代逗号：

    multi sub infix:<..>(Int $min, Int $max;; Int $by = 1) {...}

The double semicolon, if any, determines the complete long name of
a multi.  (In the absence of that, a double semicolon is assumed
after the last declared argument, but before any return signature.)
Note that a call to the routine must still be compatible with
subsequent arguments.

双分号，如果有的话，决定了多个完整的全名。（如果没有，在最后一个声明的参数后面但任何返回签名的前面，双分号都是假定的。）注意调用程序必须任然符合随后的参数。

Note that the C<$by> is not a required parameter, so doesn't impose
the kind of constraint that allows tiebreaker A.  If the default
were omitted, it would be a required parameter, and subject to tiebreaker A.
Likewise an ordinary named parameter does not participate as a tiebreaker,
but you can mark named parameters as required to effectively make
a switch based on named binding:

注意C<$by>不是一个必需的参数，所以没有强加允许中断连接A的这种约束。如果默认被省略，它将是一个必需的参数，而且对中断连接A适用。同样，一个普通的命名参数不能作为一个中断连接使用，但是你可以将命名参数标记为必需的来有效地做一个基于已命名的绑定的转换：

    multi foo (Int $a;; :$x!) {...}     # constrained
    multi foo (Int $a;; :$y!) {...}     # constrained
    multi foo (Int $a;; :$z!) {...}     # constrained

    multi foo (Int $a;; *%_) {...}      # unconstrained

The first three are dispatched under tiebreaker A as a constrained
rank.  If none of them can match, the final one is dispatched as
an unconstrained rank, since C<*%_> is not considered a required
parameter.

前三个在中断连接A下作为一个约束行列被调度。如果它们中没有能匹配的，最后一个将作为一个无约束行列被调用，因为C<*%_>不被认为是一个必需的参数。

Likewise, constrained types sort before unconstrained:

同样，约束类型在无约束之前分类：

    multi bar (Even $a) {...}   # constrained
    multi bar (Odd $a) {...}    # constrained

    multi bar (Int $a) {...}    # unconstrained

And values used as subset types also sort first, and are dispatched
on a first-to-match basis:

还有子集类型值也要先分类，然后在最佳匹配的基础上调度：

    multi baz (0) {...}         # constrained
    multi baz (1) {...}         # constrained

    multi baz (Int $x) {...}    # unconstrained

If some of the constrained candidates come by import from other modules,
they are all considered to be declared at the point of of importation
for purposes of tiebreaking; subsequent tiebreaking is provided by
the original order in the used module.

如果某些约束待选项从其他模块得到输入值，它们都被认为是为了中断连接在输入时声明的；随后的中断连接是由在已用模块的原始顺序提供的。

[Conjecture: However, a given multi may advertise multiple long names,
some of which are shorter than the complete long name.  This is done
by putting a semicolon after each advertised long name (replacing
the comma, if present).  A semicolon has the effect of inserting two
candidates into the list.  One of them is inserted with exactly the
same types, as if the semicolon were a comma.  The other is inserted
as if all the types after the semicolon were of type Any, which puts
it later in the list than the narrower actual candidate.  This merely
determines its sort order; the candidate uses its real type signature
if the dispatcher gets to it after rejecting all earlier entries on the
candidate list.  If that set of delayed candidates also contains ties,
then additional semicolons have the same effect within that sublist
of ties.  Note, however, that semicolon is a no-op if the types after
it are all C<Any>.  (As a limiting case, putting a semicolon after
every parameter produces dispatch semantics much like Common Lisp.
And putting a semicolon after only the first argument is much like
ordinary single-dispatch methods.)  Note: This single-semicolon syntax
is merely to be considered reserved until we understand the semantics
of it, and more importantly, the pragamatics of it (that is, whether
it has any valid use case).  Until then only the double-semicolon
form will be implemented in the standard language.]

[猜想：然而，一个已有的multi可能公布多个全名，它们中的某些比完整的全名短。这是通过把一个分号放在每个已公布的全名后实现的（如果存在，就取代逗号）。分号的作用是吧两个待选项插入到列表中。其中一个是插入完全相同类型的分号，就像分号是一个逗号。另一个的插入就像分号后的所有的类型是Any类型，列表中它的位置比窄些的实际待选项更靠后。这仅是决定了它的分类排序；如果调度者在舍弃待选列表中的所有早些入口后得到它，待选项就会使用它真正的类型签名。如果定时待选项也有联系，那么在联结点的sub列表中附加的分号也有相同的作用。但是，注意如果分号后的类型全是C<Any>，那么分号就是一个非操作符。（作为一个特例，把分号放在每个参数后面会产生调度语义学，更像Common Lisp。还有把分号仅放在第一个参数后面更像普通的单一调度方法。）注意：单分号语法仅仅被看做是保留的直到我们明白它的语法，而且更重要的是，它的pragamatics（即，是否有任何有效地用例。）在此之前，只有双分号形式能够在标准语言中实施。]

Within a class, C<multi submethod> is visible to both method-dispatch
and subroutine-dispatch.  A C<multi method> never participates in the
subroutine-dispatch process.  It is dispatched just like a normal
method, then the tie-breaking rules of the previous paragraph are applied.
That is, the shortest long name of a multi method includes I<only> the
single invocant, and any additional semicolons may only indicate long names
to be used as tiebreakers.

在一个类内部，C<multi submethod>对于方法调度和子程序调度都是可见的。C<multi method>从来不参与子程序的调度过程。它就像一个普通的方法被调度，然后先前段落的中断连接规则被应用。即，一个多重方法最短的全名包括I<only>唯一的调用者，并且任何附加的分号或许仅标示了全名作为一个中断连接者被使用。

The multi-method tiebreaking happens only within a given class; all
parent classes' multis appear to the outside world to be C<only>
methods (and indeed, a foreign object may have no clue how to
advertise multiple methods anyway).  In other words, longnames from
different classes don't intermix as do the longnames in ordinary
multi-sub dispatch.  So multi methods work only within a class;
outside the class, single-dispatch semantics are enforced to preserve
encapsulation.  To put it another way, multi methods are only for
convenience of implementation within a given class; and specifically
to make it easier to compose roles with similar but not identical
methods into a single class.

多重方法中断连接只有在已有类内部发生；所有父类的multis出现在C<only>的方法外部（而实质上，一个外来对象可能不知道怎样公布多重方法）。换句话说，不同类的全名不能混合就像在普通多重子调度的全名一样。所以，多重方法只能在类内部起作用；在类外部，单一调度语义被用来维护封装。换言之，多重方法仅是为了在一个已有类内部执行方便；而且具体的说，为使其更容易些，来组成相似的角色不是把相同的方法放在一个单一类中。

Conjecture: In order to specify dispatch that includes the return
type context, it is necessary to place the return type before the double
semicolon:

猜想：为了指定包括返回类型语境的调度，有必要把返回类型放在双分号前面：

    multi infix:<..>(Int $min, Int $max --> Iterator;; Int $by = 1) {...}
    multi infix:<..>(Int $min, Int $max --> Selector;; Int $by = 1) {...}

Note that such a declaration might have to delay dispatch until the
actual desired type is known!  (Generally, you might just consider
returning a flexible C<Range> object instead of an anonymous partial
dispatch that may or may not be resolved at compile time via type
inferencing.  Therefore return-type tiebreaking need not be supported
in 6.0.0 unless some enterprising soul decides to make it work.)

注意，这样一个声明可能会推迟调度直到实际想要的类型是已知的！（通常来说，你可能仅考虑返回一个灵活的C<Range>对象来取代一个匿名不完全调度，在编译时通过类型推理，这个调度可能或不可能得到解决。因此，在6.0.0中返回类型的中断连接不必得到支持，除非一些有进取心的人觉得使它发挥作用。）

=head2 Method call vs. Subroutine call

=head2 方法调用对比子程序调用

The caller indicates whether to make a method call or subroutine
call by the call syntax.  The "dot" form and the indirect object form
default to method calls.  All other prefix calls default to subroutine calls.
This applies to prefix unary operators as well:

通过调用语法，调用者指出是否使用方法调用或子程序调用。“点”形式和间接对象形式默认的是方法调用。所有其他的前缀调用默认的是子程序调用。这也适用于前缀一元操作符：

    !$obj;  # same as $obj.prefix:<!>

A method call considers only methods (including multi-methods and submethods)
from the class hierarchy of its invocant, and fails if none is found.  The
object in question is in charge of interpreting the meaning of the method
name, so if the object is a foreign object, the name will be interpreted
by that foreign runtime.

一个方法调用只考虑来自调用者的类层次结构的方法（包括多重方法和子方法），如果没有的话调用就会失败。考虑中的对象负责解释方法名的意义。所以如果对象是一个外来对象，该名称就会又能够外来的运行时间解释。

A subroutine call considers only visible subroutines (including
submethods) of that name.  The object itself has no say in the
dispatch; the subroutine dispatcher considers only the types the
arguments involved, along with the name.  Hence foreign objects passed
to subroutines are forced to follow Perl semantics (to the extent
foreign types can be coerced into Perl types, otherwise they fail).

一个子程序调用仅考虑同名的可见子程序（包括子方法）。对象本身在调用时没有发言权；子程序调度者只考虑参数包含的类型，以及名字。因此传递给子程序的外来对象要求遵循perl的语义（一定程度上，外来类型能够转变成Perl类型，否则它们就会失败）。

There is no fail-over either from subroutine to method dispatch or
vice versa.  However, you may use C<is export> on a method
definition to make it available also as a multi sub.  As with indirect
object syntax, the first argument is still always the invocant,
but the export allows you to use a comma after the invocant instead of
a colon, or to omit the colon entirely in the case of a method with
no arguments other than the invocant.  Many standard methods (such
as C<IO::close> and C<Array::push>) are automatically exported to the
C<CORE> namespace by default.  For other exported methods, you will not
see the multi sub definition unless you C<use> the class in your scope,
which will import the multi sub lexically, after which you can call it
using normal subroutine call syntax.

从子程序到方法也没有失效转移，或者反之亦然。然而，在定义方法时你可能使用C<is export>以使它作为一个多重sub也可用。和间接对象语法一样，第一个参数仍总是调用者，但是输出值允许在调用者后使用一个逗号代替冒号，或者在无参数方法而不是调用者的情况下完全忽略冒号。许多标准方法（比如C<IO::close>和C<Array::push>）自动输出到默认的C<CORE>名字空间。对其他输出方法来说，你不能看多重sub定义，除非你在你的范围内C<use>类，这将会从词法上输入多重sub，在这之后你看一用普通的字程序调用语法调用它。

In the absence of an explicit type on the method's invocant, the
exported multi sub's first argument is implicitly constrained to
match the class in which it was defined or composed, so for instance
the multi version of C<close> requires its first argument to be of
type C<IO> or one of its subclasses.  If the invocant is explicitly
typed, that will govern the type coverage of the corresponding multi's
first argument, whether that is more specific or more general than
the class's invocant would naturally be.  (But be aware that if it's
more specific than C<::?CLASS>, the binding may reject an otherwise
valid single dispatch as well as a multi dispatch.)  In any case,
it does no good to overgeneralize the invocant if the routine itself
cannot handle the broader type.  In such a situation you must write
a wrapper to coerce to the narrower type.

没有一个明确的方法调用者类型时，输出的multi sub的第一个参数被隐含地限制要和类匹配，它在类内部定义或组成的，所以C<close>的多个版本要求它的第一个参数是C<IO>类型或其中的一个子类。如果invocant已明确了类型，它将会支配相应multi的第一个参数的类型支配范围，不管它比类的invocant自然所属更具体或者更一般。（但是注意如果它比C<::?CLASS>更具体，绑定可能会拒绝一个其他的合法单一调度和多重调度。）无论如何，如果程序本身不能处理更广泛的类型，高度概括invocant是不好的。在这种情况下你必须写一个封装来控制相对狭隘的类型。

Note that explicit use of a syntactic category as a method name
overrides the choice of dispatcher, so

注意作为方法名明确使用语法分类要优先于调度者的选择，所以

    $x.infix:<*>($y)

and

还有

    infix:<*>($x,$y)

are exactly equivalent.  That is, both calls use the subroutine/multi
dispatcher, not the method/single dispatcher.  Likewise

是完全等价的。即，两个调用使用子程序或multi调度者，而不是方法或单一调度者。同样地

    foo($bar)

can be written

能写成

    $bar.prefix:<foo>()

with the same meaning.  To get single dispatch of that method
name to a foreign function, you must say:

有相同的意义。为了得到外来函数方法名的单一调度，你必须写：

    $bar.'prefix:<foo>'()

Most foreign languages are not going to understand such a method name,
however.

然而，大多数的外国语言不能够理解这样一个方法名。

=head1 Multi dispatch

=head2 多重调用

Multi submethods work just like multi methods except they are constrained
to an exact type match on the invocant, just as ordinary submethods are.

多重子方法就像多重方法一样起作用，除了他们限制了和invocant严格匹配的类型，就像普通子方法似地。

Perl 6.0.0 is not required to support multiple dispatch on named parameters,
only on positional parameters.  Note that most builtins will map known
named parameters to positional via a C<proto> declaration.

Perl 6.0.0 不需要支持命名参数的多重调度，仅支持位置参数的多重调度。注意大多数内健指令通过C<proto>声明会将已知的命名参数映射到位置参数上。

Within a multiple dispatch, C<nextsame> means to try the next best
match, or next best default in case of tie, or the proto sub if there
is one.

在一个多重调度内，C<nextsame>意味着要调用下一个最佳匹配，或者在有联结点的情况下默认的，或者原型sub如果有的话。

Attributes are tied to a particular class definition, so a multi method
can only directly access the attributes of a class it's defined within
when the invocant is the "self" of that attribute.
However, it may call the private attribute accessors from a different
class if that other class has indicated that it trusts the class the
multi method is defined in:

属性被绑定到一个专门的类定义中，所以但调用者是那个属性的“self”时，多重方法仅能直接进入在定义在类内部的属性。
然而，如果其他类已经指出它信任定义多重方法的类，它可能从不同的类调用私有属性通道：

    class MyClass {
        trusts YourClass;
        ...
    }

The syntax for calling back to C<MyClass> is C<$obj!MyClass::meth()>.

调回C<MyClass>的语法是C<MyClass>。 

The C<sub> keyword is optional immediately after a C<proto>, C<multi>,
or C<only> keyword.

在C<proto>, C<multi>或C<only>关键字后面C<sub>是直接可选的。

A C<proto> declaration may not occur after a C<multi> declaration in the
same scope.

在同一范围内C<multi>声明后C<proto>声明可能不出现。

=head1 Delegation

=head1 托管

Delegation lets you pretend that some other object's methods are your own.
Delegation is specified by a C<handles> trait verb with an argument
specifying one or more method names that the current object and the
delegated object will have in common:

托管让你假装一些其他对象的方法是你自己的。托管是由一个带有一个或更多方法名的参数得C<handles>特性谓词指定的，一个或多个方法名是当前对象和托管对象共有的：

    has $tail handles 'wag';

Since the method name (but nothing else) is known at class construction
time, the following C<.wag> method is autogenerated for you:

由于方法名（但无其他任何东西）在类构建时是已知的，下面的C<.wag>是为你自动生成的：

    method wag (|$args) { $!tail.wag(|$args) }

You can specify multiple method names:

你可以指定多个方法名：

    has $.legs handles <walk run lope shake lift>;

It's illegal to call the outer method unless the attribute
has been initialized to an object of a type supporting the method,
such as by:

调用外部方法名是不合法的，除非属性以被初始化为一个支持方法的类型对象，比如：

    has Tail $.tail handles 'wag' .= new(|%_);

Note that putting a C<Tail> type on the attribute does not necessarily
mean that the method is always delegated to the C<Tail> class.
The dispatch is still based on the I<run-time> type of the object,
not the declared type.

注意把C<Tail>类型置于属性上不是说总是把方法委托给C<Tail>类。调用仍是基于对象的I<run-time>类型，不是已声明的类型。

Any other kind of argument to C<handles> is considered to be a
smartmatch selector for method names.  So you can say:

对方法名来说，C<handles>的任何其他种参数被认为是一个精确匹配的选择者。所有你可以写：

    has $.fur is rw handles /^get_/;

If you say

如果你写

    has $.fur is rw handles Groomable;

then you get only those methods available via the C<Groomable> role
or class.  To delegate everything, use the C<Whatever> matcher:

那么，通过C<Groomable>角色或类你仅能得到那些可用的方法。要想托管每件事，用C<Whatever>匹配器：

    has $the_real_me handles *;

Wildcard matches are evaluated only after it has been determined that
there's no exact match to the method name anywhere.  When you have
multiple wildcard delegations to different objects, it's possible
to have a conflict of method names.  Wildcard method matches are
evaluated in order, so the earliest one wins.  (Non-wildcard method
conflicts can be caught at class composition time.)

通配符的匹配只有在决定和任何地方的方法名没有确切匹配时才被估计。当你有许多通配符托管给不同对象时，有一个冲突的方法名是可能的。通配符方法匹配按序估计的，所以最早的会成功。（无通配符方法冲突在类构成时间解决。）

If, where you would ordinarily specify a string, you put a pair, then
the pair maps the method name in this class to the method name in the
other class.  If you put a hash, each key/value pair is treated as
such a mapping.  Such mappings are not considered wildcards.

在你通常指定一个字符串时，如果你指定一对，那么这对就会把在这个类中的方法名映射给其他类的方法名。如果你指定一个哈希表，每个键或值对都会被视为这样一个映射。这种映射不被认为是通配符。

    has $.fur handles { :shakefur<shake>, :scratch<get_fleas> };

You I<can> do a wildcard renaming, but not with pairs.  Instead do smartmatch
with a substitution:

你I<can>做一个通配符的重命名，但不是成对的。相反用置换做精确匹配： 

    has $.fur handles (s/^furget_/get_/);

Ordinarily delegation is based on an attribute holding an object, but it can
also be based on the return value of a method:

通常，托管是基于赋予对象的属性上，但是它也可以基于方法的返回值：

    method select_tail handles <wag hang> {...}

If your delegation object happens to be an array:

如果你的托管对象正好是一个数组：

    has @handlers handles 'foo';

then Perl 6 assumes that your array contains a list of potential
handlers, and you just want to call the I<first> one that succeeds.
This is not considered a wildcard match unless the "handles" argument
forces it to be.

那么Perl6会假设你的数字包含一个潜在的处理程序列表，还有你只想成功调用I<first>。这不被认为是一个通配符匹配，除非“处理”参数强迫它这样做。

[Conjectural: the hash syntax is reserved until we figure out the
semantics we really want, and whether this actually buys us anything
over normal polymorphism.] If your delegation object happens to be
a hash:

[推测：哈希语法是保留的直到我们弄明白我们真正想要的语义，以及这实际上buys us anything over正常多态性。]如果你的托管对象正好是一个哈希表：

    has %objects handles 'foo';

then the hash provides a mapping from a set of Selectors specified as Pair
keys to the object specified as the Pair value that should be delegated to:

那么哈希表会提供一个映射从一套指定为Pair 关键字的选择器到指定为应该托管给Pair值的对象：

    has %barkers handles "bark" =
                (Chihauhau => $yip,
                    Beagle => $yap,
                   Terrier => $arf,
                 StBernard => $woof,
                         * => $ruff,
                );

If the current object matches no Selector, a "C<nextsame>" is
automatically performed.

如果当前对象和选择器不匹配，"C<nextsame>" 就会自动执行。

=head1 Types and Subtypes

=head1 类型和子类型

The type system of Perl consists of roles, classes, and subtypes.
You can declare a subtype like this:

Perl的类型体系包括角色，类，和子类型。你可以像这样声明一个子类型：

    my subset Str_not2b of Str where /^[isnt|arent|amnot|aint]$/;

or this:

或者这样：

    my Str subset Str_not2b where /^[isnt|arent|amnot|aint]$/;

An anonymous subtype looks like this:

匿名子类型看起来像这样：

    Str where /^[isnt|arent|amnot|aint]$/;

A C<where> clause implies future smartmatching of some kind: the as-yet
unspecified object of the type on the left must match the selector on
the right.  Our example is roughly equivalent to this closure:

C<where>从句暗示了某种将来的精确匹配：到现在为止还未制定的左边的类型对象必须和右边的选择器匹配。我们的例子大体上符合这种封闭：

    { $_.does(Str) and $_ ~~ /^[isnt|arent|amnot|aint]$/; }

except that a subtype knows when to call itself.

除了子类型知道什么时候调用它本身。

A subtype is not a subclass.  Subclasses add capabilities, whereas
a subtype adds constraints (takes away capabilites).  A subtype is
primarily a handy way of sneaking smartmatching into multiple dispatch.
Just as a role allows you to specify something more general than a
class, a subtype allows you to specify something more specific than
a class.  A subtype specifies a subset of the values that the original
type specified, which is why we use the C<subset> keyword for it.

子类型不是一个子类。子类增加了功能，而子类型增加了限制（移去了功能）。子类型主要是把精确匹配挤进多重调度的一个近便方式。就像角色允许你指定比类更一般的东西一样，子类也指定了原先类型指定的值的一个子集，这就是我们为什么要使用C<subset>关键字。

While subtypes are primarily intended for restricting parameter types
for multiple dispatch, they also let you impose preconditions on
assignment.  If you declare any container with a subtype,
Perl will check the constraint against any value you might try to
bind or assign to the container.

对于多重调度虽然子类型主要是用来限制参数类型，它们也让你把前提加到任务上。如果你声明任何有子类型的容器，Perl就会检测到与你试图绑定或分配的容器的任何值相反的约束。

    subset Str_not2b of Str where /^[isnt|arent|amnot|aint]$/;
    subset EvenNum   of Num where { $^n % 2 == 0 }

    my Str_not2b $hamlet;
    $hamlet = 'isnt';   # Okay because 'isnt' ~~ /^[isnt|arent|amnot|aint]$/
    $hamlet = 'amnt';   # Bzzzzzzzt!   'amnt' !~~ /^[isnt|arent|amnot|aint]$/

    my EvenNum $n;
    $n = 2;             # Okay
    $n = -2;            # Okay
    $n = 0;             # Okay
    $n = 3;             # Bzzzzzzzt

It's legal to base one subtype on another; it just adds an additional
constraint.  That is, it's a subset of a subset.

一种子类型以另一种子类型为基础是合法的；它仅增加了一个额外的限制。即，它是子集的子集。

You can use an anonymous subtype in a signature:

你可以在签名中使用一个匿名子类型：

    sub check_even (Num where { $^n % 2 == 0 } $even) {...}

That's a bit unwieldy, but by the normal type declaration rules you
can turn it around to get the variable out front:

那有点不易操作，但是通过通常的类型声明规则你可以使它转换方向得到前面的变量：

    sub check_even ($even of Num where { $^n % 2 == 0 }) {...}

and just for convenience we also let you write it:

为了方便我们也让你写：

    sub check_even (Num $even where { $^n % 2 == 0 }) {...}

since all the type constraints in a signature parameter are just
anded together anyway.

因为在一个签名参数里所有的类型约束仅是相与在一起。

You can leave out the block when matching against a literal value of some
kind:

当你把块和某种字面值匹配时，你可以省略块：

    multi sub fib (Int $n where 0|1) { return $n }
    multi sub fib (Int $n) { return fib($n-1) + fib($n-2) }

In fact, you can leave out the 'where' declaration altogether:

实际上，你可以一起省略'where'声明：

    multi sub fib (0) { return 0 }
    multi sub fib (1) { return 1 }
    multi sub fib (Int $n) { return fib($n-1) + fib($n-2) }

Subtype constraints are used as tiebreakers in multiple dispatch:

子类型约束在多重调度中用于中断连接：

    use Rules::Common :profanity;

    multi sub mesg ($mesg of Str where /<profanity>/ is copy) {
        $mesg ~~ s:g/<profanity>/[expletive deleted]/;
        print $MESG_LOG: $mesg;
    }

    multi sub mesg ($mesg of Str) {
        print $MESG_LOG: $mesg;
    }

For multi dispatch, a long name with a matching constraint is preferred over
an equivalent one with no constraint.  So the first C<mesg> above is
preferred if the constraint matches, and otherwise the second is
preferred.

对于多重调度，有匹配限制的全名优于无限制的相等值。所以如果约束匹配的话，上面的第一个C<mesg>是首选，否则第二个是首选。

To export a subset type, put the export trait just before the C<where>:

为了输出一个子集类型，把输出特性放在C<where>前面：

    subset Positive of Int is export where * > 0;

=head2 Abstract vs Concrete types [Conjectural]

=head2 抽象类型和具体类型对比[猜想的]

For any named type, certain other types may automatically be derived
from it by appending an appropriate adverbial to its name:

对任何命名类型，通过附加在它的名字上一个合适的状语，特定的其他类型可能自动派生于它：

    Int:A       Allow either defined or undefined Int values
    Int:U       Allow only undefined (abstract) Int values
    Int:D       Allow only defined (concrete) Int values

That is, these are equivalent:

即，这些是等价的：

    Int:A       Any where Int
    Int:U       Int where !*.defined
    Int:D       Int where *.defined

A bare C<Int> may default differently in different circumstances.
In a variable declaration, C<:A> is assumed, whereas in a formal
parameter that is not an invocant, C<:D> is assumed.

裸C<Int>在不同的情况下，默认的也不同。在变量声明中，C<:A>是假设的，然而在一个正式参数中它不是一个调用者，C<:D>是假设的。

=head2 Multiple constraints

=head2 多种约束

[Conjecture: This entire section is considered a guess at our
post-6.0.0 direction.  For 6.0.0 we will allow only a single constraint
before the variable, and post constraints will all be considered
"epsilon" narrower than the single type on the left.  The single
constraint on the left may, however, be a value like 0 or a named
subset type.  Such a named subset type may be predeclared with an
arbitrarily complex C<where> clause; for 6.0.0 any structure type
information inferrable from the C<where> clause will be ignored,
and the declared subset type will simply be considered nominally
derived from the C<of> type mentioned in the same declaration.]

More generally, a parameter can have a set of constraints, and
the set of constraints defines the formal type of the parameter,
as visible to the signature.  (No one constraint is priviledged as
the storage type of the actual argument, unless it is a native type.)
All constraints considered in type narrowness.
That is, these are equivalently narrow:

    Foo Bar @x
    Bar Foo @x

The constraint implied by the sigil also counts as part of the official type.
The sigil is actually a constraint on the container, so the actual
type of the parameter above is something like:

    Positional[subset :: of Any where Foo & Bar }]

Static C<where> clauses also count as part of the official type.
A C<where> clause is considered static if it can be applied to
the types to the left of it at compile time to produce a known finite set
of values.  For instance, a subset of an enum type is a static set
of values.  Hence

    Day $d where 'Mon'..'Fri'

is considered equivalent to

    subset Weekday of Day where 'Mon'..'Fri';
    Weekday $d

Types mentioned in a dynamic C<where> class are not considered part of the official
type, except insofar as the type includes the notion: "is also constrained
by a dynamic C<where> clause", which narrows it by epsilon over the equivalent
type without a C<where> clause.

    Foo Bar @x              # type is Foo & Bar & Positional
    Foo Bar @x where Baz    # slightly tighter than Foo Bar Positional

The set of constraints for a parameter creates a subset type that implies
some set of allowed values for the parameter.  The set of allowed values
may or may not be determinable at compile time.  When the set of allowed
values is determinable at compile time, we call it a static subtype.

Type constraints that resolve to a static subtype (that is, with a
fixed set of elements knowable (if not known) at compile time) are
considered to be narrower than type constraints that involve run-time
calculation, or are otherwise intractable at compile time.
Note that all values such as 0 or "foo" are considered
singleton static subtypes.  Singleton values are considered narrower
than a subtype with multiple values, even if the subtype contains
the value in question.  This is because, for enumerable types, type
narrowness is defined by doing set theory on the set of enumerated values.

So assuming:

    my enum Day ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    subset Weekday of Day where 'Mon' .. 'Fri'; # considered static
    subset Today of Day where *.today;

we have the following pecking order:

    Parameter                   # Set of possible values
    =========                   ========================
    Int $n                      # Int

    Int $n where Today          # Int plus dynamic where
    Int $n where 1 <= * <= 5    # Int plus dynamic where

    Day $n                      # 0..6

    Day $n where Today          # 0..6 plus dynamic where

    Day $n where 1 <= * <= 5    # 1..5
    Int $n where Weekday        # 1..5
    Day $n where Weekday        # 1..5
    Weekday $n                  # 1..5

    Tue                         # 2

Note the difference between:

    Int $n where 1 <= * <= 5    # Int plus dynamic where
    Day $n where 1 <= * <= 5    # 1..5

The first C<where> is considered dynamic not because of the nature
of the comparisons but because C<Int> is not finitely enumerable.
Our C<Weekday> subset type can calculate the set membership at compile
time because it is based on the C<Day> enum, and hence is considered
static despite the use of a C<where>.  Had we based C<Weekday> on
C<Int> it would have been considered dynamic.  Note, however, that
with "anded" constraints, any enum type governs looser types, so

    Int Day $n where 1 <= * <= 5

is considered static, since C<Day> is an enum, and cuts down the
search space.

The basic principle we're trying to get at is this: in comparing
two parameter types, the narrowness is determined by the subset
relationships on the sets of possible values, not on the names of
constraints, or the method by which those constraints are specified.
For practical reasons, we limit our subset knowledge to what can be
easily known at compile time, and consider the presence of one or
more dynamic constraints to be epsilon narrower than the same set of
possible values without a dynamic constraint.

As a first approximation for 6.0.0, subsets of enums are static,
and other subsets are dynamic.  We may refine this in subsequent
versions of Perl.

=head1 Enums

An enum is a low-level class that can function as a role or property.
A given enum value can function as a subtype, a method, or as an ordinary
value.  The names of the values are specified as a parenthesized list, or
an equivalent angle bracket list:

    my enum Day ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
    my enum Day <Sun Mon Tue Wed Thu Fri Sat>;

If the first value is unspecified, it defaults to 0.  To specify the
first value, use pair notation (see below).

If the declared type name begins with an uppercase letter, the default
type is C<Int> or C<Str>, depending on the type of the first value.
If the declared type is lowercase, the default return type is C<int> or C<buf>.

The type can be specified:

    my bit enum maybe <no yes>;
    my Int enum day ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
    my enum day of uint4 <Sun Mon Tue Wed Thu Fri Sat>;

For any enum value of an object type, the object itself knows its own
type, so the C<.perl> method will return its long name, while C<.name>
returns its short name.  Other than that, number valued enums act
just like numbers, while string valued enums act just like strings.

Enums based on native types may be used only for their value, since a
native value doesn't know its own type.  To translate such a value back to its name
requires a call to the name method, which must be qualified by the type:

    3.day::name   # returns "Wed"

Alternatively, native types may be placed in a typed variable, which determines
which method to call:

    my day $d = 3;
    $d.name     # returns "Wed"

An anonymous enum just makes sure each string turns into a pair with
sequentially increasing values, so:

    %e = enum < ook! ook. ook? >;

is equivalent to:

    %e = ();
    %e<ook!> = 0;
    %e<ook.> = 1;
    %e<ook?> = 2;

The enum installer inspects list values for pairs, where the value
of the pair sets the next value explicitly.  Non-pairs C<++> the
previous value.  (Str and buf types increment like Perl 5 strings.)
Since the C<«...»> quoter automatically recognizes
pair syntax along with interpolations, we can simply say:

    my enum DayOfWeek «:Sun(1) Mon Tue Wed Thu Fri Sat»;

    our Str enum Phonetic «:Alpha<A> Bravo Charlie Delta
                            Echo Foxtrot Golf Hotel India Juliet
                            Kilo Lima Mike November Oscar Papa
                            Quebec Romeo Sierra Tango Uniform
                            Victor Whiskey X-ray Yankee Zulu»;

    enum roman (i => 1,   v => 5,
                x => 10,  l => 50,
                c => 100, d => 500,
                m => 1000);

    my Item enum hex «:zero(0) one two three four five six seven eight nine
                      :ten<a> eleven twelve thirteen fourteen fifteen»;

You may import enum types; only non-colliding values are imported.
Colliding enum values are hidden and must be disambiguated with the
type name.  Any attempt to use the ambiguous name will result in a fatal
compilation error.  (All colliding values are hidden, not just the new one,
or the old one.)  Any explicit sub or type definition hides all imported
enum values of the same name but will produce a warning unless
C<is redefined> is included.  Note that true() is a built-in function,
while True is short for C<Bool::True>.

Enum values may be used as a property on the right side
of a C<but>, and the enum type will be intuited from the value to make
sure the object in question has the right semantics mixed in:

    $x = "Today" but Tue;

is the same as

    $x = "Today" but day::Tue;

or pseudo-hash form:

    $x = "Today" but day<Tue>;

which is short for something like:

    $x = "Today";
    $x does day;
    $x.day = &day::('Tue');

There's also a pseudo-functional form:

    $x = "Today" but day(Tue);

which lets you cheat:

    $x = "Today" but day(3);

After any of those

    $x.day

returns C<day::Tue> (that is, 3), and

    $x ~~ day
    $x ~~ Tue
    $x.does(Tue)
    $x.does(day)
    $x.day == Tue
    day($x) == Tue
    $x.Tue

all return true, and

    $x.does(Wed)
    $x.Wed
    $x.day == Wed
    8.does(day)
    8 ~~ day

all return false.

Two built-in enums are:

    our Bit enum Bool <False True>;
    our Bit enum Taint <Untainted Tainted>;

Note that C<Bool> and C<Taint> are really role names, and the enum
values are really subset types of the C<Bit> integer type.  You can
call the C<.Bool> coercion or the C<true> function or the C<?>
prefix operator on any built-in type, but the value returned is of
type C<bit>.  Never compare a value to "C<true>", or even "C<True>".
Just use it in a boolean context.

Like type names, enum names are parsed as standalone tokens
representing scalar values, and don't look for any arguments.
Unlike type names which are undefined type objects, enums are defined
constant values.  Also unlike types, they do not respond to C<.()>
unless you mix in C<Callable> somehow.
They may not be post-declared.

    our enum Maybe <OK FAIL>;
    sub OK {...}
    $x = OK;   # certainly the enum value
    $x = OK()  # certainly the function

Since there is an enum C<OK>, the function C<OK> may only be
called using parentheses, never in list operator form.  (If there is
a collision on two enum values that cancels them both, the function
still may only be called with parentheses, since the enum symbol
is "poisoned".)

Enum types (and perhaps certain other finite, enumerable types such
as finite ranges) define a C<.pick> method on the type object of
that type.  Hence:

    my enum CoinFace <Heads Tails>;
    CoinFace.pick

returns C<Heads> or C<Tails> with equal probability, and

    Month.pick(*)

will return the months in random order.  Presumably

    StandardPlayingCards.pick(5)

might return a Royal Flush, but a Full House is much
more likely.  It can never return Five Aces, since the pick
is done without replacement.  (If it I<does> return Five Aces,
it's time to walk away.  Or maybe run.)

To export an enum, place the export trait just before the list:

    enum Maybe is export <No Yes Dunno>;

=head1 Open vs Closed Classes

By default, all classes in Perl are non-final, which means
you can potentially derive from them.  They are also open, which means
you can add more methods to them, though you have to be explicit that
that is what you're doing:

    augment class Object {
        method wow () { say "Wow, I'm an object." }
    }

Otherwise you'll get a class redefinition error.  (Also, to completely
replace a definition, use "C<supersede>" instead of "C<augment>"...but
don't do that, since the compiler may have already committed to
optimizations based on the old definition.)

In order to discourage casual misuse of these declarators, they are not
allowed on global classes unless you put a special declaration at the top:

    use MONKEY_TYPING;

For optimization purposes, Perl 6 gives the top-level application the
right to close and finalize classes by the use of C<oo>, a pragma for
selecting global semantics of the underlying object-oriented engine:

    use oo :closed :final;

This merely changes the application's default to closed and final,
which means that at the end of the main compilation (C<CHECK> time)
the optimizer is allowed to look for candidate classes to close or
finalize.  But anyone (including the main application) can request
that any class stay open or nonfinal, and the class closer/finalizer
must honor that.

    use class :open<Mammal Insect> :nonfinal<Str>

These properties may also be specified on the class definition:

    class Mammal is open {...}
    class Insect is open {...}
    class Str is nonfinal {...}

or by lexically scoped pragma around the class definition:

    {
        use class :open;
        class Mammal {...}
        class Insect {...}
    }
    {
        use class :nonfinal;
        class Str {...}
    }

There is I<no> syntax for declaring individual classes closed or final.
The application may only request that the optimizer close and finalize
unmarked classes.

=head1 Interface Consistency

By default, all methods and submethods that do not declare an explicit
C<*%> parameter will get an implicit C<*%_> parameter declared for
them whether they like it or not.  In other words, all methods allow
unexpected named arguments, so that C<nextsame> semantics work
consistently.

If you mark a class "C<is hidden>", it hides the current class
from "C<nextsame>" semantics, and incidentally suppresses the
autogeneration of C<*%_> parameters.  Hidden classes may be visited
as C<SUPER::>, but not via "C<next>".

A similar effect can be achieved from the derived class by saying
C<hides Base> instead of C<is Base>.

=head1 Introspection

Metamethods for objects are named with interrogative pronouns in uppercase:

    WHAT        the type object of the type, stringifies to short name ~ '()'
    WHICH       the object's identity value
    WHO         the package supporting the object, stringifies to long name
    WHERE       the memory address of the object
    HOW         the metaclass object: "Higher Order Workings"
    WHEN        (reserved for events?)
    WHY         (reserved for documentation?)
    WHENCE      autovivification closure

These may be used either as methods or as unary operators:

    $obj.WHAT   # method form of P5's ref
    WHAT $obj   # unary form of P5's ref

These are all actually macros, not true operators or methods.  If you get
a foreign object from another language and need to call its C<.WHERE> method,
you can say:

    $obj."WHERE"

And if you don't know the method name in advance, you'd be using the
variable form anyway:

    $obj.$somemeth

which also bypasses the macros.

For now Perl 6 reserves the right to change how all these macros
and the corresponding C<^> forms are defined in terms of each other.
In particular, the C<.^> forms will automatically supply the invocant
as the first argument to methods of the metaclass, while the other
forms require you to pass this explicitly.

Note that C<WHAT> appends C<()> to indicate emptiness.  Use C<.perl> to get the
bare name from a type object.

In general, use of these in ordinary code should be a red flag that
Something Very Strange is going on.  (Hence the allcaps.)  Most code
should use Perl 6's operators that make use of this information
implicitly.  For instance, instead of

    $obj.WHAT eq 'Dog()'
    $x.WHICH === $y.WHICH
    $obj.WHAT.bless(%args)

you usually just want:

    $obj ~~ Dog
    $x === $y
    $obj.bless(%args)

Every class has a C<HOW> function/method that lets you get at the
class's metaobject, which lets you get at all the metadata properties
for the class (or other metaobject protocol) implementing the objects
of the class:

    MyClass.methods()           # call MyClass's .methods method (error?)
    MyClass.HOW.methods($obj)       # get the method list of MyClass

The C<^> metasyntax is equivalent to C<.HOW>:

    MyClass.HOW.methods($obj)   # get the method list of MyClass
    ^MyClass.methods($obj)      # get the method list of MyClass
    MyClass.^methods()          # get the method list of MyClass

Each object of the class also has a C<.HOW> or C<.^> method:

    $obj.HOW.methods($obj);
    $obj.^methods();

(If you are using prototype-based OO rather than class-based, you must use
the object form, since every such object functions as its own class.)

Class traits may include:

    identifier  { :name<Dog> :auth<http://www.some.com/~jrandom> :ver<1.2.1> }
        name      Dog
        authority http://www.some.com/~jrandom
        version   v1.2.1
    author        Joe Random
    description   This class implements camera obscura.
    subject       optics, boxes
    language      ja_JP
    licensed      Artistic|GPL
    parents       list of parent classes
    roles         list of roles
    disambig      how to deal with ambiguous method names from roles
    layout        P6opaque, P6hash, P5hash, P5array, PyDict, Cstruct, etc.

These are for the standard Perl 6 Meta-Object Protocol, but other MOPs
may define other traits.  The identifier should probably be accessed
through the C<.WHO> object in any case, which may have its own object
methods depending on how type namespaces evolve over time.  Which of
these items are actually part of the C<.HOW> object and which are
delegated back to the package and prototype objects is up to the MOP.
(Note also that anonymous classes may have anonymous packages and
prototype objects, in which case stringification is not likely to
produce something of interest to non-gurus.)

The C<.^parents> method by default returns a flattened list of all
parents sorted in MRO (dispatch) order. Other options are:

    :local              just returns the immediate parents
    :tree               the inheritance hierarchy as nested arrays

The C<.^methods> method returns method-descriptors containing:

    name                the name of the method
    signature           the parameters of the method
    as                  the coercion type of the method
    multi               whether duplicate names are allowed
    do                  the method body

The C<.^methods> method has a selector parameter that lets you
specify whether you want to see a flattened or hierarchical view,
whether you're interested in private methods, and so forth.

    :local              only methods defined in the current class
    :tree               methods by class structure (inheritance hierarchy)
    :private            include private methods

Note that, since introspection is primarily for use by the outside
world (the class already knows its own structure, after all), a set of
multi methods are presented to be a single C<Routine> object.  You need to
use C<.candidates> on that to break it down further.

The C<.^attributes> method returns a list of attribute descriptors
that have traits like these:

    name
    type
    scope
    rw
    private
    accessor
    build
    readonly

It also takes the parameters:

    :local              only methods defined in the current class
    :tree               attributes by class structure (inheritance hierarchy)

Strictly speaking, metamethods like C<.isa()>, C<.does()>, and C<.can()>
should be called through the meta object:

    $obj.HOW.can($obj, "bark")
    $obj.HOW.does($obj, Dog)
    $obj.HOW.isa($obj, Mammal)

or

    $obj.^can("bark")
    $obj.^does(Dog)
    $obj.^isa(Mammal)

But C<Any> gives you shortcuts to those:

    $obj.can("bark")
    $obj.does(Dog)
    $obj.isa(Mammal)

These, may, of course, be overridden in a subclass, so don't use the
short form unless you wish to allow for overrides.  In general, C<Any>
will delegate only those metamethods that read well when reasoning
about an individual object.  Infrastructural methods like C<.^methods>
and C<.^attributes> are not delegated, so C<$obj.methods> fails.

The smartmatch:

    $obj ~~ Dog

actually calls:

    $obj.HOW.does($obj, Dog)

which is true if C<$obj> either "does" or "isa" C<Dog> (or "isa"
something that "does" C<Dog>).  If C<Dog> is a subset, any additional
C<where> constraints must also evaluate true.

Unlike in Perl 5 where C<.can> returns a single C<Code> object,
Perl 6's version of C<.^can> returns a "WALK" iterator for a
set of routines that match the name, including all autoloaded and
wildcarded possibilities.  In particular, C<.^can> interrogates
any class package's C<CANDO> method for names that are to be considered autoloadable methods
in the class, even if they haven't been declared yet.  Role composition
sometimes relies on this ability to determine whether a superclass supplies
a method of a particular name if it's required and hasn't been supplied
by the class or one of its roles.

=head1 Autovivifying objects

The C<WHENCE> property of an object is its autovivifying closure.
Any undefined prototype object may carry such a closure that can
lazily create an object of the appropriate type.  When the closure
is eventually evaluated it is expected to return an argument list
corresponding to the arguments to a C<.bless> call.  For instance,
a C<CANDO> routine, instead of creating a C<Dog> object directly,
could instead return something like:

    Dog but WHENCE({ :name<Fido> })

which runs the closure if the object ever needs to be autovivified.
The closure can capture whatever initializers were available in the
original lexical scope.

The short form of the above is simply:

    Dog{ :name<Fido> }

This form is also lazily evaluated:

    my $dog = Dog{ :name<Fido> };
    defined $dog or say "doesn't exist";  # Fido doesn't exist
    $dog.wag()                            # Fido wags his tail

When the typename happens to be a role, autovivifying it involves
attempting to create a punned class of the same name as the role.
Whether this succeeds or not depends on whether the role is
sufficiently complete to serve as a class on its own.  Regardless of
whether such an attempt would succeed, it is always perfectly fine to
define a lazy type object for a role just as long as it's only ever
used as an argument to C<bless>, since C<bless> will only be using
its closure to construct the role's C<BUILD> arguments in the context
of the complete new class.  (Of course, an inconsistent or incomplete
class composition may subsequently fail, and in fact the incomplete
role autovivification mentioned above is likely to be implemented by
failing at the point of class composition.)

Note that when used as an argument to a method like C<bless>,
the type object is sufficiently lazy that autovivifying is done
only by the appropriate C<BUILD> routine.  It does not waste energy
creating a C<Dog> object when that object's attributes would later
have to be copied into the actual object.  (On top of which, such
an implementation would make it impossible to use type objects to
initialize incomplete roles.)

The object autovivification syntax works only for literal named types,
so any indirection must be written more explicitly:

    ::($dogproto){ :name<Fido> }
    $dogproto but WHENCE({ :name<Fido> })
    $dogproto.WHAT{ :name<Fido> }

Note that in contrast to this syntax, a lookup of a symbol in the C<Dog>
package requires a final C<::> before the subscript:

    Dog::{$varname}

=for vim:set expandtab sw=4:
