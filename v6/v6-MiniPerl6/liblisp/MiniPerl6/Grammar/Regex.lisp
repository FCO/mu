;; Do not edit this file - Generated by MiniPerl6
;; class MiniPerl6::Grammar::Regex
(defpackage mp-MiniPerl6-Grammar-Regex
  (:use common-lisp mp-Main))
;; (in-package mp-MiniPerl6-Grammar-Regex)
(let ((sv-rule_terms (sv-undef)))
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar-Regex)))
  (defclass mp-MiniPerl6-Grammar-Regex () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar-Regex))
  (defun proto-mp-MiniPerl6-Grammar-Regex () x))
;; method ws
(if (not (ignore-errors (find-method 'sv-ws () ())))
  (defgeneric sv-ws (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-ws ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))))))(return-from mp6-function sv-MATCH))))

;; method rule_ident
(if (not (ignore-errors (find-method 'sv-rule_ident () ())))
  (defgeneric sv-rule_ident (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-rule_ident ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digit sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "digit" (sv-hash sv-MATCH)) sv-m2)1) (progn nil)))))))(return-from mp6-function sv-MATCH))))

;; method any
(if (not (ignore-errors (find-method 'sv-any () ())))
  (defgeneric sv-any (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-any ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))))(return-from mp6-function sv-MATCH))))

;; method literal
(if (not (ignore-errors (find-method 'sv-literal () ())))
  (defgeneric sv-literal (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-literal ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-literal sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "literal" (sv-hash sv-MATCH)) sv-m2)1) (progn nil)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (sv-and (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-literal sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "literal" (sv-hash sv-MATCH)) sv-m2)1) (progn nil)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))(return-from mp6-function sv-MATCH))))

;; method metasyntax_exp
(if (not (ignore-errors (find-method 'sv-metasyntax_exp () ())))
  (defgeneric sv-metasyntax_exp (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-metasyntax_exp ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-literal sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-string_code sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-metasyntax_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)))))))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-metasyntax_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "metasyntax_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))))(return-from mp6-function sv-MATCH))))

;; method char_range
(if (not (ignore-errors (find-method 'sv-char_range () ())))
  (defgeneric sv-char_range (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-char_range ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-char_range sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "char_range" (sv-hash sv-MATCH)) sv-m2)1) (progn nil)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))))(return-from mp6-function sv-MATCH))))

;; method char_class
(if (not (ignore-errors (find-method 'sv-char_class () ())))
  (defgeneric sv-char_class (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-char_class ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "[" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-char_range sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)))))))(return-from mp6-function sv-MATCH))))

;; method string_code
(if (not (ignore-errors (find-method 'sv-string_code () ())))
  (defgeneric sv-string_code (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-string_code ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-literal sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-string_code sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (if (sv-bool (not (sv-eq "" (sv-substr sv-str (sv-to sv-MATCH ) 1)))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))))))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-string_code sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "string_code" (sv-hash sv-MATCH)) sv-m2)1) (progn nil)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))))(return-from mp6-function sv-MATCH))))

;; method parsed_code
(if (not (ignore-errors (find-method 'sv-parsed_code () ())))
  (defgeneric sv-parsed_code (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-parsed_code ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-string_code sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-string sv-MATCH)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))(return-from mp6-function sv-MATCH))))

;; method named_capture_body
(if (not (ignore-errors (find-method 'sv-named_capture_body () ())))
  (defgeneric sv-named_capture_body (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-named_capture_body ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((h (make-hash-table :test 'equal))) (setf (gethash "capturing_group" h) (sv-scalar (gethash "rule" (sv-hash sv-MATCH)))) h)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "[" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "rule" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-metasyntax_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "metasyntax_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Subrule))) (setf (sv-metasyntax m) (sv-scalar (gethash "metasyntax_exp" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (progn (write-line (format nil "~{~a~}" (list "invalid alias syntax")) *error-output*) (sb-ext:quit)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))))(return-from mp6-function sv-MATCH))))

;; method variables
(if (not (ignore-errors (find-method 'sv-variables () ())))
  (defgeneric sv-variables (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-variables ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "$<" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule_ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (concatenate 'string (sv-string "$/{") (sv-string (concatenate 'string (sv-string "'") (sv-string (concatenate 'string (sv-string (gethash "rule_ident" (sv-hash sv-MATCH))) (sv-string (concatenate 'string (sv-string "'") (sv-string "}"))))))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_sigil (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "MiniPerl6::Grammar.var_sigil" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-digits (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "MiniPerl6::Grammar.digits" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (concatenate 'string (sv-string (gethash "MiniPerl6::Grammar.var_sigil" (sv-hash sv-MATCH))) (sv-string (concatenate 'string (sv-string "/[") (sv-string (concatenate 'string (sv-string (gethash "MiniPerl6::Grammar.digits" (sv-hash sv-MATCH))) (sv-string "]"))))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_sigil (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "MiniPerl6::Grammar.var_sigil" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-var_twigil (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "MiniPerl6::Grammar.var_twigil" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-full_ident (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "MiniPerl6::Grammar.full_ident" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Var))) (setf (sv-sigil m) (sv-string (gethash "MiniPerl6::Grammar.var_sigil" (sv-hash sv-MATCH))))(setf (sv-twigil m) (sv-string (gethash "MiniPerl6::Grammar.var_twigil" (sv-hash sv-MATCH))))(setf (sv-name m) (sv-string (gethash "MiniPerl6::Grammar.full_ident" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))))))(return-from mp6-function sv-MATCH))))

;; method rule_terms
(if (not (ignore-errors (find-method 'sv-rule_terms () ())))
  (defgeneric sv-rule_terms (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-rule_terms ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "(" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Capture))) (setf (sv-rule_exp m) (sv-scalar (gethash "rule" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<(" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ")>" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-CaptureResult))) (setf (sv-rule_exp m) (sv-scalar (gethash "rule" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<after" (sv-substr sv-str (sv-to sv-MATCH ) 6))) (+ 1 (setf (sv-to sv-MATCH ) (+ 6 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-After))) (setf (sv-rule_exp m) (sv-scalar (gethash "rule" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<before" (sv-substr sv-str (sv-to sv-MATCH ) 7))) (+ 1 (setf (sv-to sv-MATCH ) (+ 7 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Before))) (setf (sv-rule_exp m) (sv-scalar (gethash "rule" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<!before" (sv-substr sv-str (sv-to sv-MATCH ) 8))) (+ 1 (setf (sv-to sv-MATCH ) (+ 8 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-NotBefore))) (setf (sv-rule_exp m) (sv-scalar (gethash "rule" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<!" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-metasyntax_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "metasyntax_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((h (make-hash-table :test 'equal))) (setf (gethash "negate" h) (let ((h (make-hash-table :test 'equal))) (setf (gethash "metasyntax" h) (sv-scalar (gethash "metasyntax_exp" (sv-hash sv-MATCH)))) h)) h)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<+" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-char_class sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "char_class" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-CharClass))) (setf (sv-chars m) (sv-string (gethash "char_class" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<-" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-char_class sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "char_class" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-NegateCharClass))) (setf (sv-chars m) (sv-string (gethash "char_class" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-literal sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "literal" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Constant))) (setf (sv-constant m) (sv-scalar (gethash "literal" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-literal sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "literal" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "'" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Constant))) (setf (sv-constant m) (sv-scalar (gethash "literal" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "<" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-variables sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "variables" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-InterpolateVar))) (setf (sv-var m) (sv-scalar (gethash "variables" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "?" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-metasyntax_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "metasyntax_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) (sv-scalar (gethash "metasyntax_exp" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-metasyntax_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "metasyntax_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) (sv-scalar (gethash "metasyntax_exp" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-metasyntax_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "metasyntax_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Subrule))) (setf (sv-metasyntax m) (sv-scalar (gethash "metasyntax_exp" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-parsed_code sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "parsed_code" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Block))) (setf (sv-closure m) (sv-scalar (gethash "parsed_code" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "\\" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-any sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "any" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-SpecialChar))) (setf (sv-char m) (sv-scalar (gethash "any" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "." (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (make-instance 'mp-Rul-Dot)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq "[" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "rule" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))))))))))))))))))(return-from mp6-function sv-MATCH))))

;; method rule_term
(if (not (ignore-errors (find-method 'sv-rule_term () ())))
  (defgeneric sv-rule_term (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-rule_term ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-variables sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "variables" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq ":=" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-named_capture_body sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "named_capture_body" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-NamedCapture))) (setf (sv-rule_exp m) (sv-scalar (gethash "named_capture_body" (sv-hash sv-MATCH))))(setf (sv-capture_ident m) (sv-scalar (gethash "variables" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "variables" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule_terms sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule_terms" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "rule_terms" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-tmp (sv-undef))) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "]" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq ")" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq ">" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "?" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "*" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "|" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "&" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "/" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))))))))))))))(setf (sv-bool sv-tmp ) (not (sv-bool sv-MATCH)))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH)) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-any sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "any" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Constant))) (setf (sv-constant m) (sv-scalar (gethash "any" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))))))(return-from mp6-function sv-MATCH))))

;; method quant_exp
(if (not (ignore-errors (find-method 'sv-quant_exp () ())))
  (defgeneric sv-quant_exp (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-quant_exp ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "**" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (if (sv-bool (sv-eq "{" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-parsed_code sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "parsed_code" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (if (sv-bool (sv-eq "}" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((h (make-hash-table :test 'equal))) (setf (gethash "closure" h) (sv-scalar (gethash "parsed_code" (sv-hash sv-MATCH)))) h)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "?" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "*" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)))))))))(return-from mp6-function sv-MATCH))))

;; method greedy_exp
(if (not (ignore-errors (find-method 'sv-greedy_exp () ())))
  (defgeneric sv-greedy_exp (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-greedy_exp ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "?" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (sv-or (progn (setf (sv-to sv-MATCH ) sv-pos1)(if (sv-bool (sv-eq "+" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil)) (progn (setf (sv-to sv-MATCH ) sv-pos1)1)))))(return-from mp6-function sv-MATCH))))

;; method quantifier
(if (not (ignore-errors (find-method 'sv-quantifier () ())))
  (defgeneric sv-quantifier (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-quantifier ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-rule_term sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "rule_term" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws2 (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-quant_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "quant_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-greedy_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "greedy_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-opt_ws3 (proto-mp-MiniPerl6-Grammar) sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Quantifier))) (setf (sv-term m) (sv-scalar (gethash "rule_term" (sv-hash sv-MATCH))))(setf (sv-quant m) (sv-scalar (gethash "quant_exp" (sv-hash sv-MATCH))))(setf (sv-greedy m) (sv-scalar (gethash "greedy_exp" (sv-hash sv-MATCH))))(setf (sv-ws1 m) (sv-scalar (gethash "MiniPerl6::Grammar.opt_ws" (sv-hash sv-MATCH))))(setf (sv-ws2 m) (sv-scalar (gethash "MiniPerl6::Grammar.opt_ws2" (sv-hash sv-MATCH))))(setf (sv-ws3 m) (sv-scalar (gethash "MiniPerl6::Grammar.opt_ws3" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "rule_term" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))))))))(return-from mp6-function sv-MATCH))))

;; method concat_list
(if (not (ignore-errors (find-method 'sv-concat_list () ())))
  (defgeneric sv-concat_list (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-concat_list ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-quantifier sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "quantifier" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-concat_list sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "concat_list" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (concatenate 'list  (list (sv-scalar (gethash "quantifier" (sv-hash sv-MATCH)))) (sv-scalar (gethash "concat_list" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (concatenate 'list  (list (sv-scalar (gethash "quantifier" (sv-hash sv-MATCH)))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function nil))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))(return-from mp6-function sv-MATCH))))

;; method concat_exp
(if (not (ignore-errors (find-method 'sv-concat_exp () ())))
  (defgeneric sv-concat_exp (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-concat_exp ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-concat_list sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "concat_list" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Concat))) (setf (sv-concat m) (sv-scalar (gethash "concat_list" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))(return-from mp6-function sv-MATCH))))

;; method or_list_exp
(if (not (ignore-errors (find-method 'sv-or_list_exp () ())))
  (defgeneric sv-or_list_exp (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-or_list_exp ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-concat_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "concat_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "|" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-or_list_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "or_list_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (concatenate 'list  (list (sv-scalar (gethash "concat_exp" (sv-hash sv-MATCH)))) (sv-scalar (gethash "or_list_exp" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (concatenate 'list  (list (sv-scalar (gethash "concat_exp" (sv-hash sv-MATCH)))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function nil))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1)))))(return-from mp6-function sv-MATCH))))

;; method rule
(if (not (ignore-errors (find-method 'sv-rule () ())))
  (defgeneric sv-rule (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-rule ((sv-grammar mp-MiniPerl6-Grammar-Regex) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH (sv-undef))) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(progn (sv-and (let ((sv-pos1 (sv-undef))) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn nil))) (if (sv-bool (sv-eq "|" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) nil))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (sv-and (let ((sv-m2 (sv-undef))) (setf sv-m2 (sv-or_list_exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "or_list_exp" (sv-hash sv-MATCH)) sv-m2)1) (progn nil))) (let ((sv-ret (sv-undef))) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Rul-Or))) (setf (sv-or_list m) (sv-scalar (gethash "or_list_exp" (sv-hash sv-MATCH)))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) nil)1))))))(return-from mp6-function sv-MATCH))))

(defmethod sv-perl ((self mp-MiniPerl6-Grammar-Regex))
  (mp-Main::sv-lisp_dump_object "::MiniPerl6::Grammar::Regex" (list )))

)


