;; Do not edit this file - Generated by MiniPerl6
;; class MiniPerl6::Grammar
(defpackage mp-MiniPerl6-Grammar
  (:use common-lisp))
;; (in-package mp-MiniPerl6-Grammar)
(if (not (ignore-errors (find-class 'mp-MiniPerl6-Grammar)))
  (defclass mp-MiniPerl6-Grammar () ()))

(let (x) 
  (setq x (make-instance 'mp-MiniPerl6-Grammar))
  (defun proto-mp-MiniPerl6-Grammar () x))
;; method key
(if (not (ignore-errors (find-method 'sv-key () ())))
  (defgeneric sv-key (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-key ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-tmp nil)) (setf sv-tmp sv-MATCH)(setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) (sv-to sv-tmp ))(setf (sv-to m) (sv-to sv-tmp ))(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (if (sv-bool (sv-eq "=>" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0)) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-m2 nil)) (setf sv-m2 (sv-ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0)))))))(setf (sv-bool sv-tmp ) (sv-bool sv-MATCH ))(setf sv-MATCH sv-tmp)(sv-bool sv-MATCH )) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (format nil "~{~a~}" (list (gethash "ident" (sv-hash sv-MATCH))))) m)))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (sv-scalar (gethash "exp" (sv-hash sv-MATCH)))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))(return-from mp6-function sv-MATCH))))

;; method pair
(if (not (ignore-errors (find-method 'sv-pair () ())))
  (defgeneric sv-pair (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-pair ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-key sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "key" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "=>" (sv-substr sv-str (sv-to sv-MATCH ) 2))) (+ 1 (setf (sv-to sv-MATCH ) (+ 2 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "key" (sv-hash sv-MATCH))) (sv-scalar (gethash "exp" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (if (sv-bool (sv-eq ":" (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-sigil sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "sigil" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-ident sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "ident" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (let ((m (make-instance 'mp-Val-Buf))) (setf (sv-buf m) (format nil "~{~a~}" (list (gethash "ident" (sv-hash sv-MATCH))))) m) (let ((m (make-instance 'mp-Var))) (setf (sv-sigil m) (format nil "~{~a~}" (list (sv-scalar (gethash "sigil" (sv-hash sv-MATCH))))))(setf (sv-twigil m) "")(setf (sv-name m) (sv-scalar (gethash "ident" (sv-hash sv-MATCH)))) m))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1))))))))(return-from mp6-function sv-MATCH))))

;; method exp_mapping
(if (not (ignore-errors (find-method 'sv-exp_mapping () ())))
  (defgeneric sv-exp_mapping (sv-grammar &optional sv-str sv-pos)
      (:documentation "a method")))
(defmethod sv-exp_mapping ((sv-grammar mp-MiniPerl6-Grammar) &optional sv-str sv-pos)
  (block mp6-function
    (let ((sv-MATCH nil)) (setf sv-MATCH (let ((m (make-instance 'mp-MiniPerl6-Match))) (setf (sv-str m) sv-str)(setf (sv-from m) sv-pos)(setf (sv-to m) sv-pos)(setf (sv-bool m) 1) m))(setf (sv-bool sv-MATCH ) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-pair sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "pair" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-exp_mapping sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))(setf (gethash "exp_mapping" (sv-hash sv-MATCH)) sv-m2)1) (progn 0))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "pair" (sv-hash sv-MATCH))) (sv-scalar (gethash "exp_mapping" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(sv-and (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))) (sv-and (let ((sv-pos1 nil)) (setf sv-pos1 (sv-to sv-MATCH ))(sv-or (progn (sv-and (if (sv-bool (sv-eq "," (sv-substr sv-str (sv-to sv-MATCH ) 1))) (+ 1 (setf (sv-to sv-MATCH ) (+ 1 (sv-to sv-MATCH )))) 0) (let ((sv-m2 nil)) (setf sv-m2 (sv-opt_ws sv-grammar sv-str (sv-to sv-MATCH )))(if (sv-bool sv-m2) (progn (setf (sv-to sv-MATCH ) (sv-to sv-m2 ))1) (progn 0))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)1))) (let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list (sv-scalar (gethash "pair" (sv-hash sv-MATCH))))))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))))) (progn (setf (sv-to sv-MATCH ) sv-pos1)(let ((sv-ret nil)) (setf sv-ret ((lambda  ()
  (block mp6-function (progn (progn (return-from mp6-function (list )))"974^213")))
 ))(if (sv-bool (not (sv-eq sv-ret "974^213"))) (progn (setf (sv-capture sv-MATCH ) sv-ret)(setf (sv-bool sv-MATCH ) 1)(return-from mp6-function sv-MATCH)) (progn ))1)))))(return-from mp6-function sv-MATCH))))




