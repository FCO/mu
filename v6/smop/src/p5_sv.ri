%include <smop_p5.h>
%prefix smop_p5_sv
%attr SV* sv
%attr SMOP__Object* p5interpreter;
%RI.id Wrapped SV*

%{
  extern SMOP__Object* SMOP__P5__smop_interpreter;
  SMOP__Object* SMOP__P5__smop_p5interpreter;

  SMOP__Object* SMOP__P5__SV_create(SMOP__Object* interpreter,SMOP__Object* p5interpreter,SV* sv) {
    SMOP__Object* ret =  smop_lowlevel_alloc(sizeof(smop_p5_sv_struct));
    ret->RI = RI;
    ((smop_p5_sv_struct*)ret)->sv = SvREFCNT_inc(sv);
    ((smop_p5_sv_struct*)ret)->p5interpreter = p5interpreter;
    return ret;
  }

  SV* SMOP__Object2SV(SMOP__Object* interpreter,PerlInterpreter* my_perl,SMOP__Object* object) {
    if (object->RI == RI) {
      SV* ret = ((smop_p5_sv_struct*)object)->sv;
      SMOP_RELEASE(interpreter,object);
      return SvREFCNT_inc(ret);
    } else {
      SV* pointer = newSViv((int)object);
      HV* class = gv_stashpv("SMOP::Object", GV_ADD);
      return sv_bless(newRV_noinc(pointer), class);
    }
  }
%}

%message {
  ___NATIVE_CAPTURE_ONLY___;
  ___CONST_IDENTIFIER_ONLY___;

  SMOP__P5__smop_interpreter  = interpreter;

  SMOP__Object* invocant = (SMOP__Object*) SMOP__NATIVE__capture_invocant(interpreter, capture);
  SMOP__Object* ret = SMOP__NATIVE__bool_false;
  PerlInterpreter* my_perl = SMOP__P5__p5interpreter_unbox(interpreter,((smop_p5_sv_struct*)invocant)->p5interpreter);
  %%METHODS%%
  {
    SMOP__P5__smop_p5interpreter = ((smop_p5_sv_struct*)invocant)->p5interpreter;

    int len;
    char* method = SMOP__NATIVE__idconst_fetch_with_null(identifier,&len);

    dSP;

    ENTER;
    SAVETMPS;
    PUSHMARK(SP);
    XPUSHs(SMOP__Object2SV(interpreter,my_perl,invocant));

    XPUSHs(sv_2mortal(newSVpvn(method,len)));

    int positionals = SMOP__NATIVE__capture_positional_count(interpreter,capture);
    int i;
    for (i=0;i < positionals;i++) {
      SMOP__Object* object = SMOP__NATIVE__capture_positional(interpreter,capture,i);
      XPUSHs(SMOP__Object2SV(interpreter,my_perl,object));
    }

    PUTBACK;

    int count = call_pv("SMOP::coro_from_methodcall",G_SCALAR);
    if (count != 1) croak("Big trouble");


    SPAGAIN;
 

    SV* on_stack = POPs;
    SV* coro_sv = newSVsv(on_stack);
    assert(coro_sv);
    
    PUTBACK;
    FREETMPS;
    LEAVE;

    SMOP__Object* coro = SMOP__P5__Coro_create(interpreter,SMOP_REFERENCE(interpreter,SMOP__P5__smop_p5interpreter),coro_sv);

    SMOP__Object* frame = SMOP__Mold__Frame_create(interpreter,SMOP_REFERENCE(interpreter,mold_run_coro));
    SMOP__Object* current = SMOP_DISPATCH(interpreter, SMOP_RI(interpreter), SMOP__ID__continuation,
                                             SMOP__NATIVE__capture_create(interpreter,SMOP_REFERENCE(interpreter,interpreter),NULL,NULL));
    mold_reg_set(interpreter,frame,0,SMOP_REFERENCE(interpreter,interpreter));
    mold_reg_set(interpreter,frame,1,coro);
    mold_reg_set(interpreter,frame,2,current);
    SMOP_DISPATCH(interpreter,SMOP_RI(interpreter),SMOP__ID__goto,frame);

    free(method);
  }
  if (invocant) SMOP_RELEASE(interpreter,invocant);
  SMOP_RELEASE(interpreter,capture);
  return ret;
%}
%method FETCH
  ___VALUE_FETCH___

%method STORE
  ___VALUE_STORE___

%method Str
  STRLEN len;
  char* str = SvPV(((smop_p5_sv_struct*)invocant)->sv,len);
  ret = SMOP__NATIVE__idconst_createn(str,len);

%method int
  ret = SMOP__NATIVE__int_create(SvIV(((smop_p5_sv_struct*)invocant)->sv));

%method DESTROYALL
  SvREFCNT_dec(((smop_p5_sv_struct*)invocant)->sv); 
  SMOP_RELEASE(interpreter,((smop_p5_sv_struct*)invocant)->p5interpreter); 

%method postcircumfix:( )

  assert(SMOP__NATIVE__capture_positional_count(interpreter,capture) == 1);
  SMOP__Object* real_capture = SMOP__NATIVE__capture_positional(interpreter,capture,0);

  dSP;
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  int positionals = SMOP__NATIVE__capture_positional_count(interpreter,real_capture);
  int i;
  for (i=0;i < positionals;i++) {
    SMOP__Object* object = SMOP__NATIVE__capture_positional(interpreter,real_capture,i);
    XPUSHs(SMOP__Object2SV(interpreter,my_perl,object));
  }
  PUTBACK;

  call_sv(((smop_p5_sv_struct*)invocant)->sv, G_DISCARD);

  FREETMPS;
  LEAVE;

  SMOP_RELEASE(interpreter,real_capture);

%mold mold_run_coro
  my $interpreter;
  my $coro;
  my $back;
  my $void = $coro."set_back"($back);
  my $void = $interpreter."goto"($coro);


