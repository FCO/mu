
=encoding utf8

=head1 标题

大纲 二: 集腋成裘

=head1 作者

    Larry Wall <larry@wall.org>

=head1 译者

    卓明亮 <zhuomingliang@yahoo.com.cn>

=head1 感谢

    Carl Mäsak <cmasak@gmail.com>

=head1 版本

    创建日期: 2004 年 8 月 10 号
    最后修改: 2009 年 9 月 20 号

    版本: 180
    基于 SVN : 28440

This document summarizes Apocalypse 2, which covers small-scale
lexical items and typological issues.  (These Synopses also contain
updates to reflect the evolving design of Perl 6 over time, unlike the
Apocalypses, which are frozen in time as "historical documents".
These updates are not marked--if a Synopsis disagrees with its
Apocalypse, assume the Synopsis is correct.)

本文档概括了启示录二，它涵盖了小规模的词汇条目和类型问题。（这些纲要也
包含了 Perl 6 随时间推移体现不断演变设计的更新，这与被及时冻结为“历史
文档”的启示录不同。这些更新没有标记——如果大纲与它的启示录不一致，并假
设大纲是正确的。）

=head1 One-pass parsing

=head1 一遍解析

To the extent allowed by sublanguages' parsers, Perl is parsed using a
one-pass, predictive parser.  That is, lookahead of more than one
"longest token" is discouraged.  The currently known exceptions to
this are where the parser must:

在子语言语法分析器允许的程度上，Perl 使用一遍解析、预言性的语法分析程序
进行语法分析。也就是说，不鼓励一个以上“最长记号”超前。目前语法分析器已
知必须例外的地方是：

=over 4

=item *

Locate the end of interpolated expressions that begin with a sigil
and might or might not end with brackets.

寻找以印记开头额外的措辞末尾，并可能或不可能以括号结尾。

=item *

Recognize that a reduce operator is not really beginning a C<[...]> composer.

识别减法元操作符不是真正与 C<[...]> 中括号开头。

=back

=head1 Lexical Conventions

=head1 词法约定

=over 4

=item *

In the abstract, Perl is written in Unicode, and has consistent Unicode
semantics regardless of the underlying text representations.  By default
Perl presents Unicode in "NFG" formation, where each grapheme counts as
one character.  A grapheme is what the novice user would think of as a
character in their normal everyday life, including any diacritics.

理论上，Perl 使用 Unicode 编写，并且拥有一致的 Unicode 语义学，而不考虑含
蓄的文本陈述。默认情况下，Perl 以 “NFG” 结构呈现 Unicode，它每一个字形视为一
个字符。一个字形就是初级用户在他们每天正常生活会认为的一个字符，包括任何发音
符号。

=item *

Perl can count Unicode line and paragraph separators as line markers,
but that behavior had better be configurable so that Perl's idea of
line numbers matches what your editor thinks about Unicode lines.

Perl 会把 Unicode 行和段落分隔符视为行标记，但这种行为最好可配置，以便 Perl 的
行匹配符合编辑器对 Unicode 行的思想。

=item *

Unicode horizontal whitespace is counted as whitespace, but it's better
not to use thin spaces where they will make adjoining tokens look like
a single token.  On the other hand, Perl doesn't use indentation as syntax,
so you are free to use any amount of whitespace anywhere that whitespace
makes sense. Comments always count as whitespace.

Unicode 横向空白被视为空白，但最好不要在使毗邻记号看起来像单一记号的时候使用紧
间距。另一方面，Perl 不使用缩进作为语法，所以你可以在任何空白有意义的地方自由使
用任意数量的空白。注释常常被视为空白。

=item *

For some syntactic purposes, Perl distinguishes bracketing characters
from non-bracketing.  Bracketing characters are defined as any Unicode
characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf properties.

出于某些语法目的，Perl 区分括号字符和非括号字符。括号字符被定义为任何双向镜
像（Bidirectional mirrorings）或 Ps/Pe/Pi/Pf 属性的 Unicode 字符。

In practice, though, you're safest using matching characters with
Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable exception,
since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.

但实际上，你使用 Ps/Pe/Pi/Pf 属性是最安全的，尽管 ASCII 尖括号是个显著的例外，
因为它们是双向的但不在 Ps/Pe/Pi/Pf 集合里面。

Characters with no corresponding closing character do not qualify
as opening brackets.  This includes the second section of the Unicode
BidiMirroring data table.

字符没有相应的闭括号就不算开括号。这包含 Unicode 双向镜像数据表的第二部分。

If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry
in BidiMirroring is ignored (both forward and backward mappings).
For any given Ps character, the next Pe codepoint (in numerical
order) is assumed to be its matching character even if that is not
what you might guess using left-right symmetry.  Therefore C<U+298D>
maps to C<U+298E>, not C<U+2990>, and C<U+298F> maps to C<U+2990>,
not C<U+298E>.  Neither C<U+298E> nor C<U+2990> are valid bracket
openers, despite having reverse mappings in the BidiMirroring table.

如果字符已经使用 Ps/Pe/Pi/Pf 映射，则双向镜像的任何入口被忽略（向前映射
和向后映射）。对于任何给定的 Ps 字符，下一个 Pe 码点（按数字顺序）被假
定为它匹配的字符，即使这不是你可能已经猜到使用左右对称的字符。因此，C<U+298D>
映射到 C<U+298E>，不是 C<U+2990>，以及 C<U+298F> 映射到 C<U+2990>，而不
是 C<U+298E>。C<U+298E> 和 C<U+2990> 都不是有效的开括号，尽管在双向镜像表
中有反向映射。

The C<U+301D> codepoint has two closing alternatives, C<U+301E> and C<U+301F>;
Perl 6 only recognizes the one with lower code point number, C<U+301E>,
as the closing brace.  This policy also applies to new one-to-many
mappings introduced in the future.

C<U+301D> 码点有两个闭括号可选，C<U+301E> 和 C<U+301F>; Perl 6 只识别较小的
码点 C<U+301E> 作为闭括号。这项政策也适用于后面新推出的一对多映射。

However, many-to-one mappings are fine; multiple opening characters
may map to the same closing character.  For instance, C<U+2018>, C<U+201A>,
and C<U+201B> may all be used as the opener for the C<U+2019> closer.
Constructs that count openers and closers assume that only the given
opener is special.  That is, if you open with one of the alternatives,
all other alternatives are treated as non-bracketing characters within
that construct.

然而，多对一映射是可以的：多个开始符号，可以映射到同样的关闭符号。举个例子，
C<U+2018>，C<U+201A>，和 C<U+201B> 都可能被用作 C<U+2019> 关闭符号的开始符号。
统计开始与关闭符号的结构假定只有规定的开始符号是特别的。也就是说，如果你使用其
中一个开始符号，在那个结构中所有其它可选的开始符号被视为非括号字符。

=back

=head1 Whitespace and Comments

=head1 空白与注释

=over 4

=item *

Pod sections may be used reliably as multiline comments in Perl 6.
Unlike in Perl 5, Pod syntax now lets you use C<=begin comment>
and C<=end comment> delimit a Pod block correctly without the need
for C<=cut>.  (In fact, C<=cut> is now gone.)  The format name does
not have to be C<comment> -- any unrecognized format name will do
to make it a comment.  (However, bare C<=begin> and C<=end> probably
aren't good enough, because all comments in them will show up in the
formatted output.)

在 Perl 6，Pod 部分确实可以作为多行注释。与 Perl 5 不同，现在 Pod 语法允许你使
用 C<=begin comment> 和 C<=end comment> 正确地划分一个 Pod 块，而不用 C<=cut>。
（实际上，C<=cut> 现在没有了。）格式名称不一定是 C<comment> —— 任何未认可的格
式名称都使之成为注释。（然而，赤裸的 C<=begin> 和 C<=end> 可能不大好，因为它们
之间所有的注释将会在格式化输出中显示出来。）

We have single paragraph comments with C<=for comment> as well.
That lets C<=for> keep its meaning as the equivalent of a C<=begin>
and C<=end> combined.  As with C<=begin> and C<=end>, a comment started
in code reverts to code afterwards.

使用 C<=for comment>，我们也可以有单独段落的注释。这让 C<=for> 与 C<=begin> 联
合 C<=end> 保持相同的含义。与 C<=begin> 及 C<=end> 一样，源于代码中的注释后来会还
原成代码。

Since there is a newline before the first C<=>, the Pod form of comment
counts as whitespace equivalent to a newline.  See S26 for more on
embedded documentation.

既然在第一个 C<=> 之前有一个新行，Pod 注释格式认为空白等价于新行。关于嵌入式文档，
参考 S26 以获得更多信息。

=item *

Except within a string literal, a C<#> character always introduces a comment in
Perl 6.  There are two forms of comment based on C<#>.  Embedded
comments require the C<#> to be followed by a backtick (C<`>) plus one
or more opening bracketing characters.

除了在字符串中，C<#>操作符常常在 Perl 6 中引入注释。基于 C<#> 有两种格式的
注释。嵌入式注释需要 C<#> 紧跟着反引号（C<`>）加上一个或多个开括号字符。

All other uses of C<#> are interpreted as single-line comments that
work just as in Perl 5, starting with a C<#> character and
ending at the subsequent newline.  They count as whitespace equivalent
to newline for purposes of separation.  Unlike in Perl 5, C<#>
may I<not> be used as the delimiter in quoting constructs.

正如 Perl 5，所有其它 C<#> 用法被解释成单行注释，以 C<#> 字符开始并结束于后面
的新行。为了达到分割目的，它们视为空白等价于新行。与 Perl 5 不同，C<#> I<不> 
得在引用结构中作为分隔符。

=item *

Embedded comments are supported as a variant on quoting syntax, introduced
by C<#`> plus any user-selected bracket characters (as defined in
L</Lexical Conventions> above):

在引用语法中，支持一个嵌入式注释变体，采用 C<#`> 加上任何用户可选的括号字符
（正如上面 C<词法约定> 的定义）：

    say #`( embedded comment ) "hello, world!";

    $object\#`{ embedded comments }.say;

    $object\ #`「
        embedded comments
    」.say;

Brackets may be nested, following the same policy as ordinary quote brackets.

括号可以被嵌套，遵循普通引用括号的策略。

There must be no space between the C<#`> and the opening bracket character.
(There may be the I<visual appearance> of space for some double-wide
characters, however, such as the corner quotes above.)

C<#`> 与开括号字符之间必须不能有空格。（不过双宽度字符可能有空格视觉出现，比
如上面的角引号。）

For multiline comments it is recommended (but not required) to use two or
more brackets both for visual clarity and to avoid relying too much on
internal bracket counting heuristics when commenting code that may accidentally
miscount single brackets:

对于多行注释推荐使用（但不要求）使用两个或者更多括号，不仅让视觉明晰而且在注
释代码偶而可能错误计算单括号的时候避免在内部括号计数器应用方面太多的依懒：

    #`{{
        say "here is an unmatched } character";
    }}

However, it's sometimes better to use Pod comments because they are
implicitly line-oriented.

不管怎么样，有时候最好使用 Pod，因为它们暗示地面向行。

=item *

For all quoting constructs that use user-selected brackets, you can open
with multiple identical bracket characters, which must be closed by the
same number of closing brackets.  Counting of nested brackets applies only
to pairs of brackets of the same length as the opening brackets:

对于所有用户可选的括号引号结构，你可以通过多个同样的括号字符展开，也必须通过
同样数量的闭括号关闭。

    say #`{{
        This comment contains unmatched } and { { { {   (ignored)
        Plus a nested {{ ... }} pair                    (counted)
    }} q<< <<woot>> >>   # says " <<woot>> "

Note however that bare circumfix or postcircumfix C<<< <<...>> >>> is
not a user-selected bracket, but the ASCII variant of the C<< «...» >>
interpolating word list.  Only C<#`> and the C<q>-style quoters (including
C<m>, C<s>, C<tr>, and C<rx>) enable subsequent user-selected brackets.

然而请注意，赤裸的环缀或后环缀 C<<< <<...>> >>> 不是用户可选的括号。
但 ASCII 的 C<< «...» >> 变体加入了词表。只有 C<#`> 和 C<q> 风格引用号（包
括 C<m>，C<s>，C<tr> 和 C<rx>）使后面用户可选的括号可行。

=item *

Some languages such as C allow you to escape newline characters
to combine lines.  Other languages (such as regexes) allow you to
backslash a space character for various reasons.  Perl 6 generalizes
this notion to any kind of whitespace.  Any contiguous whitespace
(including comments) may be hidden from the parser by prefixing it
with C<\>.  This is known as the "unspace".  An unspace can suppress
any of several whitespace dependencies in Perl.  For example, since
Perl requires an absence of whitespace between a noun and a postfix
operator, using unspace lets you line up postfix operators:

有些语言比如 C 运行使用转义换行符来合并行。由于各种原因，其它语言（比如正则表达
式）允许反斜杠空格字符。Per 6 概括这种观念为任何种类的空格字符。通过使用前
缀 C<\>，任何连续的空格（包括注释）都会从语法分析器中隐藏。这称为“反空格”。
在 Perl 中，反空格可以阻止任意若干个空白关联。举个例子，既然 Perl 需要在名词
和后缀操作符之间缺席，使用反空格让你与后缀操作符排成行。

    %hash\  {$key}
    @array\ [$ix]
    $subref\($arg)

As a special case to support the use above, a backslash where
a postfix is expected is considered a degenerate form of unspace.
Note that whitespace is not allowed before that, hence

作为支持上面使用方式的特例，后缀操作符要求有反斜杠的地方被认为是反空格的退化。
注意在反斜杠之前是不允许有空白，因此：

    $subref \($arg)

is a syntax error (two terms in a row).  And

是个语法错误（一行两个术语）。与

    foo \($arg)

will be parsed as a list operator with a C<Capture> argument:

将被分析成带 C<捕获> 参数的列表操作符：

    foo(\($arg))

However, other forms of unspace may usefully be preceded by whitespace.
(Unary uses of backslash may therefore never be followed by whitespace
or they would be taken as an unspace.)

然而，空白实际上可以紧跟着其它形式的反空格。（因此反斜杠的单一使用后面绝不可
能有空白或它们将被视为反空格。）

Other postfix operators may also make use of unspace:

其它后缀操作符也可以使用反空格：

    $number\  ++;
    $number\  --;
    1+3\      i;
    $object\  .say();
    $object\#`{ your ad here }.say

Another normal use of a you-don't-see-this-space is typically to put
a dotted postfix on the next line:

另外一种你看不见该空格的普遍用法通常是放一个点后缀操作符到下一行：

    $object\ # comment
    .say

    $object\#`[ comment
    ].say

    $object\
    .say

But unspace is mainly about language extensibility: it lets you continue
the line in any situation where a newline might confuse the parser,
regardless of your currently installed parser.  (Unless, of course,
you override the unspace rule itself...)

但反空格主要是语言的扩展性：它让你在任何可能搞混语法分析器的地方继续该行，不管
你现在安装的语法分析器。（当然，除非你覆盖了它自己的反空格规则……）

Although we say that the unspace hides the whitespace from the parser,
it does not hide whitespace from the lexer.  As a result, unspace is not
allowed within a token.  Additionally, line numbers are still
counted if the unspace contains one or more newlines.
Since Pod chunks count as whitespace to the language, they are also
swallowed up by unspace.  Heredoc boundaries are suppressed, however,
so you can split excessively long heredoc intro lines like this:

尽管我们说反空格从语法分析器中隐藏了空白，但它没有从词法分析器中隐藏。因此，反
空格不允许在记号里面。此外，如果反空格包含一个以上的新行，行数仍然会被统计。既
然对于该语言 Pod 块被视为空白，它们也被反空格吞噬。然而 Heredoc 分界线是抑制的，
所以你可以像这样极大地分离冗长的 heredoc 引入线：

    ok(q:to'CODE', q:to'OUTPUT', \
    "Here is a long description", \ # --more--
    todo(:parrøt<0.42>, :dötnet<1.2>));
        ...
        CODE
        ...
        OUTPUT

To the heredoc parser that just looks like:

对于 heredoc 语法分析器仅仅看起来像：

    ok(q:to'CODE', q:to'OUTPUT', "Here is a long description", todo(:parrøt<0.42>, :dötnet<1.2>));
        ...
        CODE
        ...
        OUTPUT

Note that this is one of those cases in which it is fine to have
whitespace before the unspace, since we're only trying to suppress
the newline transition, not all whitespace as in the case of postfix
parsing.  (Note also that the example above is not meant to spec how
the test suite works. )

注意这是可以让空白放在反空格之前的其中一个例子，因为我们只是尝试抑制新行转换，
不是所有的空白和这个后缀解析情况一样。（还有注意，上面的例子并不意味着说明测试
套件是如何工作的。）

=item *

An unspace may contain a comment, but a comment may not contain an unspace.
In particular, end-of-line comments do not treat backslash as significant.
If you say:

反空格可以包含注释，但注释不可以包含反空格，特别地，行尾注释认为反斜杠符号没有意义。
如果你写：

    #`\ (...

or

    #\ `(...

it is an end-of-line comment, not an embedded comment.  Write:

这是一行行尾注释，不是嵌入式注释。写：

    \ #`(
         ...
        )

to mean the other thing.

则表示其它意思。

=item *

In general, whitespace is optional in Perl 6 except where it is needed
to separate constructs that would be misconstrued as a single token or
other syntactic unit.  (In other words, Perl 6 follows the standard
I<longest-token> principle, or in the cases of large constructs, a
I<prefer shifting to reducing> principle.  See L</Grammatical Categories>
below for more on how a Perl program is analyzed into tokens.)

通常，Perl 6 中的空白是可选的，除非它需要用来分割被误解成一个单记号或者其它语法
单元的结构。（也就是说，Perl 6 遵循 标准的 I<最长记号> 原则，或大型结构，一
个 I<喜欢转移而不是减少> 原则。关于 Perl 程序如何分析为记号，参考下面
的 L<文法分类> 以获得更多信息。）

This is an unchanging deep rule, but the surface ramifications of it
change as various operators and macros are added to or removed from
the language, which we expect to happen because Perl 6 is designed to
be a mutable language.  In particular, there is a natural conflict
between postfix operators and infix operators, either of which
may occur after a term.  If a given token may be interpreted as
either a postfix operator or an infix operator, the infix operator
requires space before it.  Postfix operators may never have intervening
space, though they may have an intervening dot.  If further separation
is desired, an unspace or embedded comment may be used as described above, as long
as no whitespace occurs outside the unspace or embedded comment.

这是一个不变的底层原则，但随着大量的操作符或者宏从语言中被添加或者删除，它的表
面分歧改变了，正如我们期待的发生，因为 Perl 6 被设计为可变语言。特别地，中缀操作
符与后缀操作符之间有个天然冲突，它们任何一个都会出现在术语后面。如果给定的记号
被解释成后缀操作符或中缀操作符，那么中缀操作符之前需要一个空格。后缀操作符应该
决没有介于中间的空格，尽管它们可能有一个介于中间的点。如果进一步要求分离，反
空格或者嵌入式注释应该正如上描述的那样使用，只要没有空白出现在反空格或者嵌入式
注释之外。

For instance, if you were to add your own C<< infix:<++> >> operator,
then it must have space before it. The normal autoincrementing
C<< postfix:<++> >> operator may never have space before it, but may
be written in any of these forms:

例如：如果你添加你自己的 C<< infix:<++> >> 操作符，那么它之前必须有个空格。标准
自动增加 C<< postfix:<++> >> 操作符之前可能从来没有空格，但是可以以任何这些形
式编写：


    $x++

    $x\++

    $x.++

    $x\ ++

    $x\ .++

    $x\#`( comment ).++
    $x\#`((( comment ))).++

    $x\
    .++

    $x\         # comment
                # inside unspace
    .++

    $x\         # comment
                # inside unspace
    ++          # (but without the optional postfix dot)

    $x\#`『      comment
                more comment
    』.++

    $x\#`[   comment 1
    comment 2
    =begin Podstuff
    whatever (Pod comments ignore current parser state)
    =end Podstuff
    comment 3
    ].++

A consequence of the postfix rule is that (except when delimiting a
quote or terminating an unspace) a dot with whitespace in front
of it is always considered a method call on C<$_> where a term is
expected.  If a term is not expected at this point, it is a syntax
error.  (Unless, of course, there is an infix operator of that name
beginning with dot.  You could, for instance, define a Fortranly
C<< infix:<.EQ.> >> if the fit took you.  But you'll have to be sure to
always put whitespace in front of it, or it would be interpreted as
a postfix method call instead.)

一个后缀规则的后果是（除非划分引用界限或者终止反空格），点之前的空格常常被认
为 C<$_> 的上面的一个方法调用，在这个地方常常需要一个术语。如果这时候没有一个
术语，那么这是语法错误。（当然，除非点开始之前有这个名称的中缀操作符，举个例子，
如果合适的话，你可以定义一个公式翻译器 C<< infix:<.EQ.> >>。但你不得不保证常常在
它之前放一个空白，否则它将被解释成后缀方法调用。）

For example,

例如，

    foo .method

and

和

    foo
    .method

will always be interpreted as

将被解释成

    foo $_.method

but never as

但从不作为

    foo.method

Use some variant of

使用一些不同的

    foo\
    .method

if you mean the postfix method call.

如果你是指后缀函数调用。

One consequence of all this is that you may no longer write a Num as
C<42.> with just a trailing dot.  You must instead say either C<42>
or C<42.0>.  In other words, a dot following a number can only be a
decimal point if the following character is a digit.  Otherwise the
postfix dot will be taken to be the start of some kind of method call
syntax.  (The C<.123> form with a leading
dot is still allowed however when a term is expected, and is equivalent
to C<0.123> rather than C<$_.123>.)

所有这些结果就是你可能不再使用句点将 Num 写成 C<42.>。你必须改为写
成 C<42> 或 C<42.0>。换句话说，如果数字后面的点只能是小数点，如果点后面的字符是
数字的话。否则这个后缀点将视为某种方法的调用语法开始。（ 然而，当需要术语的时候，
以点开头的 C<.123> 形式仍然允许，并等价于 C<0.123>，而不是 C<$_.123>。）

=back

=head1 Built-In Data Types

=head1 内置数据类型

=over 4

=item *

In support of OO encapsulation, there is a new fundamental datatype:
B<P6opaque>.  External access to opaque objects is always through method
calls, even for attributes.

为了支持 OO 封装，这里有个基本数据类型：B<P6opaque>。外部通常通过方法调用处
理 opaque 对象，即使是对 attributes 进行处理。

=item *

Perl 6 has an optional type system that helps you write safer
code that performs better.  The compiler is free to infer what type
information it can from the types you supply, but will not complain
about missing type information unless you ask it to. 

Perl 6 有个可选的类型系统来帮助你写效率更高的安全代码。编译器可以从你提供的类
型里面自由地推断它能容下什么类型信息，但除非你要求它，否则它不会抱怨缺少的类型
信息。

=item *

Types are officially compared using name equivalence rather than
structural equivalence.  However, we're rather liberal in what we
consider a name.  For example, the name includes the version and
authority associated with the module defining the type (even if
the type itself is "anonymous").  Beyond that, when you instantiate
a parametric type, the arguments are considered part of the "long
name" of the resulting type, so one C<Array of Int> is equivalent to
another C<Array of Int>.  (Another way to look at it is that the type
instantiation "factory" is memoized.)  Typename aliases are considered
equivalent to the original type.  In particular, the C<Array of Int> syntax
is just sugar for C<Array:of(Int)>, which is the canonical form of an
instantiated generic type.

类型正式比较是使用名称对比而不是结构对比。然而，我们对自己考虑的名称比较宽松。
举个例子，名称包含了版本和该模块定义类型相关的权威信息（即使类型本身是“匿名
的”）。除此之外，当你实例化一个参数类型，参数被认为是由此产生的类型中“长名称”的
一部分，所以一个 C<Array of Int> 等价于另外一个 C<Array of Int>。（以另外一种方式
来看待，类型实例“工厂”是被保存的。）类型名称别名被认为等价于原生类型。特别地，
C<Array of Int> 仅仅是实例化泛型类型标准形式 C<Array:of(Int)> 的语法糖。

This name equivalence of parametric types extends only to parameters
that can be considered immutable (or that at least can have an
immutable snapshot taken of them).  Two distinct classes are never
considered equivalent even if they have the same attributes because
classes are not considered immutable.

参数类型的名称等价仅适用于被认为不可变的参数（或者它们之间只少有一个不可变快
照）。即使两个不同的类有同样的 attributes，也从来不认为等价，因为它们不认为是可
变类型。

=item *

Perl 6 supports the notion of B<properties> on various kinds of
objects.  Properties are like object attributes, except that they're
managed by the individual object rather than by the object's class.

Perl 6 对各种对象支持 B<properties> 概念。Properties 与对象 attributes
类似，除了它们被独立的对象管理，而不是被对象的类管理。

According to S12, properties are actually implemented by a
kind of mixin mechanism, and such mixins are accomplished by the
generation of an individual anonymous class for the object (unless
an identical anonymous class already exists and can safely be shared).

根据 S12，properties 实际上是通 1 种混合机制实现，这样的混合体是为对象通过一个
独特匿名类的衍生而实现的（除非一个完全相同的匿名类已经存在并可以被安全共享）。

=item *

Properties applied to objects constructed at compile-time, such as
variables and classes, are also called B<traits>.  Traits cannot be
changed at run-time.  Changes to run-time properties are done via
mixin instead, so that the compiler can optimize based on declared traits.

Properties 适用于对象在编译时构建，比如变量和类，也被称为 B<特性>。特性不能在运
行时被改变。运行时 properties 的改变是经过混合体代替完成，所以编译器可以基于声
明特性优化。

=item *

Perl 6 is an OO engine, but you're not generally required to think
in OO when that's inconvenient.  However, some built-in concepts such
as filehandles will be more object-oriented in a user-visible way
than in Perl 5.

Perl 6 是个 OO（面向对象） 引擎，但你不方便的时候一般不需要用 OO 考虑。
然而，一些内置思想比如 filehands（文件句柄）在用户可见的方式中将会比 Perl 5 更加
面向对象。

=item *

A variable's type is a constraint indicating what sorts of values the
variable may contain.  More precisely, it's a promise that the object
or objects contained in the variable are capable of responding to the
methods of the indicated "role".  See S12 for more about roles.

变量类型是一种约束，它说明了变量可能包含什么类型的值。更准确地说，它承诺变量中
包含的一个或者多个对象能够响应指定“role”中的方法。参考 S12 以获得更多关
于 role 的信息。 

    # $x can contain only Int objects
    my Int $x;

    # $x 只能包含 Int 对象
    my Int $x;

A variable may itself be bound to a container type that specifies how
the container works, without specifying what kinds of things it contains.

变量本身可能被绑定到容器类型来说明容器如何工作，而没有说明它包含什么样的东西。


    # $x is implemented by the MyScalar class
    my $x is MyScalar;

    # $x 通过 MyScalar 类实现
    my $x is MyScalar;

Constraints and container types can be used together:

约束类型和容器类型可以一起使用：

    # $x can contain only Int objects,
    # and is implemented by the MyScalar class
    my Int $x is MyScalar;

Note that C<$x> is also initialized to the C<Int> type object.  See below for
more on this.

注意 C<$x> 也被初始化到 C<Int> 类型对象。关于这个，请参考下面以获得更多信息。

=item *

C<my Dog $spot> by itself does not automatically call a C<Dog> constructor.
It merely assigns an undefined C<Dog> prototype object to C<$spot>:

C<my Dog $spot> 本身不会自动调用 C<Dog> 构造函数。它仅仅赋值一个未定义
的 C<Dog> 原型对象给 C<$spot>：

    my Dog $spot;           # $spot is initialized with ::Dog
    my Dog $spot = Dog;     # same thing

    $spot.defined;          # False
    say $spot;              # "Dog"

    my Dog $spot;           # $spot 使用 ::Dog 初始化
    my Dog $spot = Dog;     # 同样的事情

    $spot.defined;          # False
    say $spot;              # "Dog"

Any type name used as a value is an undefined instance ofthat type's 
prototype object, or I<type object> for short.  See S12 for more on that.

任何作为值使用的类型名称是该类型原型对象的未定义实例化，简称“类型对象”。参
考 S12 以获得更多那方面的信息。

Any type name in rvalue context is parsed as a single type value and
expects no arguments following it.  However, a type object responds to the 
function call interface, so you may use the name of a type with parentheses
as if it were a function, and any argument supplied to the call is coerced
to the type indicated by the type object.  If there is no argument
in the parentheses, the type object returns itself:

右值范围内的任何类型名称被解析为单一类型的值并期望它后面没有参数。然而，类型对
象响应函数调用接口，所以你可以通过圆括号使用类型的名称，好像它是个函数一样，并且
任何提供给该调用的参数强制为该类型所显示类型对象的类型。如果圆括号里面没有参
数，该类型对象返回本身：

    my $type = Num;             # type object as a value
    $num = $type($string)       # coerce to Num

    my $type = Num;             # 类型对象作为值
    $num = $type($string)       # 强制为 Num

To get a real C<Dog> object, call a constructor method such as C<new>:

为了获得一个真正的 C<Dog> 对象，需要调用一个构造方法，比如 C<new>：

    my Dog $spot .= new;
    my Dog $spot = $spot.new;   # .= is rewritten into this

    my Dog $spot .= new;
    my Dog $spot = $spot.new;   # .= 被重写为这样

You can pass in arguments to the constructor as well:

你也可以传递参数到构造方法里面：

    my Dog $cerberus .= new(heads => 3);
    my Dog $cerberus = $cerberus.new(heads => 3);   # same thing

    my Dog $cerberus .= new(heads => 3);
    my Dog $cerberus = $cerberus.new(heads => 3);   # 同样的事情

=item *

If you say

如果你写

    my int @array is MyArray;

you are declaring that the elements of C<@array> are native integers,
but that the array itself is implemented by the C<MyArray> class.
Untyped arrays and hashes are still perfectly acceptable, but have
the same performance issues they have in Perl 5.

那么你在声明 C<@array> 的元素为原生整型，但该数组本身通过 C<MyArray> 类实现。
无类型的数组和哈希表仍然完全可以接受，但是和 Perl 5 有同样的性能问题。

=item *

To get the number of elements in an array, use the C<.elems> method.  You can
also ask for the total string length of an array's elements, in bytes,
codepoints or graphemes, using these methods C<.bytes>, C<.codes> or C<.graphs>
respectively on the array.  The same methods apply to strings as well.
(Note that C<.bytes> is not guaranteed to be well-defined when the encoding
is unknown.  Similarly, C<.codes> is not well-defined unless you know which
canonicalization is in effect.  Hence, both methods allow an optional argument
to specify the meaning exactly if it cannot be known from context.)

为了获取数字中的元素编号，使用 C<.elems> 方法。 你也可以通过 C<.bytes>，
C<.codes> 或者 C<.graphs> 以字节，码点或者字形来请求数组元素的总字符串长
度。这些方法也适用于字符串。（注意当编码未知的时候 C<.bytes> 不能保证有明确的
定义。同样地，除非你知道哪个规范有效，否则 C<.codes> 没有明确的定义。因此，如果
不能从上下文中知道，两个方法都允许一个可选的参数来正确地指定含义。

There is no C<.length> method for either arrays or strings, because C<length>
does not specify a unit.

数组和字符串对象都没有 C<.length> 方法，因为 C<length> 没有具体指定单元。

=item *

Built-in object types start with an uppercase letter. This includes
immutable types (e.g. C<Int>, C<Num>, C<Complex>, C<Rat>, C<Str>,
C<Bit>, C<Regex>, C<Set>, C<Block>, C<List>,
C<Seq>), as well as mutable (container) types, such as C<Scalar>,
C<Array>, C<Hash>, C<Buf>, C<Routine>, C<Module>, and non-instantiable Roles
such as C<Callable>, C<Failure>, and C<Integral>.

内置对象类型使用大写字母开头。这包含不可变类型（例如：C<Int>，C<Num>，C<Complex>，
C<Rat>，C<Str>，C<Bit>，C<Regex>，C<Set>，C<Block>，C<List>，C<Seq>），以及可变（容器）
类型，比如 C<Scalar>，C<Array>，C<Hash>，C<But>，C<Routine>，C<Module>，和非实例化角
色，比如 C<Callable>，C<Failure> 和 C<Integral>。

Non-object (native) types are lowercase: C<int>, C<num>, C<complex>,
C<rat>, C<buf>, C<bit>.  Native types are primarily intended for
declaring compact array storage.  However, Perl will try to make those
look like their corresponding uppercase types if you treat them that way.
(In other words, it does autoboxing.  Note, however, that sometimes
repeated autoboxing can slow your program more than the native type
can speed it up.)

非对象（原生）类型是小写：C<int>，C<num>，C<complex>，C<rat>，C<buf>，C<bit>。原生类
型主要用于紧凑型阵列存储声明。然而，如果你尝试以大写类型对待原生类型，Perl 将会
尝试使它们看起来像它们一致的大写类型。（换句话说，Perl 进行了自动封箱。但是请注
意，有时候反复自动封箱会减慢你的程序，它慢过了原生类型可以加快的速度。）

The C<junction> type is considered a native type because its internal
representation is fixed, and you may not usefully derive from it
because the intent of junctions is to autothread any method calls
on them.

C<junction> 类型被认为是原生类型，因为它的内在表现是固定的，你可能不会从中得益，
因为 junction 的目的是自动穿越它们上面的任何方法调用。

Some object types can behave as value types.  Every object can produce
a "WHICH" value that uniquely identifies the object for hashing and other
value-based comparisons.  Normal objects just use their address in memory,
but if a class wishes to behave as a value type, it can define 
a C<.WHICH> method that makes different objects look like the same object if
they happen to have the same contents.

一些对象类型可以表现为值类型。每个对象可以产生一个“WHICH”值，它给哈希表和其它
基于值的比较唯一地标示了该对象。普通对象仅仅使用其内存地址，但如果类要表现为值
类型，它可以定义一个 C<.WHICH> 方法使不同的对象看起来像一样的对象，如果它们刚好
有相同的内容。

=item *

Variables with non-native types can always contain I<undefined> values,
such as C<Object>, C<Whatever> and C<Failure> objects.  See S04 for more
about failures (i.e. unthrown exceptions):

非原生类型变量可以随时包含 I<未定义的> 的值，比如 C<Object>，
C<Whatever> 和 C<Failure> 对象。关于 failure，参考 S04 以获得更多信息（即，未
抛出异常）：

    my Int $x = undef;    # works

Variables with native types do not support undefinedness: it is an error
to assign an undefined value to them:

原生类型变量不支持未定义：赋值给未定义的值给它们是错误的：

    my int $y = undef;    # dies

Conjecture: num might support the autoconversion of undef to NaN, since
the floating-point form can represent this concept.  Might be better
to make that conversion optional though, so that the rocket designer
can decide whether to self-destruct immediately or shortly thereafter.

推测：由于浮点形式可以代表这一概念，num 可能支持 undef 自动转换到 NaN。然而可能
最好让该转换可选，以使火箭设计者决定是否需要马上或者很快自毁。

Variables of non-native types start out containing an undefined value
unless explicitly initialized to a defined value.

非原生类型变量开始时包含一个未定义的值，除非明确初始化为一个定义的值。

=item *

Every object supports a C<HOW> function/method that returns the
metaclass instance managing it, regardless of whether the object
is defined:

每个对象支持 <HOW> 函数/方法，它返回管理自己的超类实例，无论该对象
是否定义：

    'x'.HOW.methods('x');   # get available methods for strings
    Str.HOW.methods(Str);   # same thing with the prototype object Str
    HOW(Str).methods(Str);  # same thing as function call

    'x'.methods;        # this is likely an error - not a meta object
    Str.methods;        # same thing

    'x'.HOW.methods('x');   # 从字符串中获取可用的方法
    Str.HOW.methods(Str);   # 同样的事情，使用原型对象 Str
    HOW(Str).methods(Str);  # 同样的事情，为函数调用

    'x'.methods;        # 这可能是错误的——不是元类
    Str.methods;        # 同样的事情

(For a prototype system (a non-class-based object system), all objects
are merely managed by the same meta object.)

(对于原型系统（非基于类的对象系统），所有对象仅仅被同样的元对象控制。）

=item *

Perl 6 intrinsically supports big integers and rationals through its
system of type declarations.  C<Int> automatically supports promotion
to arbitrary precision, as well as holding C<Inf> and C<NaN> values.
Note that C<Int> assumes 2's complement arithmetic, so C<+^1 == -2>
is guaranteed.  (Native C<int> operations need not support this on
machines that are not natively 2's complement.  You must convert to
and from C<Int> to do portable bitops on such ancient hardware.)

通过类型声明系统，Perl 6 本质上支持大整数和有理数。C<Int> 自动支持提升到任意精
度，以及支持 C<Inf> 和 C<NaN> 值。注意 C<Int> 承担 2 的补码运算，所
以 C<+^1 == -2> 是肯定的。（原生 C<int> 操作不需要在不是原生支持 2 补码的机器
上支持该运算。你必须在这么旧的机器上转换和从 <Int> 做可移植的位操作。）

(C<Num> may support arbitrary-precision floating-point arithmetic, but
is not required to unless we can do so portably and efficiently.  C<Num>
must support the largest native floating point format that runs at full
speed.)

（C<Num> 可以支持任意精度的浮点运算，但不要求，除非我们可以这么有效地和可移植地
做。C<Num> 必须支持全速运行的最大原生浮点格式。）

C<Rat> supports arbitrary precision rational arithmetic.
Dividing two C<Int> objects using C<< infix:</> >> produces a
a C<Rat>, which is generally usable anywhere a C<Num> is usable, but
may also be explicitly cast to C<Num>.  (Also, if either side is
C<Num> already, C<< infix:</> >> gives you a C<Num> instead of a C<Rat>.)

C<Rat>支持任意精度的有理数运算。使用 C<< infix:</> >> 除两个 C<Int> 对象产生
一个 C<Rat>，它一般用于任何 C<Num> 可用的地方，但也可以精确转换成 C<Num>。
（同样地，如果任何一方已经是 C<Num>，C<< infix:</> >> 给你一个 C<Num>，而不
是 C<Rat>。）

Lower-case types like C<int> and C<num> imply the native
machine representation for integers and floating-point numbers,
respectively, and do not promote to arbitrary precision, though
larger representations are always allowed for temporary values.
Unless qualified with a number of bits, C<int> and C<num> types represent
the largest native integer and floating-point types that run at full speed.

像 C<int> 和 C<num> 小写类型意味着分别对整数和浮点数的本地机器的陈述，但不提倡以
任意精度，尽管大量的代理对于临时值是始终允许的。除非许多位都合格，
C<int> 和 C<num> 类型描绘了全速运行的最大原生整型和浮点类型。

Numeric values in untyped variables use C<Int> and C<Num> semantics
rather than C<int> and C<num>.

无类型变量的数字值使用 C<Int> 和 C<Num> 语义而不是 C<int> 和 C<num>。

=item *

Perl 6 should by default make standard IEEE floating point concepts
visible, such as C<Inf> (infinity) and C<NaN> (not a number).  Within a
lexical scope, pragmas may specify the nature of temporary values,
and how floating point is to behave under various circumstances.
All IEEE modes must be lexically available via pragma except in cases
where that would entail heroic efforts to bypass a braindead platform.

默认情况下，Perl 6 应使标准的 IEEE 浮点概念可见，比如 C<Inf> （无穷大）和 C<NaN>
（非数字）。在词法范围内，参数应该指明临时变量的类型，以及在各种情况下浮点是如何
表现的。所有 IEEE 模式必须通过参数词法上可用，除非需要承受极大努力来忽视愚蠢的
平台。

The default floating-point modes do not throw exceptions but rather
propagate Inf and NaN.  The boxed object types may carry more detailed
information on where overflow or underflow occurred.  Numerics in Perl
are not designed to give the identical answer everywhere.  They are
designed to give the typical programmer the tools to achieve a good
enough answer most of the time.  (Really good programmers may occasionally
do even better.)  Mostly this just involves using enough bits that the
stupidities of the algorithm don't matter much.

默认的浮点模式不抛出异常，而是传递 Inf 和 NaN。盒对象类型可以记录更多关于上溢
或者下溢在哪里发生的详细信息。Perl 中的数字不是为了在任何地方给予相同的答案。
它们大多时候是为了给典型程序员工具来实现足够好的答案。（真正优秀的程序员偶尔会
做得更好。）这只是大概涉及到使用足够的位，愚蠢算法不太关心这些位。

=item *

A C<Str> is a Unicode string object.  There is no corresponding native
C<str> type.  However, since a C<Str> object may fill multiple roles,
we say that a C<Str> keeps track of its minimum and maximum Unicode
abstraction levels, and plays along nicely with the current lexical
scope's idea of the ideal character, whether that is bytes, codepoints,
graphemes, or characters in some language.  For all builtin operations,
all C<Str> positions are reported as position objects, not integers.
These C<StrPos> objects point into a particular string at a particular
location independent of abstraction level, either by tracking the
string and position directly, or by generating an abstraction-level
independent representation of the offset from the beginning of the
string that will give the same results if applied to the same string
in any context.  This is assuming the string isn't modified in the
meanwhile; a C<StrPos> is not a "marker" and is not required to follow
changes to a mutable string.  For instance, if you ask for the positions
of matches done by a substitution, the answers are reported in terms of the
original string (which may now be inaccessible!), not as positions within
the modified string.

C<Str> 是 Unicode 字符串对象。没有相应的原生 C<str> 类型。然而，既然 C<Str> 对
象可以装满多种多样的 role，我们就说 C<Str> 保持跟踪它的最小和最大 Unicode 抽象
层，并巧妙地参与当前理想字符词法范围的构想，不管那是字节，码点，字形或者某些
语言中的字符。对于所有内部操作，所有 C<Str> 位置被描述为定位对象，而不是整数。
这些 C<StrPos> 对象指向于特殊字符串中独立于抽象层的一个特殊位置，或通过直接跟
踪字符串和位置，或者通过从字符串开始产生一个偏移值的抽象层独立表示，该字符串如
果适用于同样的字符串，它将在任何上下文中产生同样的结果。这是假设字符串同时没有
被修改；C<StrPos> 不是一个记号，也不需要遵循可变字符串的变化。举个例子，如果你请
求通过替代完成的匹配位置，答案是以原始字符串的方式报告（它现在可能难以达成！），
不是以修改后的字符串的位置。

The subtraction of two C<StrPos> objects gives a C<StrLen> object,
which is also not an integer, because the string between two positions
also has multiple integer interpretations depending on the units.
A given C<StrLen> may know that it represents 18 bytes, 7 codepoints,
3 graphemes, and 1 letter in Malayalam, but it might only know this
lazily because it actually just hangs onto the two C<StrPos> endpoints
within the string that in turn may or may not just lazily point into
the string.  (The lazy implementation of C<StrLen> is much like a
C<Range> object in that respect.)

两个 C<StrPos> 对象相减产生一个 C<StrLen> 对象，它也不是一个整数，因为两个位置
之间的字符串也有多个取决于单元的整数解释。给定的 C<StrLen> 应该知道它表
示 18 字节，7 个码点，3 个字形 和 马拉雅拉姆语的一个字母，但它可能只懒洋洋地
知道这个，因为它实际上仅仅悬在字符串这两个 C<StrPos> 端点，反过来也可能或不可能
仅仅懒惰地指向字符串。（C<StrLen> 的懒惰实现在那方面更像 C<Range> 对象。）

If you use integers as arguments where position objects are expected,
it will be assumed that you mean the units of the current lexically
scoped Unicode abstraction level.  (Which defaults to graphemes.)
Otherwise you'll need to coerce to the proper units:

如果你使用整数作为定位对象所期望的参数，这将假设你意指当前词法作用
域 Unicode 抽象层。（它默认为字形。）否则，你需要强制为适当的单位：

    substr($string, Bytes(42), ArabicChars(1))

Of course, such a dimensional number will fail if used on a string
that doesn't provide the appropriate abstraction level.

当然，这样一个维数如果在一个没有提供适当抽象层的字符串上使用将会失败。

If a C<StrPos> or C<StrLen> is forced into a numeric context, it will
assume the units of the current Unicode abstraction level.  It is
erroneous to pass such a non-dimensional number to a routine that
would interpret it with the wrong units.

如果 C<StrPos> 或 C<StrLen> 被强迫为数字环境，它将会承担为当前 Unicode 抽象层
单元。传递无量纲数到一个将用错误单元解释它的例行程序是不正确的。

Implementation note: since Perl 6 mandates that the default Unicode
processing level must view graphemes as the fundamental unit rather
than codepoints, this has some implications regarding efficient
implementation.  It is suggested that all graphemes be translated on
input to a unique grapheme numbers and represented as integers within
some kind of uniform array for fast substr access.  For those graphemes
that have a precomposed form, use of that codepoint is suggested.
(Note that this means Latin-1 can still be represented internally
with 8-bit integers.)

实现说明：既然 Perl 6 要求缺省 Unicode 处理层必须把字形视为基本单元而不是码
点，这包含了一些关于高效实现的暗示。为了快速 substr 处理，建议所有字形被输入的
时候，应该被转换成唯一字形号码，并表示为里面有某种统一的数组的整型。对于这些有
预先组成形式的字形，推荐使用码的。（注意，这意味着 Latin-1 还可以使用 8 位
整型进行内部描绘。）

For graphemes that have no precomposed form, a temporary private
id should be assigned that uniquely identifies the grapheme.
If such ids are assigned consistently throughout the process,
comparison of two graphemes is no more difficult than the comparison
of two integers, and comparison of base characters no more difficult
than a direct lookup into the id-to-NFD table.

对于未预先组成形式的字形，应给它赋值一个唯一标识字形的临时私有 id。如果这样
的 id 在整个过程中始终被分配，两个字形的比较不再比两个整数的困难，

Obviously, any temporary grapheme ids must be translated back to
some universal form (such as NFD) on output, and normal precomposed
graphemes may turn into either NFC or NFD forms depending on the
desired output.  Maintaining a particular grapheme/id mapping over the
life of the process may have some GC implications for long-running
processes, but most processes will likely see a limited number of
non-precomposed graphemes.

显然地，任何临时字形 id 在输出的时候必须被转换回某些通用形式（比如 NFD），标准未
预先组成的字形可能变成 NFC 或 NFD 形式的一种，这取决于想要输出的形式。对于长期
运行的进程，在其生命周期中维持特殊的 字形/id 映射可能会有一些 GC 蕴涵式，但大部
分进程可能会看到数量有限的未预先组成的字形。

If the program has a scope that wants a codepoint view rather than
a grapheme view, the string visible to that lexical scope must also
be translated to universal form, just as with output translation.
Alternately, the temporary grapheme ids may be hidden behind an
abstraction layer.  In any case, codepoint scope should never see
any temporary grapheme ids.  (The lexical codepoint declaration
should probably specify which normalization form it prefers to
view strings under.  Such a declaration could be applied to input
translation as well.)

如果程序有个需要码点视图而不是字形视图的作用域，该词法作用域可见字符串也必须转
换成通用形式，仅仅与输出转换一样。间隔地，临时字形 id 可能被隐藏在抽象层背后。
无论如何，码点作用域从不应该看见任何临时字形 id。（词法码点声明也许应该明确说明
它在哪种

=item *

A C<Buf> is a stringish view of an array of
integers, and has no Unicode or character properties without explicit
conversion to some kind of C<Str>.  (A C<buf> is the native counterpart.)
Typically it's an array of bytes serving as a buffer.  Bitwise
operations on a C<Buf> treat the entire buffer as a single large
integer.  Bitwise operations on a C<Str> generally fail unless the
C<Str> in question can provide an abstract C<Buf> interface somehow.
Coercion to C<Buf> should generally invalidate the C<Str> interface.
As a generic type C<Buf> may be instantiated as (or bound to) any
of C<buf8>, C<buf16>, or C<buf32> (or to any type that provides the
appropriate C<Buf> interface), but when used to create a buffer C<Buf>
defaults to C<buf8>.

C<Buf> 是整数数组的字符串似的视图，并没有显式转换为一些 Str 类的 Unicode 或字
符属性。（C<buf> 是原生副本。）通常它是一个作为缓冲作用的字节数组。C<Buf> 上的逐
位操作把整个缓冲看成一个简单的大整数。<Str> 上的逐位操作一般失败，除非所讨论
的 C<Str> 能以某种方式提供一个抽象 C<Buf> 接口。强迫到 C<Buf> 一般应该
使 C<Str> 接口无效。C<Buf> 作为一般类型，可以被实例化为（或绑定到）任何 C<buf8>，
C<buf16>，或 C<buf32>（或提供适当 C<Buf> 接口的任何类型），除了当用于创建一个缺省
为 C<buf8> 的缓冲 C<Buf>。

Unlike C<Str> types, C<Buf> types prefer to deal with integer string
positions, and map these directly to the underlying compact array
as indices.  That is, these are not necessarily byte positions--an
integer position just counts over the number of underlying positions,
where one position means one cell of the underlying integer type.
Builtin string operations on C<Buf> types return integers and expect
integers when dealing with positions.  As a limiting case, C<buf8> is
just an old-school byte string, and the positions are byte positions.
Note, though, that if you remap a section of C<buf32> memory to be
C<buf8>, you'll have to multiply all your positions by 4.

与 C<Str> 类型不同，C<Buf> 类型更喜欢处理整数的字符串位置，这些作为索引直接映射
到基本的紧凑型数组。就是说，这些不一定是字节位置——一个仅仅计数超过基本位置数
目的整数位置，它的一个位置表示基本整型类型的一个单元。C<Buf> 类型上的内置字符
串操作返回整数并且当处理位置的时候期待整数。作为一个特例，C<buf8> 仅仅是个老派
的字节串，位置是字节位置。但是请注意，如果你重新映射 C<buf32> 内存的一个块
为 C<buf8>，你将不得不将你所有的位置乘以 4。


=item *

The C<utf8> type is derived from C<buf8>, with the additional constraint
that it may only contain validly encoded UTF-8.  Likewise, C<utf16> is
derived from C<buf16>, and C<utf32> from C<buf32>.

C<utf8> 类型是从 C<buf8> 派生，并带有附加约束，也就是它只能包含有效编码
的 UTF-8。同样地，C<utf16> 从 C<buf16> 派生，及 C<utf32> 从 C<buf32> 派生。

Note that since these are type names, parentheses must always be
used to call them as coercers, since the listop form is not allowed
for coercions.  That is:

注意，由于这些都是类型名称，必须始终使用圆括号作为强制符来调用它们，因为列表操作
形式用于强制是不允许的。就是说：

    utf8 op $x

is always parsed as

常常被分析成

    (utf8) op $x

and never as

并从不作为

    utf8(op $x)

=item *

The C<*> character as a standalone term captures the notion of
"Whatever", which is applied lazily by whatever operator it is an
argument to.  Generally it can just be thought of as a "glob" that
gives you everything it can in that argument position.  For instance:

C<*> 字符作为捕获“Whatever”概念的独立术语。

    if $x ~~ 1..* {...}                 # if 1 <= $x <= +Inf
    my ($a,$b,$c) = "foo" xx *;         # an arbitrary long list of "foo"
    if /foo/ ff * {...}                 # a latching flipflop
    @slice = @x[*;0;*];                 # any Int
    @slice = %x{*;'foo'};               # any keys in domain of 1st dimension
    @array[*]                           # flattens, unlike @array[]
    (*, *, $x) = (1, 2, 3);             # skip first two elements
                                        # (same as lvalue "undef" in Perl 5)

C<Whatever> is an undefined prototype object derived from C<Any>.  As a
type it is abstract, and may not be instantiated as a defined object.
If for a particular MMD dispatch, nothing in the MMD system claims it,
it dispatches to as an C<Any> with an undefined value, and usually
blows up constructively.  If you say

C<Whatever> 是一个从 C<Any> 派生而来未定义原型对象。作为一个类型，它是抽象的，

    say 1 + *;

you should probably not expect it to yield a reasonable answer, unless
you think an exception is reasonable.  Since the C<Whatever> object
is effectively immutable, the optimizer is free to recognize C<*>
and optimize in the context of what operator it is being passed to.

Most of the built-in numeric operators treat an argument of C<*> as
indicating the desire to create a function of a single unknown, so:

    * - 1

produces a closure of a single argument:

产生一个单一参数的闭包：

    { $_ - 1 }

This closure is officially returned at run time, so it is I<not>
subject to the rule that bare closures execute immediately when used as
a statement.  However, in most cases the result of a multiple dispatch
can be determined at compile time, so the compiler is expected to
optimize away the run-time call.  Hence, despite the fact that the
inside of parentheses is considered a statement, if you say

    (* + 7)(3)  # 10

the generated C< { $_ + 7 } > closure is returned uncalled
by those parentheses and then invoked by the C<.(3)> postfix.  In
contrast,

    ( { $_ + 7 } )(3)

evaluates the bare block immediately with whatever C<$_> is already in
scope, and then fails because a number doesn't know how to respond
to the C<.(3)> invocation.

Likewise, the single dispatcher offically recognizes C<*.meth> at run time
and returns C<{ $_.meth }>, so it can be used where patterns are expected:

    @primes = grep *.prime, 2..*;

This also should be optimized to a closure by the compiler.  Basically,
dispatches to C<Whatever> are assumed to be subject to constant folding.

If multiple C<*> appear as terms within a single expression, the resulting
closure binds them all to the same argument, so C<* * *> returns the closure
C<{ $_ * $_ }>.

These returned closures are of type C<WhateverCode>, not C<Whatever>,
so that constructs can distinguish via multiple dispatch:

    1,2,3 ... *
    1,2,3 ... *+1

A bare C<*> which is immediately followed by a C<(...)> or C<.(...)> is parsed
as the unary identity closure:

    *(42) == 42
    (* + 1)(42) == 43

But note that this is I<not> what is happening above, or

    1,2,3 ... *

would end up meaning:

    1,2,3,3,3,3,3,3...

The C<...> operator is instead dispatching bare C<*> to a routine that
does dwimmery, and in this case decides to supply a function { * + 1 }.
There is no requirement that an operator return a closure when C<Whatever>
is used as an argument; that's just the I<typical> behavior for functions
that have no intrinsic "globbish" meaning for C<*>.

The final element of an array is subscripted as C<@a[*-1]>,
which means that when the subscripting operation discovers a C<WhateverCode>
object for a subscript, it calls it and supplies an argument indicating
the number of elements in (that dimension of) the array.  See S09.

A variant of C<*> is the C<**> term, which is of type C<HyperWhatever>.
It is generally understood to be a multidimension form of C<*> when
that makes sense.  When modified by an operator that would turn C<*>
into a function of one argument, C<**> instead turns into a function
with a slurpy argument, of type C<HyperWhateverCode>.  That is:

    * - 1    means                -> $x { $x - 1 }
    ** - 1   means   -> *@x { map -> $x { $x - 1 }, @x }

Therefore C<@array[^**]> represents C<< @array[{ map { ^* }, @_ }] >>,
that is to say, every element of the array, no matter how many dimensions.
(However, C<@array[**]> means the same thing because (as with C<...>
above), the subscript operator will interpret bare C<**> as meaning
all the subscripts, not the list of dimension sizes.  The meaning of
C<Whatever> is always controlled by its immediate context.)

Other uses for C<*> and C<**> will doubtless suggest themselves
over time.  These can be given meaning via the MMD system, if not
the compiler.  In general a C<Whatever> should be interpreted as
maximizing the degrees of freedom in a dwimmy way, not as a nihilistic
"don't care anymore--just shoot me".

=back

=head2 Native types

=head2 原生类型

Values with these types autobox to their uppercase counterparts when
you treat them as objects:

    bit         single native bit
    int         native signed integer
    uint        native unsigned integer (autoboxes to Int)
    buf         native buffer (finite seq of native ints or uints, no Unicode)
    num         native floating point
    complex     native complex number
    bool        native boolean

Since native types cannot represent Perl's concept of undefined values,
in the absence of explicit initialization, native floating-point types
default to NaN, while integer types (including C<bit>) default to 0.
The complex type defaults to NaN + NaN\i.  A buf type of known size
defaults to a sequence of 0 values.  If any native type is explicitly
initialized to C<*> (the C<Whatever> type), no initialization is attempted
and you'll get whatever was already there when the memory was allocated.

If a buf type is initialized with a Unicode string value, the string
is decomposed into Unicode codepoints, and each codepoint shoved into
an integer element.  If the size of the buf type is not specified,
it takes its length from the initializing string.  If the size
is specified, the initializing string is truncated or 0-padded as
necessary.  If a codepoint doesn't fit into a buf's integer type,
a parse error is issued if this can be detected at compile time;
otherwise a warning is issued at run time and the overflowed buffer
element is filled with an appropriate replacement character, either
C<U+FFFD> (REPLACEMENT CHARACTER) if the element's integer type is at
least 16 bits, or C<U+007f> (DELETE) if the larger value would not fit.
If any other conversion is desired, it must be specified explicitly.
In particular, no conversion to UTF-8 or UTF-16 is attempted; that
must be specified explicitly.  (As it happens, conversion to a buf
type based on 32-bit integers produces valid UTF-32 in the native
endianness.)

=head2 Undefined types

=head2 未定义类型

These can behave as values or objects of any class, except that
C<defined> always returns false.  One can create them with the
built-in C<undef> and C<fail> functions.  (See S04 for how failures
are handled.)

    Nil         Empty list viewed as an item
    Object      Uninitialized (derivatives serve as type objects)
    Whatever    Wildcard (like undef, but subject to do-what-I-mean via MMD)
    Failure     Failure (lazy exceptions, thrown if not handled properly)

Whenever you declare any kind of type, class, module, or package, you're
automatically declaring a undefined prototype value with the same name.

Whenever a C<Failure> value is put into a typed container, it takes
on the type specified by the container but continues to carry the
C<Failure> role.  (The C<undef> function merely returns the most
generic C<Failure> object.  Use C<fail> to return more specific failures.  Use
C<Object> for the most generic non-failure undefined value.  The C<Any>
type is also undefined, but excludes C<junctions> so that autothreading
may be dispatched using normal multiple dispatch rules.)

The C<Nil> type is officially undefined as an item but interpolates
as a null list into list context, and an empty capture into slice
context.  A C<Nil> object may also carry failure information,
but if so, the object behaves as a failure only in item context.
Use C<Failure> when you want to return a hard failure that
will not evaporate in list context.  Casting to C<Nil> is one
way of evaluating an expression and throwing the result away:

    @inclist = map { $_ + 1 }, @list || Nil( warn 'Empty @list!' );

    @inclist = do for @list || Nil( warn 'Empty @list!' ) {
        $_ + 1;
    }

Or if you want to test whether you got any results back from
the C<map> or C<for>:

    @inclist = do map { $_ + 1 }, @list or Nil( warn 'Empty @list!' );

    @inclist = do for @list {
        $_ + 1;
    } or Nil( warn 'Empty @list!' )

Since the construct is in the form of a type cast, the parens are required.
If that syntax is unappealing or you wish to run multiple statements
in a block, it happens that the C<void> statement prefix also converts
any value to C<Nil>, so the examples above can be expressed
without parentheses:

    @inclist = map { $_ + 1 }, @list || void warn 'Empty @list!';

    @inclist = do for @list || void { warn 'Empty @list!'; $warnings++; } {
        $_ + 1;
    }

    @inclist = do map { $_ + 1 }, @list or void warn 'Empty @list!';

    @inclist = do for @list {
        $_ + 1;
    } or void { warn 'Empty @list!'; $warnings++; }

=head2 Immutable types

=head2 不可变类型

Objects with these types behave like values, i.e. C<$x === $y> is true
if and only if their types and contents are identical (that is, if
C<$x.WHICH> eqv C<$y.WHICH>).

    Bit         Perl single bit (allows traits, aliasing, undef, etc.)
    Int         Perl integer (allows Inf/NaN, arbitrary precision, etc.)
    Str         Perl string (finite sequence of Unicode characters)
    Num         Perl number
    Rat         Perl rational
    Complex     Perl complex number
    Bool        Perl boolean
    Exception   Perl exception
    Block       Executable objects that have lexical scopes
    List        Lazy Perl list (composed of immutables and iterators)
    Seq         Completely evaluated (hence immutable) sequence
    Range       A pair of Ordered endpoints
    Set         Unordered collection of values that allows no duplicates
    Bag         Unordered collection of values that allows duplicates
    Signature   Function parameters (left-hand side of a binding)
    Capture     Function call arguments (right-hand side of a binding)
    Blob        An undifferentiated mass of bits
    Instant     A point on the continuous atomic timeline (TAI)
    Duration    The difference between two Instants

Insofar as Lists are lazy, they're really only partially immutable, in
the sense that the past is fixed but the future is not.  The portion of
a List yet to be determined by iterators may depend on mutable values.
When an iterator is called upon to iterate and extend the known part
of the list, some number of immutable values (which includes immutable
references to mutable objects) are decided and locked in at that point.
Iterators may have several different ways of iterating depending on
the degree of laziness/eagerness desired in context.  The iterator
API is described in S07.

C<Instant>s and C<Duration>s are measured in atomic seconds with
fractions.  Notionally they are real numbers which may be implemented
in either C<Num> or C<Rat> types.  (Fixed-point implementations are
strongly discouraged.)  Interfaces that take C<Duration> arguments,
such as sleep(), may also take C<Num> arguments, but C<Instant>
arguments must be explicitly created via any of various culturally
aware time specification APIs that, by and large, are outside the
C<CORE> of Perl 6, with the possible exception of a constructor taking a
native TAI value.  In numeric context a C<Duration> happily returns a
C<Num> representing seconds.  If pressed for a number, an C<Instant>
will return the length of time in atomic seconds from the TAI epoch,
but it will be unhappy about it.  Systems which cannot provide
a steady time base, such as POSIX systems, will simply have to make
their best guess as to the correct atomic time.

=head2 Mutable types

=head2 可变类型

Objects with these types have distinct C<.WHICH> values that do not change
even if the object's contents change.  (Routines are considered mutable
because they can be wrapped in place.)

    Scalar      Perl scalar
    Array       Perl array
    Hash        Perl hash
    KeyHash     Perl hash that autodeletes values matching default
    KeySet      KeyHash of Bool (does Set in list/array context)
    KeyBag      KeyHash of UInt (does Bag in list/array context)
    Pair        A single key-to-value association
    Mapping     Set of Pairs with no duplicate keys
    Buf         Perl buffer (a stringish array of memory locations)
    IO          Perl filehandle
    Routine     Base class for all wrappable executable objects
    Sub         Perl subroutine
    Method      Perl method
    Submethod   Perl subroutine acting like a method
    Macro       Perl compile-time subroutine
    Regex       Perl pattern
    Match       Perl match, usually produced by applying a pattern
    Package     Perl 5 compatible namespace
    Module      Perl 6 standard namespace
    Class       Perl 6 standard class namespace
    Role        Perl 6 standard generic interface/implementation
    Grammar     Perl 6 pattern matching namespace
    Any         Perl 6 object (default routine parameter type, excludes junction)
    Object      Perl 6 object (default block parameter type, either Any or junction)

A C<KeyHash> differs from a normal C<Hash> in how it handles default
values.  If the value of a C<KeyHash> element is set to the default
value for the C<KeyHash>, the element is deleted.  If undeclared,
the default default for a C<KeyHash> is 0 for numeric types, C<False>
for boolean types, and the null string for string and buffer types.
A C<KeyHash> of a C<Object> type defaults to the undefined prototype
for that type.  More generally, the default default is whatever defined
value an C<undef> would convert to for that value type.  A C<KeyHash>
of C<Scalar> deletes elements that go to either 0 or the null string.
A C<KeyHash> also autodeletes keys for normal undef values (that is,
those undefined values that do not contain an unthrown exception).

C<KeyHash> 在如何操纵默认值方面不同于正常的 C<Hash>。如果 C<KeyHash> 元素的值
为 C<KeyHash> 设为默认值，这个元素会被删除。如果未声明，C<KeyHash> 的默认值是对
于整数类型是 0，对于布尔类型是 C<False>，对于 string 和 buffer 类型是空字符串。

A C<KeySet> is a C<KeyHash> of booleans with a default of C<False>.
If you use the C<Hash> interface and increment an element of a
C<KeySet> its value becomes true (creating the element if it doesn't
exist already).  If you decrement the element it becomes false and
is automatically deleted.  Decrementing a non-existing value results
in a C<False> value.  Incrementing an existing value results in C<True>.
When not used as a C<Hash> (that is,
when used as an C<Array> or list or C<Set> object) a C<KeySet>
behaves as a C<Set> of its keys.  (Since the only possible value of
a C<KeySet> is the C<True> value, it need not be represented in
the actual implementation with any bits at all.)

A C<KeyBag> is a C<KeyHash> of C<UInt> with default of 0.  If you
use the C<Hash> interface and increment an element of a C<KeyBag>
its value is increased by one (creating the element if it doesn't exist
already).  If you decrement the element the value is decreased by one;
if the value goes to 0 the element is automatically deleted.  An attempt
to decrement a non-existing value results in a C<Failure> value.  When not
used as a C<Hash> (that is, when used as an C<Array> or list or C<Bag>
object) a C<KeyBag> behaves as a C<Bag> of its keys, with each key
replicated the number of times specified by its corresponding value.
(Use C<.kv> or C<.pairs> to suppress this behavior in list context.)

As with C<Hash> types, C<Pair> and C<Mapping> are mutable in their
values but not in their keys.  (A key can be a reference to a mutable
object, but cannot change its C<.WHICH> identity.  In contrast,
the value may be rebound to a different object, just as a hash
element may.)

=head2 Value types

=head2 值类型

Explicit types are optional. Perl variables have two associated types:
their "value type" and their "implementation type".  (More generally, any
container has an implementation type, including subroutines and modules.)
The value type is stored as its C<of> property, while the implementation
type of the container is just the object type of the container itself.
The word C<returns> is allowed as an alias for C<of>.

The value type specifies what kinds of values may be stored in the
variable. A value type is given as a prefix or with the C<of> keyword:

    my Dog $spot;
    my $spot of Dog;

In either case this sets the C<of> property of the container to C<Dog>.

Subroutines have a variant of the C<of> property, C<as>, that sets
the C<as> property instead.  The C<as> property specifies a
constraint (or perhaps coercion) to be enforced on the return value (either
by explicit call to C<return> or by implicit fall-off-the-end return).
This constraint, unlike the C<of> property, is not advertised as the
type of the routine.  You can think of it as the implicit type signature of
the (possibly implicit) return statement.  It's therefore available for
type inferencing within the routine but not outside it.  If no C<as> type
is declared, it is assumed to be the same as the C<of> type, if declared.

    sub get_pet() of Animal {...}       # of type, obviously
    sub get_pet() returns Animal {...}  # of type
    our Animal sub get_pet() {...}      # of type
    sub get_pet() as Animal {...}       # as type

A value type on an array or hash specifies the type stored by each element:

    my Dog @pound;  # each element of the array stores a Dog

    my Rat %ship;   # the value of each entry stores a Rat

The key type of a hash may be specified as a shape trait--see S09.

=head2 Implementation types

The implementation type specifies how the variable itself is implemented. It is
given as a trait of the variable:

    my $spot is Scalar;             # this is the default
    my $spot is PersistentScalar;
    my $spot is DataBase;

Defining an implementation type is the Perl 6 equivalent to tying
a variable in Perl 5.  But Perl 6 variables are tied directly at
declaration time, and for performance reasons may not be tied with a
run-time C<tie> statement unless the variable is explicitly declared
with an implementation type that does the C<Tieable> role.

However, package variables are always considered C<Tieable> by default.
As a consequence, all named packages are also C<Tieable> by default.
Classes and modules may be viewed as differently tied packages.
Looking at it from the other direction, classes and modules that
wish to be bound to a global package name must be able to do the
C<Package> role.

=head2 Hierarchical types

=head2 层次类型

A non-scalar type may be qualified, in order to specify what type of
value each of its elements stores:

    my Egg $cup;                       # the value is an Egg
    my Egg @carton;                    # each elem is an Egg
    my Array of Egg @box;              # each elem is an array of Eggs
    my Array of Array of Egg @crate;   # each elem is an array of arrays of Eggs
    my Hash of Array of Recipe %book;  # each value is a hash of arrays of Recipes

Each successive C<of> makes the type on its right a parameter of the
type on its left. Parametric types are named using square brackets, so:

    my Hash of Array of Recipe %book;

actually means:

实际上意思是：

    my Hash:of(Array:of(Recipe)) %book;

Because the actual variable can be hard to find when complex types are
specified, there is a postfix form as well:

    my Hash of Array of Recipe %book;           # HoHoAoRecipe
    my %book of Hash of Array of Recipe;        # same thing

The C<as> form may be used in subroutines:

    my sub get_book ($key) as Hash of Array of Recipe {...}

Alternately, the return type may be specified within the signature:

    my sub get_book ($key --> Hash of Array of Recipe) {...}

There is a slight difference, insofar as the type inferencer will
ignore a C<as> but pay attention to C<< --> >> or prefix type
declarations, also known as the C<of> type.  Only the inside of the
subroutine pays attention to C<as>, and essentially coerces the return
value to the indicated type, just as if you'd coerced each return expression.

You may also specify the C<of> type as the C<of> trait (with C<returns>
allowed as a synonym):

    my Hash of Array of Recipe sub get_book ($key) {...}
    my sub get_book ($key) of Hash of Array of Recipe {...}
    my sub get_book ($key) returns Hash of Array of Recipe {...}

=head2 Polymorphic types

Anywhere you can use a single type you can use a set of types, for convenience
specifiable as if it were an "or" junction:

    my Int|Str $error = $val;              # can assign if $val~~Int or $val~~Str

Fancier type constraints may be expressed through a subtype:

    subset Shinola of Any where {.does(DessertWax) and .does(FloorTopping)};
    if $shimmer ~~ Shinola {...}  # $shimmer must do both interfaces

Since the terms in a parameter could be viewed as a set of
constraints that are implicitly "anded" together (the variable itself
supplies type constraints, and C<where> clauses or tree matching just
add more constraints), we relax this to allow juxtaposition of
types to act like an "and" junction:

    # Anything assigned to the variable $mitsy must conform
    # to the type Fish and either the Squirrel or Dog type...
    my Squirrel|Dog Fish $mitsy = new Fish but { Bool.pick ?? .does Squirrel
                                                           !! .does Dog };

[Note: the above is a slight lie, insofar as parameters are currently
restricted for 6.0.0 to having only a single main type for the
formal variable until we understand MMD a bit better.]

=head2 Parameter types

=head2 参数类型

Parameters may be given types, just like any other variable:

    sub max (int @array is rw) {...}
    sub max (@array of int is rw) {...}

=head2 Generic types

Within a declaration, a class variable (either by itself or
following an existing type name) declares a new type name and takes
its parametric value from the actual type of the parameter it is
associated with.  It declares the new type name in the same scope
as the associated declaration.

    sub max (Num ::X @array) {
        push @array, X.new();
    }

The new type name is introduced immediately, so two such types in
the same signature must unify compatibly if they have the same name:

    sub compare (Any ::T $x, T $y) {
        return $x eqv $y;
    }

=head2 Return types

=head2 返回类型

On a scoped subroutine, a return type can be specified before or after
the name.  We call all return types "return types", but distinguish
two kinds of return types, the C<as> type and the C<of> type,
because the C<of> type is normally an "official" named type and
declares the official interface to the routine, while the C<as>
type is merely a constraint on what may be returned by the routine
from the routine's point of view.

    our sub lay as Egg {...}            # as type
    our Egg sub lay {...}               # of type
    our sub lay of Egg {...}            # of type
    our sub lay (--> Egg) {...}         # of type

    my sub hat as Rabbit {...}          # as type
    my Rabbit sub hat {...}             # of type
    my sub hat of Rabbit {...}          # of type
    my sub hat (--> Rabbit) {...}       # of type

If a subroutine is not explicitly scoped, it belongs to the current
namespace (module, class, grammar, or package), as if it's scoped with
the C<our> scope modifier. Any return type must go after the name:

    sub lay as Egg {...}                # as type
    sub lay of Egg {...}                # of type
    sub lay (--> Egg) {...}             # of type

On an anonymous subroutine, any return type can only go after the C<sub>
keyword:

    $lay = sub as Egg {...};            # as type
    $lay = sub of Egg {...};            # of type
    $lay = sub (--> Egg) {...};         # of type

but you can use a scope modifier to introduce an C<of> prefix type:

    $lay = my Egg sub {...};            # of type
    $hat = my Rabbit sub {...};         # of type

Because they are anonymous, you can change the C<my> modifier to C<our>
without affecting the meaning.

The return type may also be specified after a C<< --> >> token within
the signature.  This doesn't mean exactly the same thing as C<as>.
The C<of> type is the "official" return type, and may therefore be
used to do type inferencing outside the sub.  The C<as> type only
makes the return type available to the internals of the sub so that
the C<return> statement can know its context, but outside the sub we
don't know anything about the return value, as if no return type had
been declared.  The prefix form specifies the C<of> type rather than
the C<as> type, so the return type of

    my Fish sub wanda ($x) { ... }

is known to return an object of type Fish, as if you'd said:

    my sub wanda ($x --> Fish) { ... }

I<not> as if you'd said

    my sub wanda ($x) as Fish { ... }

It is possible for the C<of> type to disagree with the C<as> type:

    my Squid sub wanda ($x) as Fish { ... }

or equivalently,

    my sub wanda ($x --> Squid) as Fish { ... }

This is not lying to yourself--it's lying to the world.  Having a
different inner type is useful if you wish to hold your routine to
a stricter standard than you let on to the outside world, for instance.

=head1 Names and Variables

=head1 名称和变量

=over 4

=item *

The C<$Package'var> syntax is gone.  Use C<$Package::var> instead.

=item *

Perl 6 includes a system of B<sigils> to mark the fundamental
structural type of a variable:

    $   scalar (object)
    @   ordered array
    %   unordered hash (associative array)
    &   code/rule/token/regex
    ::  package/module/class/role/subset/enum/type/grammar
    @@  slice view of @

Within a declaration, the C<&> sigil also declares the visibility of the
subroutine name without the sigil within the scope of the declaration:

    my &func := sub { say "Hi" };
    func;   # calls &func

Within a signature or other declaration, the C<::> sigil followed by an
identifier marks a type variable that also declares the visibility
of a package/type name without the sigil within the scope of the
declaration.  The first such declaration within a scope is assumed
to be an unbound type, and takes the actual type of its associated
argument.  With subsequent declarations in the same scope the use of
the sigil is optional, since the bare type name is also declared.

A declaration nested within must not use the sigil if it wishes to
refer to the same type, since the inner declaration would rebind
the type.  (Note that the signature of a pointy block counts as part
of the inner block, not the outer block.)

=item *

Sigils indicate overall interface, not the exact type of the bound
object.  Different sigils imply different minimal abilities.

C<$x> may be bound to any object, including any object that can be
bound to any other sigil.  Such a scalar variable is always treated as
a singular item in any kind of list context, regardless of whether the
object is essentially composite or unitary.  It will not automatically
dereference to its contents unless placed explicitly in some kind of
dereferencing context.  In particular, when interpolating into list
context, C<$x> never expands its object to anything other than the
object itself as a single item, even if the object is a container
object containing multiple items.

C<@x> may be bound to an object of the C<Array> class, but it may also
be bound to any object that does the C<Positional> role, such as a
C<List>, C<Seq>, C<Range>, C<Buf>, C<Parcel>, or C<Capture>.  The C<Positional>
role implies the ability to support C<< postcircumfix:<[ ]> >>.

Likewise, C<%x> may be bound to any object that does the C<Associative>
role, such as C<Pair>, C<Mapping>, C<Set>, C<Bag>, C<KeyHash>, or
C<Capture>.  The C<Associative> role implies the ability to support
C<< postcircumfix:<{ }> >>.

C<&x> may be bound to any object that does the C<Callable> role, such
as any C<Block> or C<Routine>.  The C<Callable> role implies the ability
to support C<< postcircumfix:<( )> >>.

C<::x> may be bound to any object that does the C<Abstraction> role,
such as a package, module, class, role, grammar, or any other
type object, or any immutable value object that can be used as a type.
This C<Abstraction> role implies the
ability to do various symbol table and/or typological manipulations which
may or may not be supported by any given abstraction.  Mostly though it
just means that you want to give some abstraction an official name that
you can then use later in the compilation without any sigil.

In any case, the minimal container role implied by the sigil is
checked at binding time at the latest, and may fail earlier (such
as at compile time) if a semantic error can be detected sooner.
If you wish to bind an object that doesn't yet do the appropriate
role, you must either stick with the generic C<$> sigil, or mix in
the appropriate role before binding to a more specific sigil.

An object is allowed to support both C<Positional> and C<Associative>.
An object that does not support C<Positional> may not be bound directly
to C<@x>.  However, any construct such as C<%x> that can interpolate
the contents of such an object into list context can automatically
construct a list value that may then be bound to an array variable.
Subscripting such a list does not imply subscripting back into the
original object.

=item *

Unlike in Perl 5, you may no longer put whitespace between a sigil
and its following name or construct.

与 Perl 5 不同，

=item *

Ordinary sigils indicate normally scoped variables, either lexical
or package scoped.  Oddly scoped variables include a secondary sigil
(a B<twigil>) that indicates what kind of strange scoping the variable
is subject to:

    $foo        ordinary scoping
    $.foo       object attribute public accessor
    $^foo       self-declared formal positional parameter
    $:foo       self-declared formal named parameter
    $*foo       contextualizable global variable
    $?foo       compiler hint variable
    $=foo       Pod variable
    $<foo>      match variable, short for $/{'foo'}
    $!foo       object attribute private storage
    $~foo       the foo sublanguage seen by the parser at this lexical spot

Most variables with twigils are implicitly declared or assumed to
be declared in some other scope, and don't need a "my" or "our".
Attribute variables are declared with C<has>, though.

=item *

Sigils are now invariant.  C<$> always means a scalar variable, C<@>
an array variable, and C<%> a hash variable, even when subscripting.
In item context, variables such as C<@array> and C<%hash> simply
return themselves as C<Array> and C<Hash> objects. (Item context was
formerly known as scalar context, but we now reserve the "scalar"
notion for talking about variables rather than contexts, much as
arrays are disassociated from list context.)

=item *

In string contexts, container objects automatically stringify to
appropriate (white-space separated) string values.  In numeric
contexts, the number of elements in the container is returned.
In boolean contexts, a true value is returned if and only if there
are any elements in the container.

=item *

To get a Perlish representation of any object, use the C<.perl> method.
Like the C<Data::Dumper> module in Perl 5, the C<.perl> method will put
quotes around strings, square brackets around list values, curlies around
hash values, constructors around objects, etc., so that Perl can evaluate
the result back to the same object.  The C<.perl> method will return
a representation of the object on the assumption that, if the code is
reparsed at some point, it will be used to regenerate the object as a
scalar in item context.  If you wish to interpolate the regenerated
object in a list context, it may be necessary to use C<<prefix:<|> >>
to force interpolation.

=item *

To get a formatted representation of any scalar value, use the
C<.fmt('%03d')> method to do an implicit C<sprintf> on the value.

To format an array value separated by commas, supply a second argument:
C<.fmt('%03d', ', ')>.  To format a hash value or list of pairs, include
formats for both key and value in the first string: C<< .fmt('%s: %s', "\n") >>.

=item *

Subscripts now consistently dereference the container produced by
whatever was to their left.  Whitespace is not allowed between a
variable name and its subscript.  However, there are two ways to
stretch the construct out visually.  Since a subscript is a kind
of postfix operator, there is a corresponding B<dot> form of each
subscript (C<@foo.[1]> and C<%bar.{'a'}>) that makes the dereference
a little more explicit. Constant string subscripts may be placed
in angles, so C<%bar.{'a'}> may also be written as C<< %bar<a> >>
or C<< %bar.<a> >>.  Additionally, you may insert extra whitespace
using the unspace.

现在下标符号始终解引用它们左边的任何容器。空白不允许出现在变量名和它的下标符
号之间。

=item *

Slicing is specified by the nature of the subscript, not by
the sigil.

=item *

The context in which a subscript is evaluated is no longer controlled
by the sigil either.  Subscripts are always evaluated in list context.
(More specifically, they are evaluated in a variant of list context
known as I<slice> context, which preserves dimensional information
so that you can do multi-dimensional slices using semicolons.  However,
each slice dimension evaluates its sublist in normal list context,
so functions called as part of a subscript don't see a slice context.
See S09 for more on slice context.)

If you need to force inner context to item (scalar), we now have convenient
single-character context specifiers such as + for numbers and ~ for strings:

    $x        =  g();       # item context for g()
    @x[f()]   =  g();       # list context for f() and g()
    @x[f()]   = +g();       # list context for f(), numeric item context for g()
    @x[+f()]  =  g();       # numeric item context for f(), list context for g()

    @x[f()]   =  @y[g()];   # list context for f() and g()
    @x[f()]   = +@y[g()];   # list context for f() and g()
    @x[+f()]  =  @y[g()];   # numeric item context for f(), list context for g()
    @x[f()]   =  @y[+g()];  # list context for f(), numeric item context for g()

    %x{~f()}  =  %y{g()};   # string item context for f(), list context for g()
    %x{f()}   =  %y{~g()};  # list context for f(), string item context for g()

Sigils used either as functions or as list prefix operators also
force context, so these also work:

    @x[$(g())]         # item context for g()
    @x[$ g()]          # item context for g()
    %x{$(g())}         # item context for g()
    %x{$ g()}          # item context for g()

But note that these don't do the same thing:

但注意这些不是做同样的事情：

    @x[$g()]           # call function in $g
    %x{$g()}           # call function in $g

=item *

There is a need to distinguish list assignment from list binding.
List assignment works much like it does in Perl 5, copying the
values.  There's a new C<:=> binding operator that lets you bind
names to C<Array> and C<Hash> objects without copying, in the same way
as subroutine arguments are bound to formal parameters.  See S06
for more about binding.

=item *

A list of one or more objects may be grouped together by parentheses
into a "parenthesis cell", or C<Parcel>.  This kind of list should
not be confused with the flattening list context.  Instead, this is
a raw syntactic list; no interpretation is made of the list without
knowing what context it will be evaluated in.  For example, when
you say:

    (1,2,3,:mice<blind>)

the result is a C<Parcel> object containing three C<Int> objects
and a C<Pair> object, that is, four positional objects.  When, however,
you say something like:

    rhyme(1,2,3,:mice<blind>)

the C<Parcel> is translated (at compile time, in this case)
into a C<Capture> with 3 positionals and one named argument
in preparation for binding.

=item *

An argument list may be captured into an object with backslashed parens:

    $args = \(1,2,3,:mice<blind>)

Values in a C<Capture> object are parsed as ordinary expressions, then marked as
positional or named.  If the first positional is followed by a colon instead of
a comma, it is marked as the invocant in case it finds itself in a context
that cares.

Like C<List> objects, C<Capture> objects are immutable in the abstract, but
evaluate their arguments lazily.  Before everything inside a C<Capture> is
fully evaluated (which happens at compile time when all the arguments are
constants), the eventual value may well be unknown.  All we know is
that we have the promise to make the bits of it immutable as they become known.

C<Capture> objects may contain multiple unresolved iterators such as feeds
or slices.  How these are resolved depends on what they are eventually
bound to.  Some bindings are sensitive to multiple dimensions while
others are not.

You may retrieve parts from a C<Capture> object with a prefix sigil operator:

    $args = \3;     # same as "$args = \(3)"
    @$args;         # same as "Array($args)"
    %$args;         # same as "Hash($args)"

When cast into an array, you can access all the positional arguments; into a
hash, all named arguments.

All prefix sigil operators accept one positional argument, evaluated in
item context as a rvalue.  They can interpolate in strings if called with
parentheses.  The special syntax form C<$()> translates into C<$( $.ast // Str($/) )>
to operate on the current match object; similarly C<@()> and C<%()> can
extract positional and named submatches.

C<Capture> objects fill the ecological niche of references in Perl 6.
You can think of them as "fat" references, that is, references that
can capture not only the current identity of a single object, but
also the relative identities of several related objects.  Conversely,
you can think of Perl 5 references as a degenerate form of C<Capture>
when you want to refer only to a single item.

=item *

A signature object (C<Signature>) may be created with colon-prefixed parens:

    my ::MySig ::= :(Int, Num, Complex, Status)

Expressions inside the signature are parsed as parameter declarations
rather than ordinary expressions.  See S06 for more details on the syntax
for parameters.

Signature objects bound to type variables (as in the example above) may
be used within other signatures to apply additional type constraints.
When applied to a C<Capture> argument, the signature allows you to
take the types of the capture's arguments from C<MySig>, but declare
the (untyped) variable names yourself via an additional signature
in parentheses:

    sub foo (Num Dog|Squirrel $numdog, MySig $a ($i,$j,$k,$mousestatus)) {...}
    foo($mynumdog, \(1, 2.7182818, 1.0i, statmouse());

=item *

Unlike in Perl 5, the notation C<&foo> merely stands for the C<foo>
function as a C<Routine> object without calling it.  You may call any Code
object by dereferencing it with parens (which may, of course, contain arguments):

与 Perl 5 不同，

    &foo($arg1, $arg2);

Whitespace is not allowed before the parens because it is parsed as
a postfix.  As with any postfix, there is also a corresponding C<.()>
operator, and you may use the "unspace" form to insert optional
whitespace and comments between the backslash and either of the
postfix forms:

    &foo\   ($arg1, $arg2);
    &foo\   .($arg1, $arg2);
    &foo\#`[
        embedded comment
    ].($arg1, $arg2);

Note however that the parentheses around arguments in the "normal"
named forms of function and method calls are not postfix operators, so do
not allow the C<.()> form, because the dot is indicative of an actual
dereferencing operation, which the named forms aren't doing.  You
may, however, use "unspace" to install extra space before the parens
in the forms:

    foo()       # okay
    foo\ ()     # okay
    foo.()      # means foo().()

    .foo()      # okay
    .foo\ ()    # okay
    .foo.()     # means .foo().()

    $.foo()     # okay
    $.foo\ ()   # okay
    $.foo.()    # means $.foo().()

If you I<do> use the dotty form on these special forms, it will
assume you wanted to call the named form without arguments, and
then dereference the result of that.

=item *

With multiple dispatch, C<&foo> may actually be the name of a set
of candidate functions (which you can use as if it were an ordinary function).
However, in that case C<&foo> by itself is not sufficient to uniquely
name a specific function.  To do that, the type may be refined by
using a signature literal as a postfix operator:

    &foo:(Int,Num)

It still just returns the C<Routine> object.  A call may also be partially
applied by using the C<.assuming> method:

    &foo.assuming(1,2,3,:mice<blind>)


=item *

Slicing syntax is covered in S09.  A multidimensional
slice will be done with semicolons between individual slice sublists.
Each such slice sublist is evaluated lazily.

=item *

To make a slice subscript return something other than values, append an
appropriate adverb to the subscript.

    @array = <A B>;
    @array[0,1,2];      # returns 'A', 'B', undef
    @array[0,1,2] :p;   # returns 0 => 'A', 1 => 'B'
    @array[0,1,2] :kv;  # returns 0, 'A', 1, 'B'
    @array[0,1,2] :k;   # returns 0, 1
    @array[0,1,2] :v;   # returns 'A', 'B'

    %hash = (:a<A>, :b<B>);
    %hash<a b c>;       # returns 'A', 'B', undef
    %hash<a b c> :p;    # returns a => 'A', b => 'B'
    %hash<a b c> :kv;   # returns 'a', 'A', 'b', 'B'
    %hash<a b c> :k;    # returns 'a', 'b'
    %hash<a b c> :v;    # returns 'A', 'B'

These adverbial forms all weed out non-existing entries.  You may also
perform an existence test, which will return true if all the elements
of the slice exist:

    if %hash<a b c> :exists {...}

likewise,

同样地，

    my ($a,$b,$c) = %hash<a b c> :delete;

deletes the entries "en passant" while returning them.  (Of course,
any of these forms also work in the degenerate case of a slice
containing a single index.)  Note that these forms work by virtue
of the fact that the subscript is the topmost previous operator.
You may have to parenthesize or force list context if some other
operator that is tighter than comma would appear to be topmost:

    1 + (%hash{$x} :delete);
    $x = (%hash{$x} :delete);
    ($x) = %hash{$x} :delete;

(The situation does not often arise for the slice modifiers above
because they are usually used in list context, which operates
at comma precedence.)

=item *

In numeric context (i.e. when cast into C<Int> or C<Num>), a C<Hash> object
becomes the number of pairs contained in the hash.  In a boolean context, a
Hash object is true if there are any pairs in the hash.  In either case,
any intrinsic iterator would be reset.  (If hashes do carry an intrinsic
iterator (as they do in Perl 5), there will be a C<.reset> method on the
hash object to reset the iterator explicitly.)

=item *

Sorting a list of pairs should sort on their keys by default, then
on their values.  Sorting a list of lists should sort on the first
elements, then the second elements, etc.  For more on C<sort> see S29.

=item *

Many of the special variables of Perl 5 are going away.  Those that
apply to some object such as a filehandle will instead be attributes
of the appropriate object.  Those that are truly global will have
global alphabetic names, such as C<$*PID> or C<@*ARGS>.

=item *

Any remaining special variables will be lexically scoped.
This includes C<$_> and C<@_>, as well as the new C<$/>, which
is the return value of the last regex match.  C<$0>, C<$1>, C<$2>, etc.,
are aliases into the C<$/> object.

=item *

The C<$#foo> notation is dead.  Use C<@foo.end> or C<@foo[*-1]> instead.
(Or C<@foo.shape[$dimension]> for multidimensional arrays.)

C<$#foo> 标志废弃了。使用 C<@foo.end> 或者 C<@foo[*-1]> 代替。（或
者对于多维数组使用 C<@foo.shape[$dimension]> 。）

=back

=head1 Names

=head1 名称

=over 4

=item *

An I<identifier> is composed of an alphabetic character followed by
any sequence of alphanumeric characters.  The definitions of alphabetic
and numeric include appropriate Unicode characters.  Underscore is
always considered alphabetic.  An identifier may also contain isolated
apostrophes or hyphens provided the next character is alphabetic.

A I<name> is anything that is a legal part of a variable name (not counting
the sigil).  This includes

    $foo                # simple identifiers
    $Foo::Bar::baz      # compound identifiers separated by ::
    $Foo::($bar)::baz   # compound identifiers that perform interpolations
    $42                 # numeric names
    $!                  # certain punctuational variables

When not used as a sigil, the semantic function of C<::> within a
name is to force the preceding portion of the name to be considered
a package through which the subsequent portion of the name is to
be located.  If the preceding portion is null, it means the package
is unspecified and must be searched for according to the nature of
what follows.  Generally this means that an initial C<::> following the
main sigil is a no-op on names that are known at compile time, though
C<::()> can also be used to introduce an interpolation (see below).
Also, in the absence of another sigil, C<::> can serve as its own
sigil indicating intentional use of a not-yet-declared package name.

Unlike in Perl 5, if a sigil is followed by comma, semicolon, a colon
not followed by an identifier,
or any kind of bracket or whitespace (including Unicode brackets and
whitespace), it will be taken to be a sigil without a name rather
than a punctuational variable.  This allows you to use sigils as coercion
operators:

    print $( foo() )    # foo called in item context
    print @@( foo() )   # foo called in slice context

In declarative contexts bare sigils may be used as placeholders for
anonymous variables:

    my ($a, $, $c) = 1..3;
    print unless (state $)++;

Outside of declarative contexts you may use C<*> for a placeholder:

    ($a, *, $c) = 1..3;

Attempts to say something like:

尝试描述类似这样的事情：

    ($a, $, $c) = 1..3;

will result in the message, "Anonymous variable requires declarator".

将返回一个信息，“匿名变量需要定义符”。


=item *

Ordinary package-qualified names look like in Perl 5:

    $Foo::Bar::baz      # the $baz variable in package Foo::Bar

Sometimes it's clearer to keep the sigil with the variable name, so an
alternate way to write this is:

    Foo::Bar::<$baz>

This is resolved at compile time because the variable name is a constant.

=item *

The following pseudo-package names are reserved at the front of a name:

    MY          # Symbols in the current lexical scope (aka $?SCOPE)
    OUR         # Symbols in the current package (aka $?PACKAGE)
    CORE        # Outermost lexical scope, definition of standard Perl
    GLOBAL      # Interpreter-wide package symbols, really CORE::GLOBAL
    PROCESS     # Process-related globals (superglobals), CORE::PROCESS
    COMPILING   # Lexical symbols in the scope being compiled
    CALLER      # Contextual symbols in the immediate caller's lexical scope
    CONTEXT     # Contextual symbols in my or any caller's lexical scope

The following relative names are also reserved but may be used
anywhere in a name:

    OUTER       # Symbols in the next outer lexical scope
    UNIT        # Symbols in the outermost lexical scope of compilation unit
    SETTING     # Lexical symbols in the unit's DSL (usually CORE)
    PARENT      # Symbols in this package's parent package (or lexical scope)

The following is reserved at the beginning of method names in method calls:

    SUPER       # Package symbols declared in inherited classes

Other all-caps names are semi-reserved.  We may add more of them in
the future, so you can protect yourself from future collisions by using
mixed case on your top-level packages.  (We promise not to break
any existing top-level CPAN package, of course.  Except maybe C<ACME>,
and then only for coyotes.)

The file's scope is known as C<UNIT>, but there are one or more
lexical scopes outside of that corresponding to the linguistic setting
(often known as the prelude in other cultures).  Hence, the C<SETTING>
scope is equivalent to C<UNIT::OUTER>.  For a standard Perl program
C<SETTING> is the same as C<CORE>, but various startup options (such
as C<-n> or C<-p>) can put you into a domain specific language,
in which case C<CORE> remains the scope of the standard language,
while C<SETTING> represents the scope defining the DSL that functions
as the setting of the current file.  See also the C<-L>/C<--language>
switch described in L<S19-commandline>.  If a setting wishes
to gain control of the main execution, it merely needs to declare
a C<MAIN> routine as documented in S06.  In this case the ordinary
execution of the user's code is suppressed; instead, execution
of the user's code is entirely delegated to the setting's C<MAIN> routine,
which calls back to the user's lexically embedded code with C<YOU_ARE_HERE>.

Note that, since the C<UNIT> of an eval is the eval string itself,
the C<SETTING> of an eval is the language in effect at the point
of the eval, not the language in effect at the top of the file.
(You may, however, use C<OUTER::SETTING> to get the setting of the
code that is executing the eval.)  In more traditional terms, the
normal program is functioning as the "prelude" of the eval.

So the outermost lexical scopes nest like this, traversed via C<OUTER>:

    CORE <= SETTING < UNIT < (your_block_here)

The outermost packages scopes nest like this, traversed via C<PARENT>:

    GLOBAL <  (your_package_here)

You main program starts up in the C<GLOBAL> package and the C<UNIT>
lexical scope.  Whenever anything is declared with "our" semantics, it
inserts a name into both the current package and the current lexical
scope.  (And "my" semantics only insert into the current lexical
scope.)  Note that the standard setting, C<CORE>, is a lexical scope,
not a package; the various items that are defined within (or imported
into) C<CORE> are *not* in C<GLOBAL>, which is pretty much empty when
your program starts compiling, and mostly only contains things you
either put there yourself, or some other module put there because
you used that module.  In general things defined within (or imported
into) C<CORE> should only be declared or imported with "my" semantics.
All Perl code can see C<CORE> anyway as the outermost lexical scope,
so there's no need to also put such things into C<GLOBAL>.

The C<GLOBAL> package itself is rooted at C<CORE::GLOBAL>.
The C<PROCESS> package is rooted at C<CORE::PROCESS>.  You will note
that C<PROCESS> is not the parent of C<GLOBAL>.  However, searching
up the dynamic stack for context variables will look in all nested
dynamic scopes (mapped automatically to each call's lexical scope,
not package scope) out to C<UNIT>; once all the dynamic scopes are
exhausted, it also looks in the C<GLOBAL> package and then in the
C<PROCESS> package, so C<$*OUT> typically finds the process's standard
output handle.

Any context variable declared with C<our> in the user's main program
(specifically, the part compiled with C<GLOBAL> as the current package)
is accessible (by virtue of being in C<GLOBAL>) as a context variable
even if not directly in the dynamic call chain.  Note that context
vars do *not* look in C<CORE> for anything.  (They I<might> look in
C<SETTING> if you're running under a setting distinct from C<CORE>,
if that setting defines a dynamic scope outside your main program,
such as for the C<-n> or C<-p> switch.)

=item *

You may interpolate a string into a package or variable name using
C<::($expr)> where you'd ordinarily put a package or variable name.
The string is allowed to contain additional instances of C<::>, which
will be interpreted as package nesting.  You may only interpolate
entire names, since the construct starts with C<::>, and either ends
immediately or is continued with another C<::> outside the parens.
Most symbolic references are done with this notation:

    $foo = "Bar";
    $foobar = "Foo::Bar";
    $::($foo)           # package-scoped $Bar
    $::("MY::$foo")     # lexically-scoped $Bar
    $::("*::$foo")      # global $Bar
    $::($foobar)        # $Foo::Bar
    $::($foobar)::baz   # $Foo::Bar::baz
    $::($foo)::Bar::baz # $Bar::Bar::baz
    $::($foobar)baz     # ILLEGAL at compile time (no operator baz)

Note that unlike in Perl 5, initial C<::> doesn't imply global.
Package names are searched for from inner lexical scopes to outer,
then from inner packages to outer.  Variable names are searched
for from inner lexical scopes to outer, but unlike package names
are looked for in only the current package.

注意与 Perl 5 不同，

Use the C<MY> pseudopackage to limit the lookup to the current lexical
scope, and C<OUR> to limit the scopes to the current package scope.

=item *

When "strict" is in effect (which is the default except for one-liners),
non-qualified variables (such as C<$x> and C<@y>) are only looked up from
lexical scopes, but never from package scopes.

To bind package variables into a lexical scope, simply say C<our ($x, @y)>.
To bind global variables into a lexical scope, predeclare them with C<use>:

    use PROCESS <$IN $OUT>;

Or just refer to them as C<$*IN> and C<$*OUT>.

=item *

To do direct lookup in a package's symbol table without scanning, treat
the package name as a hash:

    Foo::Bar::{'&baz'}  # same as &Foo::Bar::baz
    PROCESS::<$IN>      # Same as $*IN
    Foo::<::Bar><::Baz> # same as Foo::Bar::Baz

The C<::> before the subscript is required here, because the
C<Foo::Bar{...}> syntax is reserved for attaching a "WHENCE"
initialization closure to an autovivifiable type object.  (see S12).

Unlike C<::()> symbolic references, this does not parse the argument
for C<::>, nor does it initiate a namespace scan from that initial
point.  In addition, for constant subscripts, it is guaranteed to
resolve the symbol at compile time.

The null pseudo-package is reserved to mean the same search list as an ordinary
name search.  That is, the following are all identical in meaning:

    $foo
    $::{'foo'}
    ::{'$foo'}
    $::<foo>
    ::<$foo>

That is, each of them scans lexical scopes outward, and then the current package scope
(though the package scope is then disallowed when "strict" is in effect).

As a result of these rules, you can write any arbitrary variable name as either of:

    $::{'!@#$#@'}
    ::{'$!@#$#@'}

You can also use the C<< ::<> >> form as long as there are no spaces in the name.

=item *

The current lexical symbol table is now accessible through the
pseudo-package C<MY>.  The current package symbol table is visible as
pseudo-package C<OUR>.  The C<OUTER> name refers to the C<MY> symbol table
immediately surrounding the current C<MY>, and C<OUTER::OUTER> is the one
surrounding that one.

    our $foo = 41;
    say $::foo;         # prints 41, :: is no-op
    {
        my $foo = 42;
        say MY::<$foo>;         # prints "42"
        say $MY::foo;           # same thing
        say $::foo;             # same thing, :: is no-op here

        say OUR::<$foo>;        # prints "41"
        say $OUR::foo;          # same thing

        say OUTER::<$foo>;      # prints "41" (our $foo is also lexical)
        say $OUTER::foo;        # same thing
    }

You may not use any lexically scoped symbol table, either by name or
by reference, to add symbols to a lexical scope that is done compiling.
(We reserve the right to relax this if it turns out to be useful though.)

=item *

The C<CALLER> package refers to the lexical scope of the (dynamically
scoped) caller.  The caller's lexical scope is allowed to hide any
user-defined variable from you.  In fact, that's the default, and a
lexical variable must have the trait "C<is context>" to be
visible via C<CALLER>.  (C<$_>, C<$!> and C<$/> are always
contextual, as are any variables whose declared names contain a C<*> twigil.)
If the variable is not visible in the caller, it returns
failure.  Variables whose names are visible at the point of the call but that
come from outside that lexical scope are controlled by the scope
in which they were originally declared as contextual.
Hence the visibility of C<< CALLER::<$*foo> >> is determined where
C<$*foo> is actually declared, not by the caller's scope (unless that's where
it happens to be declared).  Likewise C<< CALLER::CALLER::<$x> >>
depends only on the declaration of C<$x> visible in your caller's caller.

User-defined contextual variables should generally be initialized with
C<::=> unless it is necessary for variable to be modified.  (Marking
dynamic variables as readonly is very helpful in terms of sharing
the same value among competing threads, since a readonly variable
need not be locked.)

=item *

The C<CONTEXT> pseudo-package is just like C<CALLER> except that
it starts in the current dynamic scope and from there scans outward
through all dynamic scopes until it finds a contextual variable of that
name in that dynamic context's associated lexical pad.  (This search
is implied for variables with the C<*> twigil; hence C<$*FOO> is
equivalent to C<< CONTEXT::<$*FOO> >>.)  If, after scanning outward
through all those dynamic scopes, there is no variable of that name
in any immediately associated lexical pad, it strips the C<*> twigil
out of the name and looks in the C<GLOBAL> package followed by the
C<PROCESS> package.  If the value is not found, it returns failure.

Unlike C<CALLER>, C<CONTEXT> will see a contextual variable that is
declared in the current scope, since it starts search 0 scopes up the
stack rather than 1.  You may, however, use C<< CALLER::<$*foo> >>
to bypass a contextual definition of C<$*foo> in your current context,
such as to initialize it with the outer contextual value:

    my $*foo ::= CALLER::<$*foo>;

The C<temp> declarator may be used (without an initializer) on a
contextual variable to perform a similar operation:

    temp $*foo;

The main difference is that by default it initializes the new
C<$*foo> with its current value, rather than the caller's value.
Also, it is allowed only on read/write contextual variables, since
the only reason to make a copy of the outer value would be
because you'd want to override it later and then forget the
changes at the end of the current dynamic scope.

You may also use C<< OUTER::<$*foo> >> to mean you want to start the
search in your outer lexical scope, but this will succeed only if
that outer lexical scope also happens to be be one of your current
I<dynamic> scopes.  That is, the same search is done as with the bare
C<$*foo>, but any "hits" are ignored until we've got to the C<OUTER>
scope in our traversal.

=item *

There is no longer any special package hash such as C<%Foo::>.  Just
subscript the package object itself as a hash object, the key of which
is the variable name, including any sigil.  The package object can
be derived from a type name by use of the C<::> postfix:

    MyType::<$foo>

(Directly subscripting the type with either square brackets or curlies
is reserved for various generic type-theoretic operations.  In most other
matters type names and package names are interchangeable.)

Typeglobs are gone.  Use binding (C<:=> or C<::=>) to do aliasing.
Individual variable objects are still accessible through the
hash representing each symbol table, but you have to include the
sigil in the variable name now: C<MyPackage::{'$foo'}> or the
equivalent C<< MyPackage::<$foo> >>.

=item *

Interpreter globals live in the C<GLOBAL> package.  The user's program
starts in the C<GLOBAL> package, so "our" declarations in the mainline
code go into that package by default.  Process-wide variables live in
the C<PROCESS> package.  Most predefined globals such as C<$*UID>
and C<%*PID> are actually process globals.

=item *

There is only ever a single C<PROCESS> package.
For an ordinary Perl program running by itself, there is only one C<GLOBAL>
package as well.  However, in certain
situations (such as shared hosting under a webserver), the actual
process may contain multiple virtual processes or interpreters, each running its own
"main" code.  In this case, the C<GLOBAL> namespace holds variables
that properly belong to the individual virtual process, while the
C<PROCESS> namespace holds variables that properly belong to the actual
process as a whole.  From the viewpoint of the program
there is little difference as long as all global variables are accessed
as if they were context variables (by using the C<*> twigil).
The process as a whole may place restrictions on the
mutability of process variables as seen by the individual subprocesses.
Also, individual subprocesses may not create new process variables.
If the process wishes to grant subprocesses the ability to communicate
via the C<PROCESS> namespace, it must supply a writeable context variable
to all the subprocesses granted that privilege.

=item *

The magic command-line input handle is C<$*ARGFILES>.
The arguments themselves come in C<@*ARGS>.  See also "Declaring a MAIN
subroutine" in S06.

=item *

Magical file-scoped values live in variables with a C<=> secondary
sigil.  C<$=DATA> is the name of your C<DATA> filehandle, for instance.
All Pod structures are available through C<%=POD> (or some such).
As with C<*>, the C<=> may also be used as a package name: C<$=::DATA>.

=item *

Magical lexically scoped values live in variables with a C<?> secondary
sigil.  These are all values that are known to the compiler, and may
in fact be dynamically scoped within the compiler itself, and only
appear to be lexically scoped because dynamic scopes of the compiler
resolve to lexical scopes of the program.  All C<$?> variables are considered
constants, and may not be modified after being compiled in.  The user
is also allowed to define or (redefine) such constants:

    constant $?TABSTOP = 4;     # assume heredoc tabs mean 4 spaces

(Note that the constant declarator always evaluates its initialization
expression at compile time.)

C<$?FILE> and C<$?LINE> are your current file and line number, for
instance.
Instead of C<$?OUTER::FOO> you probably want to write C<< OUTER::<$?FOO> >>.
Within code that is being run during the compile, such as C<BEGIN> blocks, or
macro bodies, or constant initializers, the compiler variables must be referred
to as (for instance) C<< COMPILING::<$?LINE> >> if the bare C<$?LINE> would
be taken to be the value during the compilation of the currently running
code rather than the eventual code of the user's compilation unit.  For
instance, within a macro body C<$?LINE> is the line within the macro
body, but C<< COMPILING::<$?LINE> >> is the line where the macro was invoked.
See below for more about the C<COMPILING> pseudo package.

Here are some possibilities:

这里有一些可能性：

    $?FILE      Which file am I in?
    $?LINE      Which line am I at?
    &?ROUTINE   Which routine am I in?
    &?BLOCK     Which block am I in?
    %?LANG      What is the current set of interwoven languages?

The following return objects that contain all pertinent info:

下面的返回对象包含了所有的相关信息：

    $?KERNEL    Which kernel am I compiled for?
    $?DISTRO    Which OS distribution am I compiling under
    $?VM        Which virtual machine am I compiling under
    $?XVM       Which virtual machine am I cross-compiling for
    $?PERL      Which Perl am I compiled for?
    $?SCOPE     Which lexical scope am I in?
    $?PACKAGE   Which package am I in?
    $?MODULE    Which module am I in?
    $?CLASS     Which class am I in? (as variable)
    $?ROLE      Which role am I in? (as variable)
    $?GRAMMAR   Which grammar am I in?

It is relatively easy to smartmatch these constant objects
against pairs to check various attributes such as name,
version, or authority:

    given $?VM {
        when :name<Parrot> :ver(v2) { ... }
        when :name<CLOS>            { ... }
        when :name<SpiderMonkey>    { ... }
        when :name<JVM> :ver(v6.*)  { ... }
    }

Matches of constant pairs on constant objects may all be resolved at
compile time, so dead code can be eliminated by the optimizer.

Note that some of these things have parallels in the C<*> space at run time:

    $*KERNEL    Which kernel I'm running under
    $*DISTRO    Which OS distribution I'm running under
    $*VM        Which VM I'm running under
    $*PERL      Which Perl I'm running under

You should not assume that these will have the same value as their
compile-time cousins.

=item *

While C<$?> variables are constant to the run time, the compiler
has to have a way of changing these values at compile time without
getting confused about its own C<$?> variables (which were frozen in
when the compile-time code was itself compiled).  The compiler can
talk about these compiler-dynamic values using the C<COMPILING> pseudopackage.

References to C<COMPILING> variables are automatically hoisted into the
context currently being compiled.  Setting or temporizing a C<COMPILING>
variable sets or temporizes the incipient C<$?> variable in the
surrounding lexical context that is being compiled.  If nothing in
the context is being compiled, an exception is thrown.

    $?FOO // say "undefined";   # probably says undefined
    BEGIN { COMPILING::<$?FOO> = 42 }
    say $?FOO;                  # prints 42
    {
        say $?FOO;              # prints 42
        BEGIN { temp COMPILING::<$?FOO> = 43 } # temporizes to *compiling* block
        say $?FOO;              # prints 43
        BEGIN { COMPILING::<$?FOO> = 44 }
        say $?FOO;              # prints 44
        BEGIN { say COMPILING::<$?FOO> }        # prints 44, but $?FOO probably undefined
    }
    say $?FOO;                  # prints 42 (left scope of temp above)
    $?FOO = 45;                 # always an error
    COMPILING::<$?FOO> = 45;    # an error unless we are compiling something

Note that C<< CALLER::<$?FOO> >> might discover the same variable
as C<COMPILING::<$?FOO>>, but only if the compiling context is the
immediate caller.  Likewise C<< OUTER::<$?FOO> >> might or might not
get you to the right place.  In the abstract, C<COMPILING::<$?FOO>>
goes outwards dynamically until it finds a compiling scope, and so is
guaranteed to find the "right" C<$?FOO>.  (In practice, the compiler
hopefully keeps track of its current compiling scope anyway, so no
scan is needed.)

Perceptive readers will note that this subsumes various "compiler hints"
proposals.  Crazy readers will wonder whether this means you could
set an initial value for other lexicals in the compiling scope.  The
answer is yes.  In fact, this mechanism is probably used by the
exporter to bind names into the importer's namespace.

=item *

The currently compiling Perl parser is switched by modifying
one of the braided languages in
C<< COMPILING::<%?LANG> >>.  Lexically scoped parser changes
should temporize the modification.  Changes from here to
end-of-compilation unit can just assign or bind it.  In general,
most parser changes involve deriving a new grammar and then pointing
one of the
C<< COMPILING::<%?LANG> >> entries at that new grammar.  Alternately, the
tables driving the current parser can be modified without derivation,
but at least one level of anonymous derivation must intervene from
the preceding Perl grammar, or you might be messing up someone else's
grammar.  Basically, the current set of grammars in C<%?LANG> has to belong only to the
current compiling scope.  It may not be shared, at least not without
explicit consent of all parties.  No magical syntax at a distance.
Consent of the governed, and all that.

=item *

Individual sublanguages ("slangs") may be referred to using the C<~> twigil.  The following
are useful:

    $~MAIN       the current main language (e.g. Perl statements)
    $~Q          the current root of quoting language
    $~Quasi      the current root of quasiquoting language
    $~Regex      the current root of regex language
    $~Trans      the current root of transliteration language
    $~P5Regex    the current root of the Perl regex language

Hence, when you are defining a normal Perl macro, you're replacing
C<$~MAIN> with a derived language, but when you define a new regex
backslash sequence, you're replacing C<$~Regex> with a derived
language.  (There may or may not be a syntax in the main language
to do this.)  Note that such changes are automatically scoped
to the lexical scope; as with real slang, the definitions are
temporary and embedded in a larger language inherited from
the surrounding culture.

Instead of defining macros directly you may also mix in one or more
grammar rules by lexically scoped declaration of a new sublanguage:

    augment slang Regex {  # derive from $~Regex and then modify $~Regex
        token backslash:std<\Y> { YY };
    }

This tends to be more efficient since it only has to do one mixin
at the end of the block.  Note that the slang declaration has
nothing to do with package C<Regex>, but only with C<$~Regex>.
Sublanguages are in their own namespace (inside the current value
of C<%?LANG>, in fact).  Hence C<augment> is modifying one of the local
strands of a braided language, not a package somewhere else.

You may also supersede a sublang entirely if, for example,
you just want to disable that sublanguage in the current lexical scope:

    supersede slang P5Regex {}
    m:P5/./;             # kaboom

If you supersede C<MAIN> then you're replacing the Perl parser entirely.
This might be done by, say, the "use COBOL" declaration. C<:-)>

如果你取代 C<MAIN>，那么你就是替换整个 Perl 语法分析器。

=item *

It is often convenient to have names that contain arbitrary characters
or other data structures.  Typically these uses involve situations
where a set of entities shares a common "short" name, but still needs
for each of its elements to be identifiable individually.  For
example, you might use a module whose short name is C<ThatModule>,
but the complete long name of a module includes its version, naming
authority, and perhaps even its source language.  Similarly,
sets of operators work together in various syntactic categories
with names like C<prefix>, C<infix>, C<postfix>, etc.  The long
names of these operators, however, often contain characters that
are excluded from ordinary identifiers.

For all such uses, an identifier followed by a subscript-like adverbial
form (see below) is considered an I<extended identifier>:

    infix:<+>    # the official name of the operator in $a + $b
    infix:<*>    # the official name of the operator in $a * $b
    infix:«<=»   # the official name of the operator in $a <= $b
    prefix:<+>   # the official name of the operator in +$a
    postfix:<--> # the official name of the operator in $a--

This name is to be thought of semantically, not syntactically.  That is,
the bracketing characters used do not count as part of the name; only
the quoted data matters.  These are all the same name:

这个名称被认为是语义上的，不是句法上的。也就是说，括号字符不视为名称的一部分；仅
仅仅是被引用的数据资料。这些是同样的名称：

    infix:<+>
    infix:<<+>>
    infix:«+»
    infix:['+']

Despite the appearance as a subscripting form, these names are resolved
not at run time but at compile time.  The pseudo-subscripts need not
be simple scalars.  These are extended with the same two-element list:

    infix:<?? !!>
    infix:['??','!!']

An identifier may be extended with multiple named identifier
extensions, in which case the names matter but their order does not.
These name the same module:

    use ThatModule:auth<Somebody>:ver<2.7.18.28.18>
    use ThatModule:ver<2.7.18.28.18>:auth<Somebody>

Adverbial syntax will be described more fully later.

稍后将提供更全面的副词语法描述。

=back

=head1 Literals

=head1 直接量

=over 4

=item *

A single underscore is allowed only between any two digits in a
literal number, where the definition of digit depends on the radix.
Underscores are not allowed anywhere else in any numeric literal,
including next to the radix point or exponentiator, or at the beginning
or end.

在数字串中的两个数字之间，仅允许有一个单一的下划线，

=item *

Initial C<0> no longer indicates octal numbers by itself.  You must use
an explicit radix marker for that.  Pre-defined radix prefixes include:

    0b          base 2, digits 0..1
    0o          base 8, digits 0..7
    0d          base 10, digits 0..9
    0x          base 16, digits 0..9,a..f (case insensitive)

=item *

The general radix form of a number involves prefixing with the radix
in adverbial form:

    :10<42>             same as 0d42 or 42
    :16<DEAD_BEEF>      same as 0xDEADBEEF
    :8<177777>          same as 0o177777 (65535)
    :2<1.1>             same as 0b1.1 (0d1.5)

Extra digits are assumed to be represented by C<a>..C<z> and C<A>..C<Z>, so you
can go up to base 36.  (Use C<A> and C<B> for base twelve, not C<T> and C<E>.)
Alternately you can use a list of digits in decimal:

    :60[12,34,56]       # 12 * 3600 + 34 * 60 + 56
    :100[3,'.',14,16]   # pi

All numbers representing digits must be less than the radix, or an
error will result (at compile time if constant-folding can catch it,
or at run time otherwise).

Any radix may include a fractional part.  A dot is never ambiguous
because you have to tell it where the number ends:

    :16<dead_beef.face> # fraction
    :16<dead_beef>.face # method call

=item *

Only base 10 (in any form) allows an additional exponentiator starting
with 'e' or 'E'.  All other radixes must either rely on the constant folding
properties of ordinary multiplication and exponentiation, or supply the
equivalent two numbers as part of the string, which will be interpreted
as they would outside the string, that is, as decimal numbers by default:

    :16<dead_beef> * 16**8
    :16<dead_beef*16**8>

It's true that only radixes that define C<e> as a digit are ambiguous that
way, but with any radix it's not clear whether the exponentiator should
be 10 or the radix, and this makes it explicit:

    0b1.1e10                    ILLEGAL, could be read as any of:

    :2<1.1> * 2 ** 10           1536
    :2<1.1> * 10 ** 10          15,000,000,000
    :2<1.1> * :2<10> ** :2<10>  6

So we write those as

    :2<1.1*2**10>               1536
    :2<1.1*10**10>              15,000,000,000
    :2«1.1*:2<10>**:2<10>»      6

The generic string-to-number converter will recognize all of these
forms (including the * form, since constant folding is not available
to the run time).  Also allowed in strings are leading plus or minus,
and maybe a trailing Units type for an implied scaling.  Leading and
trailing whitespace is ignored.  Note also that leading C<0> by itself
I<never> implies octal in Perl 6.

Any of the adverbial forms may be used as a function:

    :2($x)      # "bin2num"
    :8($x)      # "oct2num"
    :10($x)     # "dec2num"
    :16($x)     # "hex2num"

Think of these as setting the default radix, not forcing it.  Like Perl
5's old C<oct()> function, any of these will recognize a number starting
with a different radix marker and switch to the other radix.  However,
note that the C<:16()> converter function will interpret leading C<0b>
or C<0d> as hex digits, not radix switchers.

=item *

Rational literals are indicated by separating two integer literals
(in any radix) with a slash.  Whitespace is not allowed on either
side of the slash:

    1/2         # one half literal Rat
    1 / 2       # 1 divided by 2  (also produces a Rat by constant folding)

Note that this essentially overrides precedence to produce a term, so:

    1/2 * 3/4

means

意思是

    (1 / 2) * (3 / 4)

rather than

而不是

    ((1 / 2) * 3) / 4

=item *

Complex literals are similarly indicated by writing an addition of
two real numbers without spaces:

    5.2+1e42i

As with rational literals, constant folding would produce the same
complex number, but this form parses as a single term, ignoring
surrounding precedence.

=item *

Characters indexed by hex numbers can be interpolated into strings
by introducing with C<"\x">, followed by either a bare hex number
(C<"\x263a">) or a hex number in square brackets (C<"\x[263a]">).
Similarly, C<"\o12"> and C<"\o[12]"> interpolate octals--but generally
you should be using hex in the world of Unicode.  Multiple characters
may be specified within any of the bracketed forms by separating the
numbers with comma: C<"\x[41,42,43]">.  You must use the bracketed
form to disambiguate if the unbracketed form would "eat" too many
characters, because all of the unbracketed forms eat as many characters
as they think look like digits in the radix specified.  None of these
notations work in normal Perl code.  They work only in interpolations
and regexes and the like.

The old C<\123> form is now illegal, as is the C<\0123> form.
Only C<\0> remains, and then only if the next character is not in
the range C<'0'..'7'>.  Octal characters must use C<\o> notation.
Note also that backreferences are no longer represented by C<\1>
and the like--see S05.

=item *

The C<qw/foo bar/> quote operator now has a bracketed form: C<< <foo bar> >>.
When used as a subscript it performs a slice equivalent to C<{'foo','bar'}>.
Elsewhere it is equivalent to a parenthesized list of strings:
C<< ('foo','bar') >>.  Since parentheses are generally reserved just for
precedence grouping, they merely autointerpolate in list context.  Therefore

    @a = 1, < x y >, 2;

is equivalent to:

等价于：

    @a = 1, ('x', 'y'), 2;

which is the same as:

这与下面的一样：

    @a = 1, 'x', 'y', 2;

In item context, though, the implied parentheses are not removed, so

    $a = < a b >;

is equivalent to:

等价于：

    $a = ('a', 'b');

which, because the list is assigned to a scalar, is autopromoted into
a C<Capture> object:

    $a = \('a', 'b');

Likewise, if bound to a scalar parameter, C<< <a b> >> will be
treated as a single C<Capture> object, but if bound to a slurpy parameter,
it will auto-flatten.

But note that under the parenthesis-rewrite rule, a single value will
still act like a scalar value.  These are all the same:

    $a = < a >;
    $a = ('a');
    $a = 'a';

And if bound to a scalar parameter, no list is constructed.
To force a single value to become a list object in item context,
you should use C<< ['a'] >> for clarity as well as correctness.

The degenerate case C<< <> >> is disallowed as a probable attempt to
do IO in the style of Perl 5; that is now written C<lines()>.  (C<<
<STDIN> >> is also disallowed.)  Empty lists are better written with
C<()> or C<Nil> in any case because C<< <> >> will often be misread
as meaning C<('')>.  (Likewise the subscript form C<< %foo<> >>
should be written C<%foo{}> to avoid misreading as C<@foo{''}>.)
If you really want the angle form for stylistic reasons, you can
suppress the error by putting a space inside: C<< < > >>.

Much like the relationship between single quotes and double quotes, single
angles do not interpolate while double angles do.  The double angles may
be written either with French quotes, C<«$foo @bar[]»>, or
with "Texas" quotes, C<<< <<$foo @bar[]>> >>>, as the ASCII workaround.
The implicit split is done after interpolation, but respects quotes
in a shell-like fashion, so that C<«'$foo' "@bar[]"»> is guaranteed to
produce a list of two "words" equivalent to C<< ('$foo', "@bar[]") >>.
C<Pair> notation is also recognized inside C<«...»> and such "words" are
returned as C<Pair> objects.

Colon pairs (but not arrow pairs) are recognized within double angles.
In addition, the double angles allow for comments beginning with C<#>.
These comments work exactly like ordinary comments in Perl code.
Unlike in the shells, any literal C<#> must be quoted, even
ones without whitespace in front of them, but note that this comes
more or less for free with a colon pair like C<< :char<#x263a> >>, since
comments only work in double angles, not single.

=item *

There is now a generalized adverbial form of Pair notation.  The
following table shows the correspondence to the "fatarrow" notation:

    Fat arrow           Adverbial pair  Paren form
    =========           ==============  ==========
    a => True           :a
    a => False          :!a
    a => 0              :a(0)
    a => $x             :a($x)
    a => 'foo'          :a<foo>         :a(<foo>)
    a => <foo bar>      :a<foo bar>     :a(<foo bar>)
    a => «$foo @bar»    :a«$foo @bar»   :a(«$foo @bar»)
    a => {...}          :a{...}         :a({...})
    a => [...]          :a[...]         :a([...])
    a => $a             :$a
    a => @a             :@a
    a => %a             :%a
    a => $$a            :$$a
    a => @$$a           :@$$a (etc.)
    a => %foo<a>        %foo<a>:p

The fatarrow construct may be used only where a term is expected
because it's considered an expression in its own right, since the
fatarrow itself is parsed as a normal infix operator (even when
autoquoting an identifier on its left).  Because the left side is a
general expression, the fatarrow form may be used to create a Pair
with I<any> value as the key.  On the other hand, when used as above
to generate C<Pair> objects, the adverbial forms are restricted to
the use of identifiers as keys.  You must use the fatarrow form to
generate a C<Pair> where the key is not an identifier.

Despite that restriction, it's possible for other things to
come between a colon and its brackets; however, all of the possible
non-identifier adverbial keys are reserved for special syntactical
forms.  Perl 6 currently recognizes decimal numbers and the null key.
In the following table the first and second columns do I<not> mean
the same thing:

    Simple pair         DIFFERS from    which means
    ===========         ============    ===========
    2 => <101010>       :2<101010>      radix literal 0b101010
    8 => <123>          :8<123>         radix literal 0o123
    16 => <deadbeef>    :16<deadbeef>   radix literal 0xdeadbeef
    16 => $somevalue    :16($somevalue) radix conversion function
    '' => $x            :($x)           arglist or signature literal
    '' => ($x,$y)       :($x,$y)        arglist or signature literal
    '' => <x>           :<x>            identifier extension
    '' => «x»           :«x»            identifier extension
    '' => [$x,$y]       :[$x,$y]        identifier extension
    '' => { .say }      :{ .say }       adverbial block

All of the adverbial forms (including the normal ones with
identifier keys) are considered special tokens and are recognized
in various positions in addition to term position.  In particular,
when used where an infix would be expected they modify the previous
topmost operator that is tighter in precedence than "loose unary"
(see S03):

    1 .. 100 :by(3)     # count to 100 by threes

Within declarations the adverbial form is used to rename parameter declarations:

    sub foo ( :externalname($myname) ) {...}

Adverbs modify the meaning of various quoting forms:

    q:x 'cat /etc/passwd'

When appended to an identifier (that is, in postfix position),
the adverbial syntax is used to generate unique variants of that
identifier; this syntax is used for naming operators such as C<<
infix:<+> >> and multiply-dispatched grammatical rules such as
C<statement_control:if>.  When so used, the adverb is considered an
integral part of the name, so C<< infix:<+> >> and C<< infix:<-> >>
are two different operators.  Likewise C<< prefix:<+> >> is different
from C<< infix:<+> >>.  (The notation also has the benefit of grouping
distinct identifiers into easily accessible sets; this is how the
standard Perl 6 grammar knows the current set of infix operators,
for instance.)

Either fatarrow or adverbial pair notation may be used to pass
named arguments as terms to a function or method.  After a call with
parenthesized arguments, only the adverbial syntax may be used to pass
additional arguments.  This is typically used to pass an extra block:

    find($directory) :{ when not /^\./ }

This just naturally falls out from the preceding rules because the
adverbial block is in operator position, so it modifies the "find
operator".  (Parens aren't considered an operator.)

Note that (as usual) the C<{...}> form (either identifier-based
or special) can indicate either a closure or a hash depending on
the contents.  It does I<not> always indicate a subscript despite
being parsed as one.  (The function to which it is passed can I<use>
the value as a subscript if it chooses, however.)

Note also that the C<< <a b> >> form is not a subscript and is
therefore equivalent not to C<.{'a','b'}> but rather to C<('a','b')>.
Bare C<< <a> >> turns into C<('a')> rather than C<('a',)>.  (However,
as with the other bracketed forms, the value may end up being used
as a subscript depending on context.)

Two or more adverbs can always be strung together without intervening
punctuation anywhere a single adverb is acceptable.  When used as
named arguments in an argument list, you I<may> put comma between,
because they're just ordinary named arguments to the function, and
a fatarrow pair would work the same.  However, this comma is allowed
only when the first pair occurs where a term is expected.  Where an
infix operator is expected, the adverb is always taken as modifying
the nearest preceding operator that is not hidden within parentheses,
and if you string together multiple such pairs, you may not put commas
between, since that would cause subsequent pairs to look like terms.
(The fatarrow form is not allowed at all in operator position.)
See S06 for the use of adverbs as named arguments.

The negated form (C<:!a>) and the sigiled forms (C<:$a>, C<:@a>,
C<:%a>) never take an argument and don't care what the next character
is.  They are considered complete.  These forms require an identifier
to serve as the key.

For identifiers that take a numeric argument, it is allowed to
abbreviate, for example, C<:sweet(16)> to C<:16sweet>.  (This is
distinguishable from the :16<deadbeef> form, which never has an
alphabetic character following the number.)  Only literal decimal
numbers may be swapped this way.

The other forms of adverb (including the bare C<:a> form) I<always>
look for an immediate bracketed argument, and will slurp it up.
If that's not intended, you must use whitespace between the adverb and
the opening bracket.  The syntax of individual adverbs is the same
everywhere in Perl 6.  There are no exceptions based on whether an
argument is wanted or not.  (There is a minor exception for quote and
regex adverbs, which accept I<only> parentheses as their bracketing
operator, and ignore other brackets, which must be placed in parens
if desired.  See "Paren form" in the table above.)

Except as noted above, the parser always
looks for the brackets.  Despite not indicating a true subscript,
the brackets are similarly parsed as postfix operators.  As postfixes
the brackets may be separated from their initial C<:foo> with either
unspace or dot (or both), but nothing else.

Regardless of syntax, adverbs used as named arguments (in either term
or infix position) generally show up as optional named parameters to
the function in question--even if the function is an operator or macro.
The function in question neither knows nor cares how weird the original
syntax was.

=item *

In addition to C<q> and C<qq>, there is now the base form C<Q> which does
I<no> interpolation unless explicitly modified to do so.  So C<q> is really
short for C<Q:q> and C<qq> is short for C<Q:qq>.  In fact, all quote-like
forms derive from C<Q> with adverbs:

    q//         Q :q //
    qq//        Q :qq //
    rx//        Q :regex //
    s///        Q :subst ///
    tr///       Q :trans ///

Adverbs such as C<:regex> change the language to be parsed by switching
to a different parser.  This can completely change the interpretation
of any subsequent adverbs as well as the quoted material itself.

    q:s//       Q :q :scalar //
    rx:s//      Q :regex :sigspace //

=item *

Generalized quotes may now take adverbs:

    Short       Long            Meaning
    =====       ====            =======
    :x          :exec           Execute as command and return results
    :w          :words          Split result on words (no quote protection)
    :ww         :quotewords     Split result on words (with quote protection)
    :q          :single         Interpolate \\, \q and \' (or whatever)
    :qq         :double         Interpolate with :s, :a, :h, :f, :c, :b
    :s          :scalar         Interpolate $ vars
    :a          :array          Interpolate @ vars
    :h          :hash           Interpolate % vars
    :f          :function       Interpolate & calls
    :c          :closure        Interpolate {...} expressions
    :b          :backslash      Interpolate \n, \t, etc. (implies :q at least)
    :to         :heredoc        Parse result as heredoc terminator
                :regex          Parse as regex
                :subst          Parse as substitution
                :trans          Parse as transliteration
                :code           Quasiquoting
    :p          :path           Return a Path object (see S16 for more options)

You may omit the first colon by joining an initial C<Q>, C<q>, or C<qq> with
a single short form adverb, which produces forms like:

    qw /a b c/;                         # P5-esque qw// meaning q:w
    Qc '...{$x}...';                    # Q:c//, interpolate only closures
    qqx/$cmd @args[]/                   # equivalent to P5's qx//

(Note that C<qx//> doesn't interpolate.)

If you want to abbreviate further, just define a macro:

    macro qx { 'qq:x ' }          # equivalent to P5's qx//
    macro qTO { 'qq:x:w:to ' }    # qq:x:w:to//
    macro quote:<❰ ❱> ($text) { quasi { $text.quoteharder } }

All the uppercase adverbs are reserved for user-defined quotes.
All Unicode delimiters above Latin-1 are reserved for user-defined quotes.

=item *

A consequence of the previous item is that we can now say:

    %hash = qw:c/a b c d {@array} {%hash}/;

or

或

    %hash = qq:w/a b c d {@array} {%hash}/;

to interpolate items into a C<qw>.  Conveniently, arrays and hashes
interpolate with only whitespace separators by default, so the subsequent
split on whitespace still works out.  (But the built-in C<«...»> quoter
automatically does interpolation equivalent to C<qq:ww/.../>.  The
built-in C<< <...> >> is equivalent to C<q:w/.../>.)

=item *

Whitespace is allowed between the "q" and its adverb: C<q :w /.../>.

=item *

For these "q" forms the choice of delimiters has no influence on the
semantics.  That is, C<''>, C<"">, C<< <> >>, C<«»>, C<``>, C<()>,
C<[]>, and C<{}> have no special significance when used in place of
C<//> as delimiters.  There may be whitespace before the
opening delimiter. (Which is mandatory for parens because C<q()> is
a subroutine call and C<q:w(0)> is an adverb with arguments).  Other
brackets may also require whitespace when they would be understood as
an argument to an adverb in something like C<< q:z<foo>// >>.
A colon may never be used as the delimiter since it will always be
taken to mean another adverb regardless of what's in front of it.
Nor may a C<#> character be used as the delimiter since it is always
taken as whitespace (specifically, as a comment).
You may not use whitespace or alphanumerics for delimiters.

=item *

New quoting constructs may be declared as macros:

    macro quote:<qX> (*%adverbs) {...}

Note: macro adverbs are automatically evaluated at macro call time if
the adverbs are included in the parse.  If an adverb needs to affect
the parsing of the quoted text of the macro, then an explicit named
parameter may be passed on as a parameter to the C<is parsed> subrule,
or used to select which subrule to invoke.

=item *

You may interpolate double-quotish text into a single-quoted string
using the C<\qq[...]> construct.  Other "q" forms also work, including
user-defined ones, as long as they start with "q".  Otherwise you'll
just have to embed your construct inside a C<\qq[...]>.

=item *

Bare scalar variables always interpolate in double-quotish
strings.  Bare array, hash, and subroutine variables may I<never> be
interpolated.  However, any scalar, array, hash or subroutine variable may
start an interpolation if it is followed by a sequence of one or more bracketed
dereferencers: that is, any of:

=over 4

=item 1. An array subscript

=item 2. A hash subscript

=item 3. A set of parentheses indicating a function call

=item 4. Any of 1 through 3 in their B<dot> form

=item 5. A method call that includes argument parentheses

=item 6. A sequence of one or more unparenthesized method call, followed by any of 1 through 5

=back

In other words, this is legal:

换句话说，这是合法的：

    "Val = $a.ord.fmt('%x')\n"

and is equivalent to

并等价于：

    "Val = { $a.ord.fmt('%x') }\n"


=item *

In order to interpolate an entire array, it's necessary now to subscript
with empty brackets:

    print "The answers are @foo[]\n"

Note that this fixes the spurious "C<@>" problem in double-quoted email addresses.

As with Perl 5 array interpolation, the elements are separated by a space.
(Except that a space is not added if the element already ends in some kind
of whitespace.  In particular, a list of pairs will interpolate with a
tab between the key and value, and a newline after the pair.)

=item *

In order to interpolate an entire hash, it's necessary to subscript
with empty braces or angles:

    print "The associations are:\n%bar{}"
    print "The associations are:\n%bar<>"

Note that this avoids the spurious "C<%>" problem in double-quoted printf formats.

By default, keys and values are separated by tab characters, and pairs
are terminated by newlines.  (This is almost never what you want, but
if you want something polished, you can be more specific.)

=item *

In order to interpolate the result of a sub call, it's necessary to include
both the sigil and parentheses:

    print "The results are &baz().\n"

The function is called in item context.  (If it returns a list anyway,
that list is interpolated as if it were an array in string context.)

=item *

In order to interpolate the result of a method call without arguments,
it's necessary to include parentheses or extend the call with something
ending in brackets:

    print "The attribute is $obj.attr().\n"
    print "The attribute is $obj.attr<Jan>.\n"

The method is called in item context.  (If it returns a list,
that list is interpolated as if it were an array.)

It is allowed to have a cascade of argumentless methods as long as
the last one ends with parens:

    print "The attribute is %obj.keys.sort.reverse().\n"

(The cascade is basically counted as a single method call for the
end-bracket rule.)

=item *

Multiple dereferencers may be stacked as long as each one ends in
some kind of bracket:

    print "The attribute is @baz[3](1,2,3){$xyz}<blurfl>.attr().\n"

Note that the final period above is not taken as part of the expression since
it doesn't introduce a bracketed dereferencer.

=item *

A bare closure also interpolates in double-quotish context.  It may
not be followed by any dereferencers, since you can always put them
inside the closure.  The expression inside is evaluated in string item
context.  You can force list context on the expression using
the C<list> operator if necessary.

The following means the same as the previous example.

下面与前面的例子意思一样。

    print "The attribute is { @baz[3](1,2,3){$xyz}<blurfl>.attr }.\n"

The final parens are unnecessary since we're providing "real" code in
the curlies.  If you need to have double quotes that don't interpolate
curlies, you can explicitly remove the capability:

    qq:c(0) "Here are { $two uninterpolated } curlies";

or equivalently:

    qq:!c "Here are { $two uninterpolated } curlies";

Alternately, you can build up capabilities from single quote to tell
it exactly what you I<do> want to interpolate:

    q:s 'Here are { $two uninterpolated } curlies';

=item *

Secondary sigils (twigils) have no influence over whether the primary sigil
interpolates.  That is, if C<$a> interpolates, so do C<$^a>, C<$*a>,
C<$=a>, C<$?a>, C<$.a>, etc.  It only depends on the C<$>.

=item *

No other expressions interpolate.  Use curlies.

=item *

A class method may not be directly interpolated.  Use curlies:

    print "The dog bark is {Dog.bark}.\n"

=item *

The old disambiguation syntax:

    ${foo[$bar]}
    ${foo}[$bar]

is dead.  Use closure curlies instead:

    {$foo[$bar]}
    {$foo}[$bar]

(You may be detecting a trend here...)

=item *

To interpolate a topical method, use curlies: C<"{.bark}">.

=item *

To interpolate a function call without a sigil, use curlies: C<"{abs $var}">.

=item *

And so on.

=item *

Backslash sequences still interpolate, but there's no longer any C<\v>
to mean I<vertical tab>, whatever that is...  (C<\v> now matches vertical
whitespace in a regex.)  Literal character representations are:

    \a          BELL
    \b          BACKSPACE
    \t          TAB
    \n          LINE FEED
    \f          FORM FEED
    \r          CARRIAGE RETURN
    \e          ESCAPE

=item *

There's also no longer any C<\L>, C<\U>, C<\l>, C<\u>, or C<\Q>.
Use curlies with the appropriate function instead: C<"{ucfirst $word}">.

=item *

You may interpolate any Unicode codepoint by name using C<\c> and
square brackets:

    "\c[NEGATED DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE]"

Multiple codepoints constituting a single character may be interpolated
with a single C<\c> by separating the names with comma:

    "\c[LATIN CAPITAL LETTER A, COMBINING RING ABOVE]"

Whether that is regarded as one character or two depends on the
Unicode support level of the current lexical scope.  It is also
possible to interpolate multiple codepoints that do not resolve to
a single character:

    "\c[LATIN CAPITAL LETTER A, LATIN CAPITAL LETTER B]"

[Note: none of the official Unicode character names contains comma.]

You may also put one or more decimal numbers inside the square brackets:

    "\c[13,10]" # CRLF

Any single decimal number may omit the brackets:

    "\c8" # backspace

(Within a regex you may also use C<\C> to match a character that is
not the specified character.)

If the character following C<\c> or C<\C> is neither a left square bracket
nor a decimal digit,
the single following character is turned into a control character by
the usual trick of XORing the 64 bit.  This allows C<\c@> for NULL
and C<\c?> for DELETE, but note that the ESCAPE character may not be
represented that way; it must be represented something like:

    \e
    \c[ESCAPE]
    \c27
    \x1B
    \o33

Obviously C<\e> is preferred when brevity is needed.

=item *

Any character that I<would> start an interpolation in the current
quote context may be protected from such interpolation by prefixing with
backslash.  The backslash is always removed in this case.

The treatment of backslashed characters that would I<not> have
introduced an interpolation varies depending on the type of quote:

=over 4

=item 1.

Any quoting form that includes C<qq> or C<:qq> in its semantic
derivation (including the normal double quote form) assumes that all
backslashes are to be considered meaningful.  The meaning depends
on whether the following character is alphanumeric; if it is, the
non-interpolating sequence produces a compile-time error.  If the
character is non-alphanumeric, the backslash is silently removed, on
the assumption that the string was backslashed using C<quotemeta()>
or some such.

=item 2.

All other quoting forms (including standard single quotes)
assume that non-interpolating sequences are to be left unaltered
because they are probably intended to pass through to the result.
Backslashes are removed I<only> for the terminating quote or for
characters that would interpolate if unbackslashed.  (In either case,
a special exception is made for brackets; if the left bracket would
interpolate, the right bracket may optionally also be backslashed,
and if so, the backslash will be removed.  If brackets are used as
the delimiters, both left and right C<must> be backslashed the same,
since they would otherwise be counted wrong in the bracket count.)

=back

As a consequence, these all produce the same literal string:

因此，这些都产生相同的文字串。

    " \{ this is not a closure } "
    " \{ this is not a closure \} "
    q:c / \{ this is not a closure } /
    q:c / \{ this is not a closure \} /
    q:c { \{ this is not a closure \} }
    q { { this is not a closure } }
    q { \{ this is not a closure \} }

(Of course, matching backslashes is likely to make your syntax
highlighter a bit happier, along with any other naïve bracket
counting algorithms...)

=item *

There are no barewords in Perl 6.  An undeclared bare identifier will
always be taken to mean a subroutine name.  (Class names
(and other type names) are predeclared, or prefixed with the C<::>
type sigil when you're declaring a new one.)  A consequence of this
is that there's no longer any "C<use strict 'subs'>".  Since the syntax
for method calls is distinguished from sub calls, it is only unrecognized
sub calls that must be treated specially.

You still must declare your subroutines, but a bareword with an unrecognized
name is provisionally compiled as a subroutine call, on that assumption that
such a declaration will occur by the end of the current compilation unit:

    foo;         # provisional call if neither &foo nor ::foo is defined so far
    foo();       # provisional call if &foo is not defined so far
    foo($x);     # provisional call if &foo is not defined so far
    foo($x, $y); # provisional call if &foo is not defined so far

    $x.foo;      # not a provisional call; it's a method call on $x
    foo $x:;     # not a provisional call; it's a method call on $x
    foo $x: $y;  # not a provisional call; it's a method call on $x

If a postdeclaration is not seen, the compile fails at C<CHECK> time.
(You are still free to predeclare subroutines explicitly, of course.)
The postdeclaration may be in any lexical or package scope that
could have made the declaration visible to the provisional call had the
declaration occurred before rather than after the provisional
call.

This fixup is done only for provisional calls.  If there
is I<any> real predeclaration visible, it always takes precedence.
In case of multiple ambiguous postdeclarations, either they must all
be multis, or a compile-time error is declared and you must predeclare,
even if one postdeclaration is obviously "closer".  A single
C<proto> predeclaration may make all postdeclared C<multi> work fine,
since that's a run-time dispatch, and all multis are effectively
visible at the point of the controlling C<proto> declaration.

Parsing of a bareword function as a provisional call is always done
the same way list operators are treated.  If a postdeclaration
bends the syntax to be inconsistent with that, it is an error of
the inconsistent signature variety.

If the unrecognized subroutine name is followed by C<< postcircumfix:<( )> >>,
it is compiled as a provisional function call of the parenthesized form.
If it is not, it is compiled as a provisional function call of
the list operator form, which may or may not have an argument list.
When in doubt, the attempt is made to parse an argument list.  As with
any list operator, an immediate postfix operator is illegal unless it is a
form of parentheses, whereas anything following whitespace will be interpreted
as an argument list if possible.

Based on the signature of the subroutine declaration, there are only
four ways that an argument list can be parsed:

    Signature           # of expected args
    ()                  0
    ($x)                1
    ($x?)               0..1
    (anything else)     0..Inf

That is, a standard subroutine call may be parsed only as a 0-arg term
(or function call), a 1-mandatory-arg prefix operator (or function
call), a 1-optional-arg term or prefix operator (or function call), or
an "infinite-arg" list operator (or function call).  A given signature
might only accept 2 arguments, but the only number distinctions the
parser is allowed to make is between void, singular and plural;
checking that number of arguments supplied matches some number
larger than one must be done as a separate semantic constraint, not
as a syntactic constraint.  Perl functions never take N arguments
off of a list and leave the rest for someone else, except for small
values of N, where small is defined as not more than 1.  You can get
fancier using macros, but macros I<always> require predeclaration.
Since the non-infinite-list forms are essentially behaving as macros,
those forms also require predeclaration.  Only the infinite-list form
may be postdeclared (and hence used provisionally).

It is illegal for a provisional subroutine call to be followed by a
colon postfix, since such a colon is allowed only on an indirect object,
or a method call in dot form.  (It is also allowed on a label when a
statement is expected.) So for any undeclared identifier "C<foo>":

    foo.bar             # ILLEGAL       -- postfix must use foo().bar
    foo .bar            # foo($_.bar)   -- no postfix starts with whitespace
    foo\ .bar           # ILLEGAL       -- must use foo()\ .bar
    foo++               # ILLEGAL       -- postfix must use foo()++
    foo 1,2,3           # foo(1,2,3)    -- args always expected after listop
    foo + 1             # foo(+1)       -- term always expected after listop
    foo;                # foo();        -- no postfix, but no args either
    foo:                #   label       -- must be label at statement boundary.
                                        -- ILLEGAL otherwise
    foo: bar:           #   two labels in a row, okay
    .foo:               # $_.foo: 1     -- must be "dot" method with : args
    .foo(1)             # $_.foo(1)     -- must be "dot" method with () args
    .foo                # $_.foo()      -- must be "dot" method with no args
    .$foo:              # $_.$foo: 1    -- indirect "dot" method with : args
    foo bar: 1          # bar.foo(1)    -- bar must be predecl as class
                                        -- sub bar allowed here only if 0-ary
                                        -- otherwise you must say (bar):
    foo bar 1           # foo(bar(1))   -- both subject to postdeclaration
                                        -- never taken as indirect object
    foo $bar: 1         # $bar.foo(1)   -- indirect object even if declared sub
                                        -- $bar considered one token
    foo (bar()):        # bar().foo(1)  -- even if foo declared sub
    foo bar():          # ILLEGAL       -- bar() is two tokens.
    foo .bar:           # foo(.bar:)    -- colon chooses .bar to listopify
    foo bar baz: 1      # foo(baz.bar(1)) -- colon controls "bar", not foo.
    foo (bar baz): 1    # bar(baz()).foo(1) -- colon controls "foo"
    $foo $bar           # ILLEGAL       -- two terms in a row
    $foo $bar:          # ILLEGAL       -- use $bar.$foo for indirection
    (foo bar) baz: 1    # ILLEGAL       -- use $baz.$(foo bar) for indirection

The indirect object colon only ever dominates a simple term, where
"simple" includes classes and variables and parenthesized expressions,
but explicitly not method calls, because the colon will bind to a
trailing method call in preference.  An indirect object that parses as
more than one token must be placed in parentheses, followed by the colon.

In short, only an identifier followed by a simple term followed by a
postfix colon is C<ever> parsed as an indirect object, but that form
will C<always> be parsed as an indirect object regardless of whether
the identifier is otherwise declared.

=item *

There's also no "C<use strict 'refs'>" because symbolic dereferences
are now syntactically distinguished from hard dereferences.
C<@($arrayref)> must now provide an actual array object, while
C<@::($string)> is explicitly a symbolic reference.  (Yes, this may
give fits to the P5-to-P6 translator, but I think it's worth it to
separate the concepts.  Perhaps the symbolic ref form will admit real
objects in a pinch.)

=item *

There is no hash subscript autoquoting in Perl 6.  Use C<< %x<foo> >>
for constant hash subscripts, or the old standby C<< %x{'foo'} >>.  (It
also works to say C<%x«foo»> as long as you realized it's subject to
interpolation.)

But C<< => >> still autoquotes any bare identifier to its immediate
left (horizontal whitespace allowed but not comments).  The identifier is not
subject to keyword or even macro interpretation.  If you say

    $x = do {
        call_something();
        if => 1;
    }

then C<$x> ends up containing the pair C<< ("if" => 1) >>.  Always.
(Unlike in Perl 5, where version numbers didn't autoquote.)

You can also use the :key($value) form to quote the keys of option
pairs.  To align values of option pairs, you may use the
"unspace" postfix forms:

    :longkey\  ($value)
    :shortkey\ <string>
    :fookey\   { $^a <=> $^b }

These will be interpreted as

    :longkey($value)
    :shortkey<string>
    :fookey{ $^a <=> $^b }

=item *

The double-underscore forms are going away:

    Old                 New
    ---                 ---
    __LINE__            $?LINE
    __FILE__            $?FILE
    __PACKAGE__         $?PACKAGE
    __END__             =begin END
    __DATA__            =begin DATA

The C<=begin END> Pod stream is special in that it assumes there's
no corresponding C<=end END> before end of file.  The C<DATA>
stream is no longer special--any Pod stream in the current file
can be accessed via a filehandle, named as C<< %=POD{'DATA'} >> and such.
Alternately, you can treat a Pod stream as a scalar via C<$=DATA>
or as an array via C<@=DATA>.  Presumably a module could read all
its COMMENT blocks from C<@=COMMENT>, for instance.  Each chunk of
Pod comes as a separate array element.  You have to split it into lines
yourself.  Each chunk has a C<.range> property that indicates its
line number range within the source file.

The lexical routine itself is C<&?ROUTINE>; you can get its name with
C<&?ROUTINE.name>.  The current block is C<&?BLOCK>.  If the block has any
labels, those shows up in C<&?BLOCK.labels>.  Within the lexical scope of
a statement with a label, the label is a pseudo-object representing
the dynamic context of that statement.  (If inside multiple dynamic
instances of that statement, the label represents the innermost one.)
When you say:

    next LINE;

it is really a method on this pseudo-object, and

这的确是该伪对象上的一个方法，以及

    LINE.next;

would work just as well.  You can exit any labeled block early by saying

    MyLabel.leave(@results);

=item *

Heredocs are no longer written with C<<< << >>>, but with an adverb on
any other quote construct:

    print qq:to/END/;
        Give $amount to the man behind curtain number $curtain.
        END

Other adverbs are also allowed, as are multiple heredocs within the same
expression:

    print q:c:to/END/, q:to/END/;
        Give $100 to the man behind curtain number {$curtain}.
        END
        Here is a $non-interpolated string
        END

=item *

Heredocs allow optional whitespace both before and after terminating
delimiter.  Leading whitespace equivalent to the indentation of the
delimiter will be removed from all preceding lines.  If a line is
deemed to have less whitespace than the terminator, only whitespace
is removed, and a warning may be issued.  (Hard tabs will be assumed
to be C<< ($?TABSTOP // 8) >> spaces, but as long as tabs and spaces are used consistently
that doesn't matter.)  A null terminating delimiter terminates on
the next line consisting only of whitespace, but such a terminator
will be assumed to have no indentation.  (That is, it's assumed to
match at the beginning of any whitespace.)

=item *

There are two possible ways to parse heredocs.  One is to look ahead
for the newline and grab the lines corresponding to the heredoc, and
then parse the rest of the original line.  This is how Perl 5 does it.
Unfortunately this suffers from the problem pervasive in Perl 5 of
multi-pass parsing, which is masked somewhat because there's no way
to hide a newline in Perl 5.  In Perl 6, however, we can use "unspace"
to hide a newline, which means that an algorithm looking ahead to find
the newline must do a full parse (with possible untoward side effects)
in order to locate the newline.

Instead, Perl 6 takes the one-pass approach, and just lazily queues
up the heredocs it finds in a line, and waits until it sees a "real"
newline to look for the text and attach it to the appropriate heredoc.
The downside of this approach is a slight restriction--you may not use
the actual text of the heredoc in code that must run before the line
finishes parsing.  Mostly that just means you can't write:

    BEGIN { say q:to/END/ }
        Say me!
        END

You must instead put the entire heredoc into the C<BEGIN>:

    BEGIN {
        say q:to/END/;
        Say me!
        END
    }

=item *

A version literal is written with a 'v' followed by the version
number in dotted form.  This always constructs a C<Version> object,
not a string.  Only integers and certain wildcards are allowed;
for anything fancier you must coerce a string to a C<Version>:

    v1.2.3                      # okay
    v1.2.*                      # okay, wildcard version
    v1.2.3+                     # okay, wildcard version
    v1.2.3beta                  # illegal
    Version('1.2.3beta')        # okay

Note though that most places that take a version number in Perl accept
it as a named argument, in which case saying C<< :ver<1.2.3beta> >> is fine.
See S11 for more on using versioned modules.

Version objects have a predefined sort order that follows most people's
intuition about versioning: each sorting position sorts numerically
between numbers, alphabetically between alphas, and alphabetics in a
position before numerics.  Missing final positions are assumed to be '.0'.
Except for '0' itself, numbers ignore leading zeros.  For splitting
into sort positions, if any alphabetics (including underscore) are
immediately adjacent to a number, a dot is assumed between them.
Likewise any non-alphanumeric character is assumed to be equivalent
to a dot.  So these are all equivalent:

    1.2.1alpha1.0
    1.2.1alpha1
    1.2.1.alpha1
    1.2.1alpha.1
    1.2.1.alpha.1
    1.2-1+alpha/1

And these are also equivalent:

    1.2.1_01
    1.2.1_1
    1.2.1._1
    1.2.1_1
    1.2.1._.1
    001.0002.0000000001._.00000000001
    1.2.1._.1.0.0.0.0.0

So these are in sorted version order:

    1.2.0.999
    1.2.1_01
    1.2.1_2
    1.2.1_003
    1.2.1a1
    1.2.1.alpha1
    1.2.1b1
    1.2.1.beta1
    1.2.1.gamma
    1.2.1α1
    1.2.1β1
    1.2.1γ
    1.2.1

Note how the last pair assume that an implicit .0 sorts after anything
alphabetic, and that alphabetic is defined according to Unicode, not just
according to ASCII.  The intent of all this is to make sure that prereleases
sort before releases.  Note also that this is still a subset of the
versioning schemes seen in the real world.  Modules with such strange
versions can still be used by Perl since by default Perl imports
external modules by exact version number.  (See S11.)  Only range
operations will be compromised by an unknown foreign collation order,
such as a system that sorts "delta" after "gamma".

=back

=head1 Context

=over 4

=item *

Perl still has the three main contexts: void, item (scalar), and list.

=item *

In addition to undifferentiated items, we also have these item contexts:

    Context     Type    OOtype  Operator
    -------     ----    ------  --------
    boolean     bit     Bit     ?
    integer     int     Int     int
    numeric     num     Num     +
    string      buf     Str     ~

There are also various container contexts that require particular kinds of
containers (such as slice and hash context; see S03 for details).

=item *

Unlike in Perl 5, objects are no longer always considered true.
It depends on the state of their C<.Bool> property.  Classes get to decide
which of their values are true and which are false.  Individual objects
can override the class definition:

不像在 Perl 5 中，对象不再始终认为 true。这取决于它们的 C<.Bool> 属性状态。类
能决定它们的值哪个是真，哪个是假。个别对象能覆盖类的定义：


    return 0 but True;

This overrides the C<.Bool> method of the C<0> without changing its
official type (by mixing the method into an anonymous derived type).

这个覆盖了 C<0> 的 C<.Bool> 方法，而没有改变它的正式类型（通过将方法混合成匿名
派生类型）。

=item *

The definition of C<.Bool> for the most ancestral type (that is, the
C<Object> type) is equivalent to C<.defined>.  Since type objects are
considered undefined, all type objects (including C<Object> itself)
are false unless the type overrides the definition of C<.Bool>
to include undefined values.  Instantiated objects default to true
unless the class overrides the definition.  Note that if you could
instantiate an C<Object> it would be considered defined, and thus true.
(It is not clear that this is allowed, however.)

=item *

In general any container types should return false if they are empty,
and true otherwise.  This is true of all the standard container types
except Scalar, which always defers the definition of truth to its
contents.  Non-container types define truthiness much as Perl 5 does.

Just as with the standard types, user-defined types should feel free
to partition their defined values into true and false values if such
a partition makes sense in control flow using boolean contexts, since
the separate C<.defined> method is always there if you need it.

=back

=head1 Lists

=over 4

=item *

List context in Perl 6 is by default lazy.  This means a list can
contain infinite generators without blowing up.  No flattening happens
to a lazy list until it is bound to the signature of a function or
method at call time (and maybe not even then).  We say that such
an argument list is "lazily flattened", meaning that we promise to
flatten the list on demand, but not before.

=item *

There is a "C<list>" operator which imposes a list context on
its arguments even if C<list> itself occurs in a item context.
In list context, it flattens lazily.  In an item context, it returns
the resulting list as a single C<List> object.  (So the C<list> operator
really does exactly the same thing as putting a list in parentheses with
at least one comma.  But it's more readable in some situations.)

To force a non-flattening item context, use the "C<item>" operator.

=item *

The C<|> prefix operator may be used to force "capture" context on its
argument and I<also> defeat any scalar argument checking imposed by
subroutine signature declarations.  Any resulting list arguments are
then evaluated lazily.

=item *

To force non-lazy list flattening, use the C<eager> list operator.
List assignment is also implicitly eager.

    eager $filehandle.lines;    # read all remaining lines

By contrast,

    $filehandle.lines;

makes no guarantee about how many lines ahead the iterator has read.
Iterators feeding a list are allowed to process in batches, even
when stored within an array.  The array knows that it is extensible,
and calls the iterator as it needs more elements.  (Counting the elements
in the array will also force eager completion.)

=item *

A variant of C<eager> is the C<hyper> list operator, which declares
not only that you want all the values generated now, but that you want
them badly enough that you don't care what order they're generated in.
That is, C<eager> requires sequential evaluation of the list, while
C<hyper> requests (but does not require) parallel evaluation.  In any
case, it declares that you don't care about the evaluation order.
(Conjecture: populating a hash from a hyper list of pairs could be done
as the results come in, such that some keys can be seen even before
the hyper is done.  Thinking about Map-Reduce algorithms here...)

=item *

Signatures on non-multi subs can be checked at compile time, whereas
multi sub and method call signatures can only be checked at run time
(in the absence of special instructions to the optimizer).

This is not a problem for arguments that are arrays or hashes,
since they don't have to care about their context, but just return
themselves in any event, which may or may not be lazily flattened.

However, function calls in the argument list can't know their eventual
context because the method hasn't been dispatched yet, so we don't
know which signature to check against.  As in Perl 5, list context
is assumed unless you explicitly qualify the argument with an item
context operator.

=item *

The C<< => >> operator now constructs C<Pair> objects rather than merely
functioning as a comma.  Both sides are in item context.

=item *
X<..>

The C<< .. >> operator now constructs a C<Range> object rather than merely
functioning as an operator.  Both sides are in item context.  Semantically,
the C<Range> acts like a list of its values to the extent possible, but
does so lazily, unlike Perl 5's eager range operator.

=item *

There is no such thing as a hash list context.  Assignment to a hash
produces an ordinary list context.  You may assign alternating keys
and values just as in Perl 5.  You may also assign lists of C<Pair> objects, in
which case each pair provides a key and a value.  You may, in fact,
mix the two forms, as long as the pairs come when a key is expected.
If you wish to supply a C<Pair> as a key, you must compose an outer C<Pair>
in which the key is the inner C<Pair>:

    %hash = (($keykey => $keyval) => $value);

=item *

The anonymous C<enum> function takes a list of keys or pairs, and adds
values to any keys that are not already part of a key.  The value added
is one more than the previous key or pair's value.  This works nicely with
the new C<qq:ww> form:

    %hash = enum <<:Mon(1) Tue Wed Thu Fri Sat Sun>>;
    %hash = enum « :Mon(1) Tue Wed Thu Fri Sat Sun »;

are the same as:

    %hash = ();
    %hash<Mon Tue Wed Thu Fri Sat Sun> = 1..7;

=item *

In contrast to assignment, binding to a hash requires a C<Hash> (or
C<Pair>) object.  Binding to a "splat" hash requires a list of pairs
or hashes, and stops processing the argument list when it runs out
of pairs or hashes.  See S06 for much more about parameter binding.

=back

=head1 Files

=over 4

=item *

Filename globs are no longer done with angle brackets.  Use the C<glob>
function.

=item *

Input from a filehandle is no longer done with angle brackets.  Instead
of

    while (<HANDLE>) {...}

you now write

    for @$handle {...}

or

    for $handle.lines {...}

=back

=head1 Properties

=over 4

=item *

Properties work as detailed in S12.  They're actually object
attributes provided by role mixins.  Compile-time properties applied
to containers and such still use the C<is> keyword, but are now called
"traits".  On the other hand, run-time properties are attached to
individual objects using the C<but> keyword instead, but are still
called "properties".

=item *

Properties are accessed just like attributes because they are in fact
attributes of some class or other, even if it's an anonymous singleton
class generated on the fly for that purpose.  Since "C<rw>" attributes
behave in all respects as variables, properties may therefore also
be temporized with C<temp>, or hypotheticalized with C<let>.

=back

=head1 Grammatical Categories

Lexing in Perl 6 is controlled by a system of grammatical categories.
At each point in the parse, the lexer knows which subset of the
grammatical categories are possible at that point, and follows the
longest-token rule across all the active grammatical categories.
The grammatical categories that are active at any point are specified
using a regex construct involving a set of magical hashes.  For example,
the matcher for the beginning of a statement might look like:

    <%statement_control
    | %scope_declarator
    | %prefix
    | %prefix_circumfix_meta_operator
    | %circumfix
    | %quote
    | %term
    >

(Ordering of grammatical categories within such a construct matters
only in case of a "tie", in which case the grammatical category that
is notionally "first" wins.  For instance, given the example above, a
statement_control is always going to win out over a prefix operator of
the same name.  And the reason you can't call a function named "if"
directly as a list operator is because it would be hidden either by
the statement_control category at the beginning of a statement or by
the statement_modifier category elsewhere in the statement.  Only the
C<if(...)> form unambiguously calls an "if" function, and even that
works only because statement controls and statement modifiers require
subsequent whitespace, as do list operators.)

Here are the current grammatical categories:

    category:<prefix>                           prefix:<+>
    circumfix:<[ ]>                             [ @x ]
    dotty:<.=>                                  $obj.=method
    infix_circumfix_meta_operator:{'»','«'}     @a »+« @b
    infix_postfix_meta_operator:<=>             $x += 2;
    infix_prefix_meta_operator:<!>              $x !~~ 2;
    infix:<+>                                   $x + $y
    package_declarator:<role>                   role Foo;
    postcircumfix:<[ ]>                         $x[$y] or $x.[$y]
    postfix_prefix_meta_operator:{'»'}          @array »++
    postfix:<++>                                $x++
    prefix_circumfix_meta_operator:{'[',']'}    [*]
    prefix_postfix_meta_operator:{'«'}          -« @magnitudes
    prefix:<!>                                  !$x (and $x.'!')
    q_backslash:<\\>                            '\\'
    qq_backslash:<n>                            "\n"
    quote_mod:<x>                               q:x/ ls /
    quote:<qq>                                  qq/foo/
    regex_assertion:<!>                         /<!before \h>/
    regex_backslash:<w>                         /\w/ and /\W/
    regex_metachar:<.>                          /.*/
    regex_mod_internal:<P5>                     m:/ ... :P5 ... /
    routine_declarator:<sub>                    sub foo {...}
    scope_declarator:<has>                      has $.x;
    sigil:<%>                                   %hash
    special_variable:<$!>                       $!
    statement_control:<if>                      if $condition { 1 } else { 2 }
    statement_mod_cond:<if>                     .say if $condition
    statement_mod_loop:<for>                    .say for 1..10
    statement_prefix:<gather>                   gather for @foo { .take }
    term:<!!!>                                  $x = { !!! }
    trait_auxiliary:<does>                      my $x does Freezable
    trait_verb:<handles>                        has $.tail handles <wag>
    twigil:<?>                                  $?LINE
    type_declarator:<subset>                    subset Nybble of Int where ^16
    version:<v>                                 v4.3.*

Any category containing "circumfix" requires two token arguments, supplied
in slice notation.  Note that many of these names do not represent real
operators, and you wouldn't be able to call them even though you can name
them.

=for vim:set expandtab sw=4:
